// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import * as environments from "../../../../../../environments.js";
import * as core from "../../../../../../core/index.js";
import * as Management from "../../../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import * as errors from "../../../../../../errors/index.js";

export declare namespace Connections {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class Connections {
    protected readonly _options: Connections.Options;

    constructor(_options: Connections.Options) {
        this._options = _options;
    }

    /**
     * Retrieve all connections that are enabled for the specified <a href="https://www.auth0.com/docs/get-started/applications"> Application</a>, using checkpoint pagination. A list of fields to include or exclude for each connection may also be specified.
     * <ul>
     *   <li>
     *     This endpoint requires the <code>read:connections</code> scope and any one of <code>read:clients</code> or <code>read:client_summary</code>.
     *   </li>
     *   <li>
     *     <b>Note</b>: The first time you call this endpoint, omit the <code>from</code> parameter. If there are more results, a <code>next</code> value is included in the response. You can use this for subsequent API calls. When <code>next</code> is no longer included in the response, no further results are remaining.
     *   </li>
     * </ul>
     *
     * @param {string} id - ID of the client for which to retrieve enabled connections.
     * @param {Management.ConnectionsGetRequest} request
     * @param {Connections.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.NotFoundError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.clients.connections.get("id", {
     *         from: "from",
     *         take: 1,
     *         fields: "fields",
     *         include_fields: true
     *     })
     */
    public async get(
        id: string,
        request: Management.ConnectionsGetRequest = {},
        requestOptions?: Connections.RequestOptions,
    ): Promise<core.Page<Management.ConnectionForList, Management.ListClientConnectionsResponseContent>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Management.ConnectionsGetRequest,
            ): Promise<core.WithRawResponse<Management.ListClientConnectionsResponseContent>> => {
                const { strategy, from: from_, take = 50, fields, include_fields: includeFields } = request;
                const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
                if (strategy !== undefined) {
                    if (Array.isArray(strategy)) {
                        _queryParams["strategy"] = strategy.map((item) => item);
                    } else {
                        _queryParams["strategy"] = strategy;
                    }
                }
                if (from_ !== undefined) {
                    _queryParams["from"] = from_;
                }
                if (take !== undefined) {
                    _queryParams["take"] = take?.toString() ?? null;
                }
                if (fields !== undefined) {
                    _queryParams["fields"] = fields;
                }
                if (includeFields !== undefined) {
                    _queryParams["include_fields"] = includeFields?.toString() ?? null;
                }
                let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    this._options?.headers,
                    mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            (await core.Supplier.get(this._options.environment)) ??
                            environments.ManagementEnvironment.Default,
                        `clients/${core.url.encodePathParam(id)}/connections`,
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        data: _response.body as Management.ListClientConnectionsResponseContent,
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Management.BadRequestError(
                                _response.error.body as unknown,
                                _response.rawResponse,
                            );
                        case 401:
                            throw new Management.UnauthorizedError(
                                _response.error.body as unknown,
                                _response.rawResponse,
                            );
                        case 403:
                            throw new Management.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                        case 404:
                            throw new Management.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                        case 429:
                            throw new Management.TooManyRequestsError(
                                _response.error.body as unknown,
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.ManagementError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.ManagementError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                            rawResponse: _response.rawResponse,
                        });
                    case "timeout":
                        throw new errors.ManagementTimeoutError(
                            "Timeout exceeded when calling GET /clients/{id}/connections.",
                        );
                    case "unknown":
                        throw new errors.ManagementError({
                            message: _response.error.errorMessage,
                            rawResponse: _response.rawResponse,
                        });
                }
            },
        );
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Management.ConnectionForList, Management.ListClientConnectionsResponseContent>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) =>
                response?.next != null && !(typeof response?.next === "string" && response?.next === ""),
            getItems: (response) => response?.connections ?? [],
            loadPage: (response) => {
                return list(core.setObjectProperty(request, "from", response?.next));
            },
        });
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
