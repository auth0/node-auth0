// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { normalizeClientOptions } from "../../../../BaseClient.js";
import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Management from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";
import { AuthenticationMethodsClient } from "../resources/authenticationMethods/client/Client.js";
import { AuthenticatorsClient } from "../resources/authenticators/client/Client.js";
import { ConnectedAccountsClient } from "../resources/connectedAccounts/client/Client.js";
import { EnrollmentsClient } from "../resources/enrollments/client/Client.js";
import { FederatedConnectionsTokensetsClient } from "../resources/federatedConnectionsTokensets/client/Client.js";
import { IdentitiesClient } from "../resources/identities/client/Client.js";
import { LogsClient } from "../resources/logs/client/Client.js";
import { MultifactorClient } from "../resources/multifactor/client/Client.js";
import { OrganizationsClient } from "../resources/organizations/client/Client.js";
import { PermissionsClient } from "../resources/permissions/client/Client.js";
import { RiskAssessmentsClient } from "../resources/riskAssessments/client/Client.js";
import { RolesClient } from "../resources/roles/client/Client.js";
import { RefreshTokenClient } from "../resources/refreshToken/client/Client.js";
import { SessionsClient } from "../resources/sessions/client/Client.js";

export declare namespace UsersClient {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class UsersClient {
    protected readonly _options: UsersClient.Options;
    protected _authenticationMethods: AuthenticationMethodsClient | undefined;
    protected _authenticators: AuthenticatorsClient | undefined;
    protected _connectedAccounts: ConnectedAccountsClient | undefined;
    protected _enrollments: EnrollmentsClient | undefined;
    protected _federatedConnectionsTokensets: FederatedConnectionsTokensetsClient | undefined;
    protected _identities: IdentitiesClient | undefined;
    protected _logs: LogsClient | undefined;
    protected _multifactor: MultifactorClient | undefined;
    protected _organizations: OrganizationsClient | undefined;
    protected _permissions: PermissionsClient | undefined;
    protected _riskAssessments: RiskAssessmentsClient | undefined;
    protected _roles: RolesClient | undefined;
    protected _refreshToken: RefreshTokenClient | undefined;
    protected _sessions: SessionsClient | undefined;

    constructor(options: UsersClient.Options) {
        this._options = normalizeClientOptions(options);
    }

    public get authenticationMethods(): AuthenticationMethodsClient {
        return (this._authenticationMethods ??= new AuthenticationMethodsClient(this._options));
    }

    public get authenticators(): AuthenticatorsClient {
        return (this._authenticators ??= new AuthenticatorsClient(this._options));
    }

    public get connectedAccounts(): ConnectedAccountsClient {
        return (this._connectedAccounts ??= new ConnectedAccountsClient(this._options));
    }

    public get enrollments(): EnrollmentsClient {
        return (this._enrollments ??= new EnrollmentsClient(this._options));
    }

    public get federatedConnectionsTokensets(): FederatedConnectionsTokensetsClient {
        return (this._federatedConnectionsTokensets ??= new FederatedConnectionsTokensetsClient(this._options));
    }

    public get identities(): IdentitiesClient {
        return (this._identities ??= new IdentitiesClient(this._options));
    }

    public get logs(): LogsClient {
        return (this._logs ??= new LogsClient(this._options));
    }

    public get multifactor(): MultifactorClient {
        return (this._multifactor ??= new MultifactorClient(this._options));
    }

    public get organizations(): OrganizationsClient {
        return (this._organizations ??= new OrganizationsClient(this._options));
    }

    public get permissions(): PermissionsClient {
        return (this._permissions ??= new PermissionsClient(this._options));
    }

    public get riskAssessments(): RiskAssessmentsClient {
        return (this._riskAssessments ??= new RiskAssessmentsClient(this._options));
    }

    public get roles(): RolesClient {
        return (this._roles ??= new RolesClient(this._options));
    }

    public get refreshToken(): RefreshTokenClient {
        return (this._refreshToken ??= new RefreshTokenClient(this._options));
    }

    public get sessions(): SessionsClient {
        return (this._sessions ??= new SessionsClient(this._options));
    }

    /**
     * Retrieve details of users. It is possible to:
     *
     * - Specify a search criteria for users
     * - Sort the users to be returned
     * - Select the fields to be returned
     * - Specify the number of users to retrieve per page and the page index
     *  <!-- only v3 is available -->
     * The <code>q</code> query parameter can be used to get users that match the specified criteria <a href="https://auth0.com/docs/users/search/v3/query-syntax">using query string syntax.</a>
     *
     * <a href="https://auth0.com/docs/users/search/v3">Learn more about searching for users.</a>
     *
     * Read about <a href="https://auth0.com/docs/users/search/best-practices">best practices</a> when working with the API endpoints for retrieving users.
     *
     * Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.
     *
     * @param {Management.ListUsersRequestParameters} request
     * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     * @throws {@link Management.ServiceUnavailableError}
     *
     * @example
     *     await client.users.list({
     *         page: 1,
     *         per_page: 1,
     *         include_totals: true,
     *         sort: "sort",
     *         connection: "connection",
     *         fields: "fields",
     *         include_fields: true,
     *         q: "q",
     *         search_engine: "v1",
     *         primary_order: true
     *     })
     */
    public async list(
        request: Management.ListUsersRequestParameters = {},
        requestOptions?: UsersClient.RequestOptions,
    ): Promise<core.Page<Management.UserResponseSchema, Management.ListUsersOffsetPaginatedResponseContent>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Management.ListUsersRequestParameters,
            ): Promise<core.WithRawResponse<Management.ListUsersOffsetPaginatedResponseContent>> => {
                const {
                    page = 0,
                    per_page: perPage = 50,
                    include_totals: includeTotals = true,
                    sort,
                    connection,
                    fields,
                    include_fields: includeFields,
                    q,
                    search_engine: searchEngine,
                    primary_order: primaryOrder,
                } = request;
                const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
                if (page !== undefined) {
                    _queryParams["page"] = page?.toString() ?? null;
                }
                if (perPage !== undefined) {
                    _queryParams["per_page"] = perPage?.toString() ?? null;
                }
                if (includeTotals !== undefined) {
                    _queryParams["include_totals"] = includeTotals?.toString() ?? null;
                }
                if (sort !== undefined) {
                    _queryParams["sort"] = sort;
                }
                if (connection !== undefined) {
                    _queryParams["connection"] = connection;
                }
                if (fields !== undefined) {
                    _queryParams["fields"] = fields;
                }
                if (includeFields !== undefined) {
                    _queryParams["include_fields"] = includeFields?.toString() ?? null;
                }
                if (q !== undefined) {
                    _queryParams["q"] = q;
                }
                if (searchEngine !== undefined) {
                    _queryParams["search_engine"] = searchEngine;
                }
                if (primaryOrder !== undefined) {
                    _queryParams["primary_order"] = primaryOrder?.toString() ?? null;
                }
                let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    this._options?.headers,
                    mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            (await core.Supplier.get(this._options.environment)) ??
                            environments.ManagementEnvironment.Default,
                        "users",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: _response.body as Management.ListUsersOffsetPaginatedResponseContent,
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Management.BadRequestError(
                                _response.error.body as unknown,
                                _response.rawResponse,
                            );
                        case 401:
                            throw new Management.UnauthorizedError(
                                _response.error.body as unknown,
                                _response.rawResponse,
                            );
                        case 403:
                            throw new Management.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                        case 429:
                            throw new Management.TooManyRequestsError(
                                _response.error.body as unknown,
                                _response.rawResponse,
                            );
                        case 503:
                            throw new Management.ServiceUnavailableError(
                                _response.error.body as unknown,
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.ManagementError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.ManagementError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                            rawResponse: _response.rawResponse,
                        });
                    case "timeout":
                        throw new errors.ManagementTimeoutError("Timeout exceeded when calling GET /users.");
                    case "unknown":
                        throw new errors.ManagementError({
                            message: _response.error.errorMessage,
                            rawResponse: _response.rawResponse,
                        });
                }
            },
        );
        let _offset = request?.page != null ? request?.page : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Management.UserResponseSchema, Management.ListUsersOffsetPaginatedResponseContent>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.users ?? []).length >= Math.floor(request?.per_page ?? 1),
            getItems: (response) => response?.users ?? [],
            loadPage: (response) => {
                _offset += response?.users != null ? response.users.length : 1;
                return list(core.setObjectProperty(request, "page", _offset));
            },
        });
    }

    /**
     * Create a new user for a given <a href="https://auth0.com/docs/connections/database">database</a> or <a href="https://auth0.com/docs/connections/passwordless">passwordless</a> connection.
     *
     * Note: <code>connection</code> is required but other parameters such as <code>email</code> and <code>password</code> are dependent upon the type of connection.
     *
     * @param {Management.CreateUserRequestContent} request
     * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.ConflictError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.create({
     *         connection: "connection"
     *     })
     */
    public create(
        request: Management.CreateUserRequestContent,
        requestOptions?: UsersClient.RequestOptions,
    ): core.HttpResponsePromise<Management.CreateUserResponseContent> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: Management.CreateUserRequestContent,
        requestOptions?: UsersClient.RequestOptions,
    ): Promise<core.WithRawResponse<Management.CreateUserResponseContent>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ManagementEnvironment.Default,
                "users",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Management.CreateUserResponseContent, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Management.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Management.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Management.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new Management.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Management.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ManagementError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ManagementTimeoutError("Timeout exceeded when calling POST /users.");
            case "unknown":
                throw new errors.ManagementError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Find users by email. If Auth0 is the identity provider (idP), the email address associated with a user is saved in lower case, regardless of how you initially provided it.
     *
     * For example, if you register a user as JohnSmith@example.com, Auth0 saves the user's email as johnsmith@example.com.
     *
     * Therefore, when using this endpoint, make sure that you are searching for users via email addresses using the correct case.
     *
     * @param {Management.ListUsersByEmailRequestParameters} request
     * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.listUsersByEmail({
     *         fields: "fields",
     *         include_fields: true,
     *         email: "email"
     *     })
     */
    public listUsersByEmail(
        request: Management.ListUsersByEmailRequestParameters,
        requestOptions?: UsersClient.RequestOptions,
    ): core.HttpResponsePromise<Management.UserResponseSchema[]> {
        return core.HttpResponsePromise.fromPromise(this.__listUsersByEmail(request, requestOptions));
    }

    private async __listUsersByEmail(
        request: Management.ListUsersByEmailRequestParameters,
        requestOptions?: UsersClient.RequestOptions,
    ): Promise<core.WithRawResponse<Management.UserResponseSchema[]>> {
        const { fields, include_fields: includeFields, email } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (fields !== undefined) {
            _queryParams["fields"] = fields;
        }

        if (includeFields !== undefined) {
            _queryParams["include_fields"] = includeFields?.toString() ?? null;
        }

        _queryParams["email"] = email;
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ManagementEnvironment.Default,
                "users-by-email",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Management.UserResponseSchema[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Management.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Management.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Management.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Management.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ManagementError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ManagementTimeoutError("Timeout exceeded when calling GET /users-by-email.");
            case "unknown":
                throw new errors.ManagementError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve user details. A list of fields to include or exclude may also be specified. For more information, see <a href="https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint">Retrieve Users with the Get Users Endpoint</a>.
     *
     * @param {string} id - ID of the user to retrieve.
     * @param {Management.GetUserRequestParameters} request
     * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.NotFoundError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.get("id", {
     *         fields: "fields",
     *         include_fields: true
     *     })
     */
    public get(
        id: string,
        request: Management.GetUserRequestParameters = {},
        requestOptions?: UsersClient.RequestOptions,
    ): core.HttpResponsePromise<Management.GetUserResponseContent> {
        return core.HttpResponsePromise.fromPromise(this.__get(id, request, requestOptions));
    }

    private async __get(
        id: string,
        request: Management.GetUserRequestParameters = {},
        requestOptions?: UsersClient.RequestOptions,
    ): Promise<core.WithRawResponse<Management.GetUserResponseContent>> {
        const { fields, include_fields: includeFields } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (fields !== undefined) {
            _queryParams["fields"] = fields;
        }

        if (includeFields !== undefined) {
            _queryParams["include_fields"] = includeFields?.toString() ?? null;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ManagementEnvironment.Default,
                `users/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Management.GetUserResponseContent, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Management.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Management.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Management.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Management.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Management.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ManagementError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ManagementTimeoutError("Timeout exceeded when calling GET /users/{id}.");
            case "unknown":
                throw new errors.ManagementError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Delete a user by user ID. This action cannot be undone. For Auth0 Dashboard instructions, see <a href="https://auth0.com/docs/manage-users/user-accounts/delete-users">Delete Users</a>.
     *
     * @param {string} id - ID of the user to delete.
     * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.delete("id")
     */
    public delete(id: string, requestOptions?: UsersClient.RequestOptions): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
    }

    private async __delete(
        id: string,
        requestOptions?: UsersClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ManagementEnvironment.Default,
                `users/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Management.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Management.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Management.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Management.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ManagementError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ManagementTimeoutError("Timeout exceeded when calling DELETE /users/{id}.");
            case "unknown":
                throw new errors.ManagementError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update a user.
     *
     * These are the attributes that can be updated at the root level:
     *
     * <ul>
     *     <li>app_metadata</li>
     *     <li>blocked</li>
     *     <li>email</li>
     *     <li>email_verified</li>
     *     <li>family_name</li>
     *     <li>given_name</li>
     *     <li>name</li>
     *     <li>nickname</li>
     *     <li>password</li>
     *     <li>phone_number</li>
     *     <li>phone_verified</li>
     *     <li>picture</li>
     *     <li>username</li>
     *     <li>user_metadata</li>
     *     <li>verify_email</li>
     * </ul>
     *
     * Some considerations:
     * <ul>
     *     <li>The properties of the new object will replace the old ones.</li>
     *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
     *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
     *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
     *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
     *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the "Unblock a user" endpoint from the "User Blocks" API to change the user's state.</li>
     *     <li>Supported attributes can be unset by supplying <code>null</code> as the value.</li>
     * </ul>
     *
     * <h5>Updating a field (non-metadata property)</h5>
     * To mark the email address of a user as verified, the body to send should be:
     * <pre><code>{ "email_verified": true }</code></pre>
     *
     * <h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
     * <pre><code>{ "user_metadata" : { "profileCode": 1479 } }</code></pre>
     *
     * To add the field <code>addresses</code> the body to send should be:
     * <pre><code>{ "user_metadata" : { "addresses": {"work_address": "100 Industrial Way"} }}</code></pre>
     *
     * The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
     *   "user_metadata": {
     *     "profileCode": 1479,
     *     "addresses": { "work_address": "100 Industrial Way" }
     *   }
     * }</code></pre>
     *
     * <h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>"home_address": "742 Evergreen Terrace"</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
     * <pre><code>{
     *   "user_metadata": {
     *     "addresses": {
     *       "work_address": "100 Industrial Way",
     *       "home_address": "742 Evergreen Terrace"
     *     }
     *   }
     * }</code></pre>
     *
     * The modified object ends up with the following <code>user_metadata</code> property:
     * <pre><code>{
     *   "user_metadata": {
     *     "profileCode": 1479,
     *     "addresses": {
     *       "work_address": "100 Industrial Way",
     *       "home_address": "742 Evergreen Terrace"
     *     }
     *   }
     * }</code></pre>
     *
     * @param {string} id - ID of the user to update.
     * @param {Management.UpdateUserRequestContent} request
     * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.NotFoundError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.update("id")
     */
    public update(
        id: string,
        request: Management.UpdateUserRequestContent = {},
        requestOptions?: UsersClient.RequestOptions,
    ): core.HttpResponsePromise<Management.UpdateUserResponseContent> {
        return core.HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
    }

    private async __update(
        id: string,
        request: Management.UpdateUserRequestContent = {},
        requestOptions?: UsersClient.RequestOptions,
    ): Promise<core.WithRawResponse<Management.UpdateUserResponseContent>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ManagementEnvironment.Default,
                `users/${core.url.encodePathParam(id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Management.UpdateUserResponseContent, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Management.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Management.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Management.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Management.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Management.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ManagementError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ManagementTimeoutError("Timeout exceeded when calling PATCH /users/{id}.");
            case "unknown":
                throw new errors.ManagementError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Remove an existing multi-factor authentication (MFA) <a href="https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa">recovery code</a> and generate a new one. If a user cannot access the original device or account used for MFA enrollment, they can use a recovery code to authenticate.
     *
     * @param {string} id - ID of the user to regenerate a multi-factor authentication recovery code for.
     * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.NotFoundError}
     *
     * @example
     *     await client.users.regenerateRecoveryCode("id")
     */
    public regenerateRecoveryCode(
        id: string,
        requestOptions?: UsersClient.RequestOptions,
    ): core.HttpResponsePromise<Management.RegenerateUsersRecoveryCodeResponseContent> {
        return core.HttpResponsePromise.fromPromise(this.__regenerateRecoveryCode(id, requestOptions));
    }

    private async __regenerateRecoveryCode(
        id: string,
        requestOptions?: UsersClient.RequestOptions,
    ): Promise<core.WithRawResponse<Management.RegenerateUsersRecoveryCodeResponseContent>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ManagementEnvironment.Default,
                `users/${core.url.encodePathParam(id)}/recovery-code-regeneration`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Management.RegenerateUsersRecoveryCodeResponseContent,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Management.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Management.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Management.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Management.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ManagementError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ManagementTimeoutError(
                    "Timeout exceeded when calling POST /users/{id}/recovery-code-regeneration.",
                );
            case "unknown":
                throw new errors.ManagementError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Revokes selected resources related to a user (sessions, refresh tokens, ...).
     *
     * @param {string} id - ID of the user.
     * @param {Management.RevokeUserAccessRequestContent} request
     * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.revokeAccess("id")
     */
    public revokeAccess(
        id: string,
        request: Management.RevokeUserAccessRequestContent = {},
        requestOptions?: UsersClient.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__revokeAccess(id, request, requestOptions));
    }

    private async __revokeAccess(
        id: string,
        request: Management.RevokeUserAccessRequestContent = {},
        requestOptions?: UsersClient.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ManagementEnvironment.Default,
                `users/${core.url.encodePathParam(id)}/revoke-access`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Management.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Management.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Management.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new Management.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ManagementError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ManagementTimeoutError(
                    "Timeout exceeded when calling POST /users/{id}/revoke-access.",
                );
            case "unknown":
                throw new errors.ManagementError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
