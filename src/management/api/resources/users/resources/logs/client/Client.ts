// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { normalizeClientOptionsWithAuth, type NormalizedClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import * as core from "../../../../../../core/index.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as environments from "../../../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../../../errors/index.js";
import * as Management from "../../../../../index.js";

export declare namespace LogsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class LogsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<LogsClient.Options>;

    constructor(options: LogsClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Retrieve log events for a specific user.
     *
     * Note: For more information on all possible event types, their respective acronyms and descriptions, see <a href="https://auth0.com/docs/logs/log-event-type-codes">Log Event Type Codes</a>.
     *
     * For more information on the list of fields that can be used in `sort`, see <a href="https://auth0.com/docs/logs/log-search-query-syntax#searchable-fields">Searchable Fields</a>.
     *
     * Auth0 <a href="https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#limitations">limits the number of logs</a> you can return by search criteria to 100 logs per request. Furthermore, you may only paginate through up to 1,000 search results. If you exceed this threshold, please redefine your search.
     *
     * @param {string} id - ID of the user of the logs to retrieve
     * @param {Management.ListUserLogsRequestParameters} request
     * @param {LogsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.logs.list("id", {
     *         page: 1,
     *         per_page: 1,
     *         sort: "sort",
     *         include_totals: true
     *     })
     */
    public async list(
        id: string,
        request: Management.ListUserLogsRequestParameters = {},
        requestOptions?: LogsClient.RequestOptions,
    ): Promise<core.Page<Management.Log, Management.UserListLogOffsetPaginatedResponseContent>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Management.ListUserLogsRequestParameters,
            ): Promise<core.WithRawResponse<Management.UserListLogOffsetPaginatedResponseContent>> => {
                const { page = 0, per_page: perPage = 50, sort, include_totals: includeTotals = true } = request;
                const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
                if (page !== undefined) {
                    _queryParams["page"] = page?.toString() ?? null;
                }
                if (perPage !== undefined) {
                    _queryParams["per_page"] = perPage?.toString() ?? null;
                }
                if (sort !== undefined) {
                    _queryParams["sort"] = sort;
                }
                if (includeTotals !== undefined) {
                    _queryParams["include_totals"] = includeTotals?.toString() ?? null;
                }
                const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
                let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    _authRequest.headers,
                    this._options?.headers,
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            (await core.Supplier.get(this._options.environment)) ??
                            environments.ManagementEnvironment.Default,
                        `users/${core.url.encodePathParam(id)}/logs`,
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                    fetchFn: this._options?.fetch,
                    logging: this._options.logging,
                });
                if (_response.ok) {
                    return {
                        data: _response.body as Management.UserListLogOffsetPaginatedResponseContent,
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Management.BadRequestError(
                                _response.error.body as unknown,
                                _response.rawResponse,
                            );
                        case 401:
                            throw new Management.UnauthorizedError(
                                _response.error.body as unknown,
                                _response.rawResponse,
                            );
                        case 403:
                            throw new Management.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                        case 429:
                            throw new Management.TooManyRequestsError(
                                _response.error.body as unknown,
                                _response.rawResponse,
                            );
                        default:
                            throw new errors.ManagementError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{id}/logs");
            },
        );
        let _offset = request?.page != null ? request?.page : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<Management.Log, Management.UserListLogOffsetPaginatedResponseContent>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.logs ?? []).length >= Math.floor(request?.per_page ?? 50),
            getItems: (response) => response?.logs ?? [],
            loadPage: (_response) => {
                _offset += 1;
                return list(core.setObjectProperty(request, "page", _offset));
            },
        });
    }
}
