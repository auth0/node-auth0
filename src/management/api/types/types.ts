// This file was auto-generated by Fern from our API Definition.

import * as Management from "../index.js";

export const OauthScope = {
    /**
     * Read Actions */
    ReadActions: "read:actions",
    /**
     * Create Actions */
    CreateActions: "create:actions",
    /**
     * Delete Actions */
    DeleteActions: "delete:actions",
    /**
     * Update Actions */
    UpdateActions: "update:actions",
    /**
     * Read Anomaly Blocks */
    ReadAnomalyBlocks: "read:anomaly_blocks",
    /**
     * Delete Anomaly Blocks */
    DeleteAnomalyBlocks: "delete:anomaly_blocks",
    /**
     * Read Shields */
    ReadShields: "read:shields",
    /**
     * Create Shields */
    CreateShields: "create:shields",
    /**
     * Update Shields */
    UpdateShields: "update:shields",
    /**
     * Read Attack Protection */
    ReadAttackProtection: "read:attack_protection",
    /**
     * Update Attack Protection */
    UpdateAttackProtection: "update:attack_protection",
    /**
     * Read Branding */
    ReadBranding: "read:branding",
    /**
     * Update Branding */
    UpdateBranding: "update:branding",
    /**
     * Read Phone Providers */
    ReadPhoneProviders: "read:phone_providers",
    /**
     * Create Phone Providers */
    CreatePhoneProviders: "create:phone_providers",
    /**
     * Update Phone Providers */
    UpdatePhoneProviders: "update:phone_providers",
    /**
     * Delete Phone Providers */
    DeletePhoneProviders: "delete:phone_providers",
    /**
     * Read Phone Templates */
    ReadPhoneTemplates: "read:phone_templates",
    /**
     * Create Phone Templates */
    CreatePhoneTemplates: "create:phone_templates",
    /**
     * Update Phone Templates */
    UpdatePhoneTemplates: "update:phone_templates",
    /**
     * Delete Phone Templates */
    DeletePhoneTemplates: "delete:phone_templates",
    /**
     * Delete Branding */
    DeleteBranding: "delete:branding",
    /**
     * Read Client Grants */
    ReadClientGrants: "read:client_grants",
    /**
     * Create Client Grants */
    CreateClientGrants: "create:client_grants",
    /**
     * Update Client Grants */
    UpdateClientGrants: "update:client_grants",
    /**
     * Delete Client Grants */
    DeleteClientGrants: "delete:client_grants",
    /**
     * Read Organization Client Grants */
    ReadOrganizationClientGrants: "read:organization_client_grants",
    /**
     * Read Clients */
    ReadClients: "read:clients",
    /**
     * Read Client Keys */
    ReadClientKeys: "read:client_keys",
    /**
     * Read Client Credentials */
    ReadClientCredentials: "read:client_credentials",
    /**
     * Read Client Summary */
    ReadClientSummary: "read:client_summary",
    /**
     * Create Clients */
    CreateClients: "create:clients",
    /**
     * Create Client Credentials */
    CreateClientCredentials: "create:client_credentials",
    /**
     * Update Client Credentials */
    UpdateClientCredentials: "update:client_credentials",
    /**
     * Delete Client Credentials */
    DeleteClientCredentials: "delete:client_credentials",
    /**
     * Update Clients */
    UpdateClients: "update:clients",
    /**
     * Update Client Keys */
    UpdateClientKeys: "update:client_keys",
    /**
     * Update Client Token Vault Privileged Access */
    UpdateClientTokenVaultPrivilegedAccess: "update:client_token_vault_privileged_access",
    /**
     * Delete Clients */
    DeleteClients: "delete:clients",
    /**
     * Read Connections */
    ReadConnections: "read:connections",
    /**
     * Read Connection Profiles */
    ReadConnectionProfiles: "read:connection_profiles",
    /**
     * Create Connection Profiles */
    CreateConnectionProfiles: "create:connection_profiles",
    /**
     * Update Connection Profiles */
    UpdateConnectionProfiles: "update:connection_profiles",
    /**
     * Delete Connection Profiles */
    DeleteConnectionProfiles: "delete:connection_profiles",
    /**
     * Create Connections */
    CreateConnections: "create:connections",
    /**
     * Update Connections */
    UpdateConnections: "update:connections",
    /**
     * Delete Connections */
    DeleteConnections: "delete:connections",
    /**
     * Read Directory Provisionings */
    ReadDirectoryProvisionings: "read:directory_provisionings",
    /**
     * Create Directory Provisionings */
    CreateDirectoryProvisionings: "create:directory_provisionings",
    /**
     * Update Directory Provisionings */
    UpdateDirectoryProvisionings: "update:directory_provisionings",
    /**
     * Delete Directory Provisionings */
    DeleteDirectoryProvisionings: "delete:directory_provisionings",
    /**
     * Read Users */
    ReadUsers: "read:users",
    /**
     * Read Connections Keys */
    ReadConnectionsKeys: "read:connections_keys",
    /**
     * Create Connections Keys */
    CreateConnectionsKeys: "create:connections_keys",
    /**
     * Update Connections Keys */
    UpdateConnectionsKeys: "update:connections_keys",
    /**
     * Read Scim Config */
    ReadScimConfig: "read:scim_config",
    /**
     * Create Scim Config */
    CreateScimConfig: "create:scim_config",
    /**
     * Update Scim Config */
    UpdateScimConfig: "update:scim_config",
    /**
     * Delete Scim Config */
    DeleteScimConfig: "delete:scim_config",
    /**
     * Read Scim Token */
    ReadScimToken: "read:scim_token",
    /**
     * Create Scim Token */
    CreateScimToken: "create:scim_token",
    /**
     * Delete Scim Token */
    DeleteScimToken: "delete:scim_token",
    /**
     * Delete Users */
    DeleteUsers: "delete:users",
    /**
     * Read Custom Domains */
    ReadCustomDomains: "read:custom_domains",
    /**
     * Create Custom Domains */
    CreateCustomDomains: "create:custom_domains",
    /**
     * Update Custom Domains */
    UpdateCustomDomains: "update:custom_domains",
    /**
     * Delete Custom Domains */
    DeleteCustomDomains: "delete:custom_domains",
    /**
     * Read Device Credentials */
    ReadDeviceCredentials: "read:device_credentials",
    /**
     * Create Current User Device Credentials */
    CreateCurrentUserDeviceCredentials: "create:current_user_device_credentials",
    /**
     * Delete Device Credentials */
    DeleteDeviceCredentials: "delete:device_credentials",
    /**
     * Delete Current User Device Credentials */
    DeleteCurrentUserDeviceCredentials: "delete:current_user_device_credentials",
    /**
     * Update Device Codes */
    UpdateDeviceCodes: "update:device_codes",
    /**
     * Read Device Codes */
    ReadDeviceCodes: "read:device_codes",
    /**
     * Create Test Email Dispatch */
    CreateTestEmailDispatch: "create:test_email_dispatch",
    /**
     * Create Email Templates */
    CreateEmailTemplates: "create:email_templates",
    /**
     * Read Email Templates */
    ReadEmailTemplates: "read:email_templates",
    /**
     * Update Email Templates */
    UpdateEmailTemplates: "update:email_templates",
    /**
     * Read Email Provider */
    ReadEmailProvider: "read:email_provider",
    /**
     * Create Email Provider */
    CreateEmailProvider: "create:email_provider",
    /**
     * Update Email Provider */
    UpdateEmailProvider: "update:email_provider",
    /**
     * Delete Email Provider */
    DeleteEmailProvider: "delete:email_provider",
    /**
     * Read Entitlements */
    ReadEntitlements: "read:entitlements",
    /**
     * Read Event Streams */
    ReadEventStreams: "read:event_streams",
    /**
     * Create Event Streams */
    CreateEventStreams: "create:event_streams",
    /**
     * Update Event Streams */
    UpdateEventStreams: "update:event_streams",
    /**
     * Delete Event Streams */
    DeleteEventStreams: "delete:event_streams",
    /**
     * Read Event Deliveries */
    ReadEventDeliveries: "read:event_deliveries",
    /**
     * Update Event Deliveries */
    UpdateEventDeliveries: "update:event_deliveries",
    /**
     * Read Extensions */
    ReadExtensions: "read:extensions",
    /**
     * Read Flows */
    ReadFlows: "read:flows",
    /**
     * Create Flows */
    CreateFlows: "create:flows",
    /**
     * Read Flows Vault Connections */
    ReadFlowsVaultConnections: "read:flows_vault_connections",
    /**
     * Create Flows Vault Connections */
    CreateFlowsVaultConnections: "create:flows_vault_connections",
    /**
     * Update Flows Vault Connections */
    UpdateFlowsVaultConnections: "update:flows_vault_connections",
    /**
     * Delete Flows Vault Connections */
    DeleteFlowsVaultConnections: "delete:flows_vault_connections",
    /**
     * Read Flows Executions */
    ReadFlowsExecutions: "read:flows_executions",
    /**
     * Delete Flows Executions */
    DeleteFlowsExecutions: "delete:flows_executions",
    /**
     * Update Flows */
    UpdateFlows: "update:flows",
    /**
     * Delete Flows */
    DeleteFlows: "delete:flows",
    /**
     * Read Forms */
    ReadForms: "read:forms",
    /**
     * Create Forms */
    CreateForms: "create:forms",
    /**
     * Update Forms */
    UpdateForms: "update:forms",
    /**
     * Delete Forms */
    DeleteForms: "delete:forms",
    /**
     * Read Grants */
    ReadGrants: "read:grants",
    /**
     * Delete Grants */
    DeleteGrants: "delete:grants",
    /**
     * Read Groups */
    ReadGroups: "read:groups",
    /**
     * Read Group Members */
    ReadGroupMembers: "read:group_members",
    /**
     * Create Guardian Enrollment Tickets */
    CreateGuardianEnrollmentTickets: "create:guardian_enrollment_tickets",
    /**
     * Read Guardian Enrollments */
    ReadGuardianEnrollments: "read:guardian_enrollments",
    /**
     * Delete Guardian Enrollments */
    DeleteGuardianEnrollments: "delete:guardian_enrollments",
    /**
     * Read Guardian Factors */
    ReadGuardianFactors: "read:guardian_factors",
    /**
     * Update Guardian Factors */
    UpdateGuardianFactors: "update:guardian_factors",
    /**
     * Read Mfa Policies */
    ReadMfaPolicies: "read:mfa_policies",
    /**
     * Update Mfa Policies */
    UpdateMfaPolicies: "update:mfa_policies",
    /**
     * Read Hooks */
    ReadHooks: "read:hooks",
    /**
     * Create Hooks */
    CreateHooks: "create:hooks",
    /**
     * Update Hooks */
    UpdateHooks: "update:hooks",
    /**
     * Delete Hooks */
    DeleteHooks: "delete:hooks",
    /**
     * Read Insights */
    ReadInsights: "read:insights",
    /**
     * Read Stats */
    ReadStats: "read:stats",
    /**
     * Read Integrations */
    ReadIntegrations: "read:integrations",
    /**
     * Create Integrations */
    CreateIntegrations: "create:integrations",
    /**
     * Update Integrations */
    UpdateIntegrations: "update:integrations",
    /**
     * Delete Integrations */
    DeleteIntegrations: "delete:integrations",
    /**
     * Create Users */
    CreateUsers: "create:users",
    /**
     * Update Users */
    UpdateUsers: "update:users",
    /**
     * Read Custom Signing Keys */
    ReadCustomSigningKeys: "read:custom_signing_keys",
    /**
     * Create Custom Signing Keys */
    CreateCustomSigningKeys: "create:custom_signing_keys",
    /**
     * Update Custom Signing Keys */
    UpdateCustomSigningKeys: "update:custom_signing_keys",
    /**
     * Delete Custom Signing Keys */
    DeleteCustomSigningKeys: "delete:custom_signing_keys",
    /**
     * Read Encryption Keys */
    ReadEncryptionKeys: "read:encryption_keys",
    /**
     * Create Encryption Keys */
    CreateEncryptionKeys: "create:encryption_keys",
    /**
     * Update Encryption Keys */
    UpdateEncryptionKeys: "update:encryption_keys",
    /**
     * Delete Encryption Keys */
    DeleteEncryptionKeys: "delete:encryption_keys",
    /**
     * Read Signing Keys */
    ReadSigningKeys: "read:signing_keys",
    /**
     * Create Signing Keys */
    CreateSigningKeys: "create:signing_keys",
    /**
     * Update Signing Keys */
    UpdateSigningKeys: "update:signing_keys",
    /**
     * Read Log Streams */
    ReadLogStreams: "read:log_streams",
    /**
     * Create Log Streams */
    CreateLogStreams: "create:log_streams",
    /**
     * Update Log Streams */
    UpdateLogStreams: "update:log_streams",
    /**
     * Delete Log Streams */
    DeleteLogStreams: "delete:log_streams",
    /**
     * Read Logs */
    ReadLogs: "read:logs",
    /**
     * Read Logs Users */
    ReadLogsUsers: "read:logs_users",
    /**
     * Read Tenant Settings */
    ReadTenantSettings: "read:tenant_settings",
    /**
     * Update Tenant Settings */
    UpdateTenantSettings: "update:tenant_settings",
    /**
     * Read Network Acls */
    ReadNetworkAcls: "read:network_acls",
    /**
     * Create Network Acls */
    CreateNetworkAcls: "create:network_acls",
    /**
     * Update Network Acls */
    UpdateNetworkAcls: "update:network_acls",
    /**
     * Delete Network Acls */
    DeleteNetworkAcls: "delete:network_acls",
    /**
     * Read Organizations */
    ReadOrganizations: "read:organizations",
    /**
     * Read Organizations Summary */
    ReadOrganizationsSummary: "read:organizations_summary",
    /**
     * Create Organizations */
    CreateOrganizations: "create:organizations",
    /**
     * Create Organization Connections */
    CreateOrganizationConnections: "create:organization_connections",
    /**
     * Update Organizations */
    UpdateOrganizations: "update:organizations",
    /**
     * Delete Organizations */
    DeleteOrganizations: "delete:organizations",
    /**
     * Create Organization Client Grants */
    CreateOrganizationClientGrants: "create:organization_client_grants",
    /**
     * Delete Organization Client Grants */
    DeleteOrganizationClientGrants: "delete:organization_client_grants",
    /**
     * Read Organization Connections */
    ReadOrganizationConnections: "read:organization_connections",
    /**
     * Update Organization Connections */
    UpdateOrganizationConnections: "update:organization_connections",
    /**
     * Delete Organization Connections */
    DeleteOrganizationConnections: "delete:organization_connections",
    /**
     * Read Organization Discovery Domains */
    ReadOrganizationDiscoveryDomains: "read:organization_discovery_domains",
    /**
     * Create Organization Discovery Domains */
    CreateOrganizationDiscoveryDomains: "create:organization_discovery_domains",
    /**
     * Update Organization Discovery Domains */
    UpdateOrganizationDiscoveryDomains: "update:organization_discovery_domains",
    /**
     * Delete Organization Discovery Domains */
    DeleteOrganizationDiscoveryDomains: "delete:organization_discovery_domains",
    /**
     * Read Organization Invitations */
    ReadOrganizationInvitations: "read:organization_invitations",
    /**
     * Create Organization Invitations */
    CreateOrganizationInvitations: "create:organization_invitations",
    /**
     * Delete Organization Invitations */
    DeleteOrganizationInvitations: "delete:organization_invitations",
    /**
     * Read Organization Members */
    ReadOrganizationMembers: "read:organization_members",
    /**
     * Create Organization Members */
    CreateOrganizationMembers: "create:organization_members",
    /**
     * Delete Organization Members */
    DeleteOrganizationMembers: "delete:organization_members",
    /**
     * Read Organization Member Roles */
    ReadOrganizationMemberRoles: "read:organization_member_roles",
    /**
     * Create Organization Member Roles */
    CreateOrganizationMemberRoles: "create:organization_member_roles",
    /**
     * Delete Organization Member Roles */
    DeleteOrganizationMemberRoles: "delete:organization_member_roles",
    /**
     * Read Prompts */
    ReadPrompts: "read:prompts",
    /**
     * Update Prompts */
    UpdatePrompts: "update:prompts",
    /**
     * Read Resource Servers */
    ReadResourceServers: "read:resource_servers",
    /**
     * Update Resource Servers */
    UpdateResourceServers: "update:resource_servers",
    /**
     * Read Refresh Tokens */
    ReadRefreshTokens: "read:refresh_tokens",
    /**
     * Delete Refresh Tokens */
    DeleteRefreshTokens: "delete:refresh_tokens",
    /**
     * Create Resource Servers */
    CreateResourceServers: "create:resource_servers",
    /**
     * Delete Resource Servers */
    DeleteResourceServers: "delete:resource_servers",
    /**
     * Read Roles */
    ReadRoles: "read:roles",
    /**
     * Create Roles */
    CreateRoles: "create:roles",
    /**
     * Update Roles */
    UpdateRoles: "update:roles",
    /**
     * Delete Roles */
    DeleteRoles: "delete:roles",
    /**
     * Read Role Members */
    ReadRoleMembers: "read:role_members",
    /**
     * Create Role Members */
    CreateRoleMembers: "create:role_members",
    /**
     * Read Rules */
    ReadRules: "read:rules",
    /**
     * Create Rules */
    CreateRules: "create:rules",
    /**
     * Update Rules */
    UpdateRules: "update:rules",
    /**
     * Read Rules Configs */
    ReadRulesConfigs: "read:rules_configs",
    /**
     * Update Rules Configs */
    UpdateRulesConfigs: "update:rules_configs",
    /**
     * Delete Rules Configs */
    DeleteRulesConfigs: "delete:rules_configs",
    /**
     * Delete Rules */
    DeleteRules: "delete:rules",
    /**
     * Read Security Metrics */
    ReadSecurityMetrics: "read:security_metrics",
    /**
     * Read Self Service Profiles */
    ReadSelfServiceProfiles: "read:self_service_profiles",
    /**
     * Create Self Service Profiles */
    CreateSelfServiceProfiles: "create:self_service_profiles",
    /**
     * Update Self Service Profiles */
    UpdateSelfServiceProfiles: "update:self_service_profiles",
    /**
     * Delete Self Service Profiles */
    DeleteSelfServiceProfiles: "delete:self_service_profiles",
    /**
     * Read Self Service Profile Custom Texts */
    ReadSelfServiceProfileCustomTexts: "read:self_service_profile_custom_texts",
    /**
     * Update Self Service Profile Custom Texts */
    UpdateSelfServiceProfileCustomTexts: "update:self_service_profile_custom_texts",
    /**
     * Create Sso Access Tickets */
    CreateSsoAccessTickets: "create:sso_access_tickets",
    /**
     * Delete Sso Access Tickets */
    DeleteSsoAccessTickets: "delete:sso_access_tickets",
    /**
     * Read Sessions */
    ReadSessions: "read:sessions",
    /**
     * Update Sessions */
    UpdateSessions: "update:sessions",
    /**
     * Delete Sessions */
    DeleteSessions: "delete:sessions",
    /**
     * Delete Tenants */
    DeleteTenants: "delete:tenants",
    /**
     * Run Checks */
    RunChecks: "run:checks",
    /**
     * Read Checks */
    ReadChecks: "read:checks",
    /**
     * Read Tenant Feature Flags */
    ReadTenantFeatureFlags: "read:tenant_feature_flags",
    /**
     * Read Tenant Invitations */
    ReadTenantInvitations: "read:tenant_invitations",
    /**
     * Create Tenant Invitations */
    CreateTenantInvitations: "create:tenant_invitations",
    /**
     * Update Tenant Invitations */
    UpdateTenantInvitations: "update:tenant_invitations",
    /**
     * Delete Tenant Invitations */
    DeleteTenantInvitations: "delete:tenant_invitations",
    /**
     * Read Tenant Members */
    ReadTenantMembers: "read:tenant_members",
    /**
     * Update Tenant Members */
    UpdateTenantMembers: "update:tenant_members",
    /**
     * Delete Tenant Members */
    DeleteTenantMembers: "delete:tenant_members",
    /**
     * Read Owners */
    ReadOwners: "read:owners",
    /**
     * Delete Owners */
    DeleteOwners: "delete:owners",
    /**
     * Create User Tickets */
    CreateUserTickets: "create:user_tickets",
    /**
     * Read Token Exchange Profiles */
    ReadTokenExchangeProfiles: "read:token_exchange_profiles",
    /**
     * Create Token Exchange Profiles */
    CreateTokenExchangeProfiles: "create:token_exchange_profiles",
    /**
     * Update Token Exchange Profiles */
    UpdateTokenExchangeProfiles: "update:token_exchange_profiles",
    /**
     * Delete Token Exchange Profiles */
    DeleteTokenExchangeProfiles: "delete:token_exchange_profiles",
    /**
     * Read Entity Counts */
    ReadEntityCounts: "read:entity_counts",
    /**
     * Read User Attribute Profiles */
    ReadUserAttributeProfiles: "read:user_attribute_profiles",
    /**
     * Create User Attribute Profiles */
    CreateUserAttributeProfiles: "create:user_attribute_profiles",
    /**
     * Update User Attribute Profiles */
    UpdateUserAttributeProfiles: "update:user_attribute_profiles",
    /**
     * Delete User Attribute Profiles */
    DeleteUserAttributeProfiles: "delete:user_attribute_profiles",
    /**
     * Read User Idp Tokens */
    ReadUserIdpTokens: "read:user_idp_tokens",
    /**
     * Read Current User */
    ReadCurrentUser: "read:current_user",
    /**
     * Update Users App Metadata */
    UpdateUsersAppMetadata: "update:users_app_metadata",
    /**
     * Update Current User Metadata */
    UpdateCurrentUserMetadata: "update:current_user_metadata",
    /**
     * Delete Current User */
    DeleteCurrentUser: "delete:current_user",
    /**
     * Read User Application Passwords */
    ReadUserApplicationPasswords: "read:user_application_passwords",
    /**
     * Create User Application Passwords */
    CreateUserApplicationPasswords: "create:user_application_passwords",
    /**
     * Delete User Application Passwords */
    DeleteUserApplicationPasswords: "delete:user_application_passwords",
    /**
     * Read Authentication Methods */
    ReadAuthenticationMethods: "read:authentication_methods",
    /**
     * Update Authentication Methods */
    UpdateAuthenticationMethods: "update:authentication_methods",
    /**
     * Create Authentication Methods */
    CreateAuthenticationMethods: "create:authentication_methods",
    /**
     * Delete Authentication Methods */
    DeleteAuthenticationMethods: "delete:authentication_methods",
    /**
     * Read Federated Connections Tokens */
    ReadFederatedConnectionsTokens: "read:federated_connections_tokens",
    /**
     * Delete Federated Connections Tokens */
    DeleteFederatedConnectionsTokens: "delete:federated_connections_tokens",
    /**
     * Update Current User Identities */
    UpdateCurrentUserIdentities: "update:current_user_identities",
    /**
     * Delete Role Members */
    DeleteRoleMembers: "delete:role_members",
    /**
     * Read Vdcs Templates */
    ReadVdcsTemplates: "read:vdcs_templates",
    /**
     * Create Vdcs Templates */
    CreateVdcsTemplates: "create:vdcs_templates",
    /**
     * Update Vdcs Templates */
    UpdateVdcsTemplates: "update:vdcs_templates",
    /**
     * Delete Vdcs Templates */
    DeleteVdcsTemplates: "delete:vdcs_templates",
} as const;
export type OauthScope = (typeof OauthScope)[keyof typeof OauthScope];

export interface Action {
    /** The unique ID of the action. */
    id?: string;
    /** The name of an action. */
    name?: string;
    /** The list of triggers that this action supports. At this time, an action can only target a single trigger at a time. */
    supported_triggers?: Management.ActionTrigger[];
    /** True if all of an Action's contents have been deployed. */
    all_changes_deployed?: boolean;
    /** The time when this action was created. */
    created_at?: string;
    /** The time when this action was updated. */
    updated_at?: string;
    /** The source code of the action. */
    code?: string;
    /** The list of third party npm modules, and their versions, that this action depends on. */
    dependencies?: Management.ActionVersionDependency[];
    /** The Node runtime. For example: `node22`, defaults to `node22` */
    runtime?: string;
    /** The list of secrets that are included in an action or a version of an action. */
    secrets?: Management.ActionSecretResponse[];
    deployed_version?: Management.ActionDeployedVersion;
    /** installed_integration_id is the fk reference to the InstalledIntegration entity. */
    installed_integration_id?: string;
    integration?: Management.Integration;
    status?: Management.ActionBuildStatusEnum;
    /** The time when this action was built successfully. */
    built_at?: string;
    /** True if the action should be deployed after creation. */
    deploy?: boolean;
}

/**
 * The action to which this version belongs.
 */
export interface ActionBase {
    /** The unique ID of the action. */
    id?: string;
    /** The name of an action. */
    name?: string;
    /** The list of triggers that this action supports. At this time, an action can only target a single trigger at a time. */
    supported_triggers?: Management.ActionTrigger[];
    /** True if all of an Action's contents have been deployed. */
    all_changes_deployed?: boolean;
    /** The time when this action was created. */
    created_at?: string;
    /** The time when this action was updated. */
    updated_at?: string;
}

/**
 * Binding is the associative entity joining a trigger, and an action together.
 */
export interface ActionBinding {
    /** The unique ID of this binding. */
    id?: string;
    trigger_id?: Management.ActionTriggerTypeEnum;
    /** The name of the binding. */
    display_name?: string;
    action?: Management.Action;
    /** The time when the binding was created. */
    created_at?: string;
    /** The time when the binding was updated. */
    updated_at?: string;
}

/**
 * A reference to an action. An action can be referred to by ID or by Name.
 */
export interface ActionBindingRef {
    type?: Management.ActionBindingRefTypeEnum;
    /** The id or name of an action that is being bound to a trigger. */
    value?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** How the action is being referred to: `action_id` or `action_name`. */
export const ActionBindingRefTypeEnum = {
    BindingId: "binding_id",
    ActionId: "action_id",
    ActionName: "action_name",
} as const;
export type ActionBindingRefTypeEnum = (typeof ActionBindingRefTypeEnum)[keyof typeof ActionBindingRefTypeEnum];

/** In order to execute an Action, it must be bound to a trigger using a binding. `trigger-bound` means that bindings are managed by the tenant. `entity-bound` means that the bindings are automatically managed by Auth0 and other internal resouces will control those bindings. Tenants cannot manage `entity-bound` bindings. */
export const ActionBindingTypeEnum = {
    TriggerBound: "trigger-bound",
    EntityBound: "entity-bound",
} as const;
export type ActionBindingTypeEnum = (typeof ActionBindingTypeEnum)[keyof typeof ActionBindingTypeEnum];

export interface ActionBindingWithRef {
    ref: Management.ActionBindingRef;
    /** The name of the binding. */
    display_name?: string;
    /** The list of secrets that are included in an action or a version of an action. */
    secrets?: Management.ActionSecretRequest[];
}

/** The build status of this action. */
export const ActionBuildStatusEnum = {
    Pending: "pending",
    Building: "building",
    Packaged: "packaged",
    Built: "built",
    Retrying: "retrying",
    Failed: "failed",
} as const;
export type ActionBuildStatusEnum = (typeof ActionBuildStatusEnum)[keyof typeof ActionBuildStatusEnum];

/**
 * The version of the action that is currently deployed.
 */
export interface ActionDeployedVersion {
    /** The unique id of an action version. */
    id?: string;
    /** The id of the action to which this version belongs. */
    action_id?: string;
    /** The source code of this specific version of the action. */
    code?: string;
    /** The list of third party npm modules, and their versions, that this specific version depends on. */
    dependencies?: Management.ActionVersionDependency[];
    /** Indicates if this specific version is the currently one deployed. */
    deployed?: boolean;
    /** The Node runtime. For example: `node22` */
    runtime?: string;
    /** The list of secrets that are included in an action or a version of an action. */
    secrets?: Management.ActionSecretResponse[];
    status?: Management.ActionVersionBuildStatusEnum;
    /** The index of this version in list of versions for the action. */
    number?: number;
    /** Any errors that occurred while the version was being built. */
    errors?: Management.ActionError[];
    action?: Management.ActionBase;
    /** The time when this version was built successfully. */
    built_at?: string;
    /** The time when this version was created. */
    created_at?: string;
    /** The time when a version was updated. Versions are never updated externally. Only Auth0 will update an action version as it is being built. */
    updated_at?: string;
    /** The list of triggers that this version supports. At this time, a version can only target a single trigger at a time. */
    supported_triggers?: Management.ActionTrigger[];
}

/**
 * Error is a generic error with a human readable id which should be easily referenced in support tickets.
 */
export interface ActionError {
    id?: string;
    msg?: string;
    url?: string;
}

/**
 * Captures the results of a single action being executed.
 */
export interface ActionExecutionResult {
    /** The name of the action that was executed. */
    action_name?: string;
    error?: Management.ActionError;
    /** The time when the action was started. */
    started_at?: string;
    /** The time when the action finished executing. */
    ended_at?: string;
}

/** The overall status of an execution. */
export const ActionExecutionStatusEnum = {
    Unspecified: "unspecified",
    Pending: "pending",
    Final: "final",
    Partial: "partial",
    Canceled: "canceled",
    Suspended: "suspended",
} as const;
export type ActionExecutionStatusEnum = (typeof ActionExecutionStatusEnum)[keyof typeof ActionExecutionStatusEnum];

export interface ActionSecretRequest {
    /** The name of the particular secret, e.g. API_KEY. */
    name?: string;
    /** The value of the particular secret, e.g. secret123. A secret's value can only be set upon creation. A secret's value will never be returned by the API. */
    value?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface ActionSecretResponse {
    /** The name of the particular secret, e.g. API_KEY. */
    name?: string;
    /** The time when the secret was last updated. */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface ActionTrigger {
    id: Management.ActionTriggerTypeEnum;
    /** The version of a trigger. v1, v2, etc. */
    version?: string;
    /** status points to the trigger status. */
    status?: string;
    /** runtimes supported by this trigger. */
    runtimes?: string[];
    /** Runtime that will be used when none is specified when creating an action. */
    default_runtime?: string;
    /** compatible_triggers informs which other trigger supports the same event and api. */
    compatible_triggers?: Management.ActionTriggerCompatibleTrigger[];
    binding_policy?: Management.ActionBindingTypeEnum;
}

export interface ActionTriggerCompatibleTrigger {
    id: Management.ActionTriggerTypeEnum;
    /** The version of a trigger. v1, v2, etc. */
    version: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * An actions extensibility point.
 */
export type ActionTriggerTypeEnum = string;

export interface ActionVersion {
    /** The unique id of an action version. */
    id?: string;
    /** The id of the action to which this version belongs. */
    action_id?: string;
    /** The source code of this specific version of the action. */
    code?: string;
    /** The list of third party npm modules, and their versions, that this specific version depends on. */
    dependencies?: Management.ActionVersionDependency[];
    /** Indicates if this specific version is the currently one deployed. */
    deployed?: boolean;
    /** The Node runtime. For example: `node22` */
    runtime?: string;
    /** The list of secrets that are included in an action or a version of an action. */
    secrets?: Management.ActionSecretResponse[];
    status?: Management.ActionVersionBuildStatusEnum;
    /** The index of this version in list of versions for the action. */
    number?: number;
    /** Any errors that occurred while the version was being built. */
    errors?: Management.ActionError[];
    action?: Management.ActionBase;
    /** The time when this version was built successfully. */
    built_at?: string;
    /** The time when this version was created. */
    created_at?: string;
    /** The time when a version was updated. Versions are never updated externally. Only Auth0 will update an action version as it is being built. */
    updated_at?: string;
    /** The list of triggers that this version supports. At this time, a version can only target a single trigger at a time. */
    supported_triggers?: Management.ActionTrigger[];
}

/** The build status of this specific version. */
export const ActionVersionBuildStatusEnum = {
    Pending: "pending",
    Building: "building",
    Packaged: "packaged",
    Built: "built",
    Retrying: "retrying",
    Failed: "failed",
} as const;
export type ActionVersionBuildStatusEnum =
    (typeof ActionVersionBuildStatusEnum)[keyof typeof ActionVersionBuildStatusEnum];

/**
 * Dependency is an npm module. These values are used to produce an immutable artifact, which manifests as a layer_id.
 */
export interface ActionVersionDependency {
    /** name is the name of the npm module, e.g. lodash */
    name?: string;
    /** description is the version of the npm module, e.g. 4.17.1 */
    version?: string;
    /** registry_url is an optional value used primarily for private npm registries. */
    registry_url?: string;
}

/**
 * Client array filter items
 */
export type AculClientFilter = Management.AculClientFilterById | Management.AculClientFilterByMetadata;

export interface AculClientFilterById {
    /** Client ID */
    id: string;
}

export interface AculClientFilterByMetadata {
    metadata: Management.AculClientMetadata;
}

/**
 * Client metadata key/value pairs
 */
export type AculClientMetadata = Record<string, unknown>;

export interface AculConfigsItem {
    prompt: Management.PromptGroupNameEnum;
    screen: Management.ScreenGroupNameEnum;
    rendering_mode?: Management.AculRenderingModeEnum;
    context_configuration?: Management.AculContextConfiguration;
    default_head_tags_disabled?: (Management.AculDefaultHeadTagsDisabled | undefined) | null;
    head_tags?: Management.AculHeadTags;
    filters?: Management.AculFilters | null;
    use_page_template?: (Management.AculUsePageTemplate | undefined) | null;
}

/**
 * Array of screen configurations to update
 */
export type AculConfigs = Management.AculConfigsItem[];

/**
 * Context values to make available
 */
export type AculContextConfiguration = Management.AculContextConfigurationItem[];

export type AculContextConfigurationItem = string;

/**
 * Override Universal Login default head tags
 */
export type AculDefaultHeadTagsDisabled = (boolean | null) | undefined;

/**
 * Domains array filter items
 */
export type AculDomainFilter = Management.AculDomainFilterById | Management.AculDomainFilterByMetadata;

export interface AculDomainFilterById {
    /** Domain ID */
    id: string;
}

export interface AculDomainFilterByMetadata {
    metadata: Management.AculDomainMetadata;
}

/**
 * Domain metadata key/value pairs
 */
export type AculDomainMetadata = Record<string, unknown>;

/**
 * Optional filters to apply rendering rules to specific entities
 */
export interface AculFilters {
    match_type?: Management.AculMatchTypeEnum;
    /** Clients filter */
    clients?: Management.AculClientFilter[];
    /** Organizations filter */
    organizations?: Management.AculOrganizationFilter[];
    /** Domains filter */
    domains?: Management.AculDomainFilter[];
}

export interface AculHeadTag {
    /** Any HTML element valid for use in the head tag */
    tag?: string;
    attributes?: Management.AculHeadTagAttributes;
    /**
     * Text/content within the opening and closing tags of the element.
     * See <a href="https://auth0.com/docs/customize/login-pages/advanced-customizations/getting-started/configure-acul-screens">documentation</a> on using context variables
     */
    content?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Attributes of the HTML tag
 */
export interface AculHeadTagAttributes {
    integrity?: string[];
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * An array of head tags
 */
export type AculHeadTags = Management.AculHeadTag[];

/** Type of match to apply */
export const AculMatchTypeEnum = {
    IncludesAny: "includes_any",
    ExcludesAny: "excludes_any",
} as const;
export type AculMatchTypeEnum = (typeof AculMatchTypeEnum)[keyof typeof AculMatchTypeEnum];

/**
 * Organizations array filter items
 */
export type AculOrganizationFilter =
    | Management.AculOrganizationFilterById
    | Management.AculOrganizationFilterByMetadata;

export interface AculOrganizationFilterById {
    /** Organization ID */
    id: string;
}

export interface AculOrganizationFilterByMetadata {
    metadata: Management.AculOrganizationMetadata;
}

/**
 * Organization metadata key/value pairs
 */
export type AculOrganizationMetadata = Record<string, unknown>;

/** Rendering mode to filter by */
export const AculRenderingModeEnum = {
    Advanced: "advanced",
    Standard: "standard",
} as const;
export type AculRenderingModeEnum = (typeof AculRenderingModeEnum)[keyof typeof AculRenderingModeEnum];

export interface AculResponseContent {
    rendering_mode?: Management.AculRenderingModeEnum;
    /** Context values to make available */
    context_configuration?: string[];
    /** Override Universal Login default head tags */
    default_head_tags_disabled?: boolean | null;
    /** An array of head tags */
    head_tags?: Management.AculHeadTag[];
    filters?: Management.AculFilters | null;
    /** Use page template with ACUL */
    use_page_template?: boolean | null;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Use page template with ACUL
 */
export type AculUsePageTemplate = (boolean | null) | undefined;

export interface AddOrganizationConnectionResponseContent {
    /** ID of the connection. */
    connection_id?: string;
    /** When true, all users that log in with this connection will be automatically granted membership in the organization. When false, users must be granted membership in the organization before logging in with this connection. */
    assign_membership_on_login?: boolean;
    /** Determines whether a connection should be displayed on this organizationâ€™s login prompt. Only applicable for enterprise connections. Default: true. */
    show_as_button?: boolean;
    /** Determines whether organization signup should be enabled for this organization connection. Only applicable for database connections. Default: false. */
    is_signup_enabled?: boolean;
    connection?: Management.OrganizationConnectionInformation;
}

/**
 * IP address to check.
 */
export type AnomalyIpFormat = string;

/**
 * Data related to the user that does affect the application's core functionality.
 */
export type AppMetadata = Record<string, unknown>;

export type AssessorsTypeEnum = "new-device";

export interface AssociateOrganizationClientGrantResponseContent {
    /** ID of the client grant. */
    id?: string;
    /** ID of the client. */
    client_id?: string;
    /** The audience (API identifier) of this client grant */
    audience?: string;
    /** Scopes allowed for this client grant. */
    scope?: string[];
    organization_usage?: Management.OrganizationUsageEnum;
    /** If enabled, any organization can be used with this grant. If disabled (default), the grant must be explicitly assigned to the desired organizations. */
    allow_any_organization?: boolean;
}

export const AsyncApprovalNotificationsChannelsEnum = {
    GuardianPush: "guardian-push",
    Email: "email",
} as const;
export type AsyncApprovalNotificationsChannelsEnum =
    (typeof AsyncApprovalNotificationsChannelsEnum)[keyof typeof AsyncApprovalNotificationsChannelsEnum];

export interface AttackProtectionCaptchaArkoseResponseContent {
    /** The site key for the Arkose captcha provider. */
    site_key?: string;
    /** Whether the captcha should fail open. */
    fail_open?: boolean;
    /** The subdomain used for client requests to the Arkose captcha provider. */
    client_subdomain?: string;
    /** The subdomain used for server-side verification requests to the Arkose captcha provider. */
    verify_subdomain?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface AttackProtectionCaptchaAuthChallengeRequest {
    /** Whether the auth challenge should fail open. */
    fail_open: boolean;
}

export interface AttackProtectionCaptchaAuthChallengeResponseContent {
    /** Whether the auth challenge should fail open. */
    fail_open?: boolean;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface AttackProtectionCaptchaFriendlyCaptchaResponseContent {
    /** The site key for the Friendly Captcha provider. */
    site_key?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface AttackProtectionCaptchaHcaptchaResponseContent {
    /** The site key for the hCaptcha provider. */
    site_key?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** The id of the active provider for the CAPTCHA. */
export const AttackProtectionCaptchaProviderId = {
    Arkose: "arkose",
    AuthChallenge: "auth_challenge",
    FriendlyCaptcha: "friendly_captcha",
    Hcaptcha: "hcaptcha",
    RecaptchaV2: "recaptcha_v2",
    RecaptchaEnterprise: "recaptcha_enterprise",
    SimpleCaptcha: "simple_captcha",
} as const;
export type AttackProtectionCaptchaProviderId =
    (typeof AttackProtectionCaptchaProviderId)[keyof typeof AttackProtectionCaptchaProviderId];

export interface AttackProtectionCaptchaRecaptchaEnterpriseResponseContent {
    /** The site key for the reCAPTCHA Enterprise provider. */
    site_key?: string;
    /** The project ID for the reCAPTCHA Enterprise provider. */
    project_id?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface AttackProtectionCaptchaRecaptchaV2ResponseContent {
    /** The site key for the reCAPTCHA v2 provider. */
    site_key?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export type AttackProtectionCaptchaSimpleCaptchaResponseContent = Record<string, unknown>;

export interface AttackProtectionUpdateCaptchaArkose {
    /** The site key for the Arkose captcha provider. */
    site_key: string;
    /** The secret key for the Arkose captcha provider. */
    secret: string;
    /** The subdomain used for client requests to the Arkose captcha provider. */
    client_subdomain?: string;
    /** The subdomain used for server-side verification requests to the Arkose captcha provider. */
    verify_subdomain?: string;
    /** Whether the captcha should fail open. */
    fail_open?: boolean;
}

export interface AttackProtectionUpdateCaptchaFriendlyCaptcha {
    /** The site key for the Friendly Captcha provider. */
    site_key: string;
    /** The secret key for the Friendly Captcha provider. */
    secret: string;
}

export interface AttackProtectionUpdateCaptchaHcaptcha {
    /** The site key for the hCaptcha provider. */
    site_key: string;
    /** The secret key for the hCaptcha provider. */
    secret: string;
}

export interface AttackProtectionUpdateCaptchaRecaptchaEnterprise {
    /** The site key for the reCAPTCHA Enterprise provider. */
    site_key: string;
    /** The API key for the reCAPTCHA Enterprise provider. */
    api_key: string;
    /** The project ID for the reCAPTCHA Enterprise provider. */
    project_id: string;
}

export interface AttackProtectionUpdateCaptchaRecaptchaV2 {
    /** The site key for the reCAPTCHA v2 provider. */
    site_key: string;
    /** The secret key for the reCAPTCHA v2 provider. */
    secret: string;
}

export const AuthenticationMethodTypeEnum = {
    RecoveryCode: "recovery-code",
    Totp: "totp",
    Push: "push",
    Phone: "phone",
    Email: "email",
    EmailVerification: "email-verification",
    WebauthnRoaming: "webauthn-roaming",
    WebauthnPlatform: "webauthn-platform",
    Guardian: "guardian",
    Passkey: "passkey",
    Password: "password",
} as const;
export type AuthenticationMethodTypeEnum =
    (typeof AuthenticationMethodTypeEnum)[keyof typeof AuthenticationMethodTypeEnum];

export const AuthenticationTypeEnum = {
    Phone: "phone",
    Email: "email",
    Totp: "totp",
} as const;
export type AuthenticationTypeEnum = (typeof AuthenticationTypeEnum)[keyof typeof AuthenticationTypeEnum];

/**
 * List of IP addresses or CIDR blocks to allowlist
 */
export type BotDetectionAllowlist = Management.BotDetectionIpAddressOrCidrBlock[];

/** The policy that defines how often to show CAPTCHA */
export const BotDetectionChallengePolicyPasswordFlowEnum = {
    Never: "never",
    WhenRisky: "when_risky",
    Always: "always",
} as const;
export type BotDetectionChallengePolicyPasswordFlowEnum =
    (typeof BotDetectionChallengePolicyPasswordFlowEnum)[keyof typeof BotDetectionChallengePolicyPasswordFlowEnum];

/** The policy that defines how often to show CAPTCHA */
export const BotDetectionChallengePolicyPasswordResetFlowEnum = {
    Never: "never",
    WhenRisky: "when_risky",
    Always: "always",
} as const;
export type BotDetectionChallengePolicyPasswordResetFlowEnum =
    (typeof BotDetectionChallengePolicyPasswordResetFlowEnum)[keyof typeof BotDetectionChallengePolicyPasswordResetFlowEnum];

/** The policy that defines how often to show CAPTCHA */
export const BotDetectionChallengePolicyPasswordlessFlowEnum = {
    Never: "never",
    WhenRisky: "when_risky",
    Always: "always",
} as const;
export type BotDetectionChallengePolicyPasswordlessFlowEnum =
    (typeof BotDetectionChallengePolicyPasswordlessFlowEnum)[keyof typeof BotDetectionChallengePolicyPasswordlessFlowEnum];

/**
 * CIDR block
 */
export type BotDetectionCidrBlock = string;

/**
 * IPv4 address or CIDR block
 */
export type BotDetectionIPv4 = string;

/**
 * IPv6 address or CIDR block
 */
export type BotDetectionIPv6 = string;

/**
 * IP address (IPv4 or IPv6) or CIDR block
 */
export type BotDetectionIpAddressOrCidrBlock = string;

/**
 * IPv6 CIDR block
 */
export type BotDetectionIpv6CidrBlock = string;

/** The level of bot detection sensitivity */
export const BotDetectionLevelEnum = {
    Low: "low",
    Medium: "medium",
    High: "high",
} as const;
export type BotDetectionLevelEnum = (typeof BotDetectionLevelEnum)[keyof typeof BotDetectionLevelEnum];

/**
 * Whether monitoring mode is enabled (logs but does not block)
 */
export type BotDetectionMonitoringModeEnabled = boolean;

/**
 * Custom color settings.
 */
export interface BrandingColors {
    /** Accent color. */
    primary?: string;
    page_background?: Management.BrandingPageBackground;
}

/**
 * Custom font settings.
 */
export interface BrandingFont {
    /** URL for the custom font. The URL must point to a font file and not a stylesheet. Must use HTTPS. */
    url?: string;
}

/**
 * Page Background Color or Gradient.
 * Property contains either <code>null</code> to unset, a solid color as a string value <code>#FFFFFF</code>, or a gradient as an object.
 *
 * <pre><code>
 * {
 *   type: 'linear-gradient',
 *   start: '#FFFFFF',
 *   end: '#000000',
 *   angle_deg: 35
 * }
 * </code></pre>
 */
export type BrandingPageBackground = (string | null) | undefined | (Record<string, unknown> | null) | undefined;

export interface BrandingThemeBorders {
    /** Button border radius */
    button_border_radius: number;
    /** Button border weight */
    button_border_weight: number;
    buttons_style: Management.BrandingThemeBordersButtonsStyleEnum;
    /** Input border radius */
    input_border_radius: number;
    /** Input border weight */
    input_border_weight: number;
    inputs_style: Management.BrandingThemeBordersInputsStyleEnum;
    /** Show widget shadow */
    show_widget_shadow: boolean;
    /** Widget border weight */
    widget_border_weight: number;
    /** Widget corner radius */
    widget_corner_radius: number;
}

/** Buttons style */
export const BrandingThemeBordersButtonsStyleEnum = {
    Pill: "pill",
    Rounded: "rounded",
    Sharp: "sharp",
} as const;
export type BrandingThemeBordersButtonsStyleEnum =
    (typeof BrandingThemeBordersButtonsStyleEnum)[keyof typeof BrandingThemeBordersButtonsStyleEnum];

/** Inputs style */
export const BrandingThemeBordersInputsStyleEnum = {
    Pill: "pill",
    Rounded: "rounded",
    Sharp: "sharp",
} as const;
export type BrandingThemeBordersInputsStyleEnum =
    (typeof BrandingThemeBordersInputsStyleEnum)[keyof typeof BrandingThemeBordersInputsStyleEnum];

export interface BrandingThemeColors {
    /** Base Focus Color */
    base_focus_color?: string;
    /** Base Hover Color */
    base_hover_color?: string;
    /** Body text */
    body_text: string;
    captcha_widget_theme?: Management.BrandingThemeColorsCaptchaWidgetThemeEnum;
    /** Error */
    error: string;
    /** Header */
    header: string;
    /** Icons */
    icons: string;
    /** Input background */
    input_background: string;
    /** Input border */
    input_border: string;
    /** Input filled text */
    input_filled_text: string;
    /** Input labels & placeholders */
    input_labels_placeholders: string;
    /** Links & focused components */
    links_focused_components: string;
    /** Primary button */
    primary_button: string;
    /** Primary button label */
    primary_button_label: string;
    /** Read only background */
    read_only_background?: string;
    /** Secondary button border */
    secondary_button_border: string;
    /** Secondary button label */
    secondary_button_label: string;
    /** Success */
    success: string;
    /** Widget background */
    widget_background: string;
    /** Widget border */
    widget_border: string;
}

/** Captcha Widget Theme */
export const BrandingThemeColorsCaptchaWidgetThemeEnum = {
    Auto: "auto",
    Dark: "dark",
    Light: "light",
} as const;
export type BrandingThemeColorsCaptchaWidgetThemeEnum =
    (typeof BrandingThemeColorsCaptchaWidgetThemeEnum)[keyof typeof BrandingThemeColorsCaptchaWidgetThemeEnum];

/**
 * Body text
 */
export interface BrandingThemeFontBodyText {
    /** Body text bold */
    bold: boolean;
    /** Body text size */
    size: number;
}

/**
 * Buttons text
 */
export interface BrandingThemeFontButtonsText {
    /** Buttons text bold */
    bold: boolean;
    /** Buttons text size */
    size: number;
}

/**
 * Input Labels
 */
export interface BrandingThemeFontInputLabels {
    /** Input Labels bold */
    bold: boolean;
    /** Input Labels size */
    size: number;
}

/**
 * Links
 */
export interface BrandingThemeFontLinks {
    /** Links bold */
    bold: boolean;
    /** Links size */
    size: number;
}

/** Links style */
export const BrandingThemeFontLinksStyleEnum = {
    Normal: "normal",
    Underlined: "underlined",
} as const;
export type BrandingThemeFontLinksStyleEnum =
    (typeof BrandingThemeFontLinksStyleEnum)[keyof typeof BrandingThemeFontLinksStyleEnum];

/**
 * Subtitle
 */
export interface BrandingThemeFontSubtitle {
    /** Subtitle bold */
    bold: boolean;
    /** Subtitle size */
    size: number;
}

/**
 * Title
 */
export interface BrandingThemeFontTitle {
    /** Title bold */
    bold: boolean;
    /** Title size */
    size: number;
}

export interface BrandingThemeFonts {
    body_text: Management.BrandingThemeFontBodyText;
    buttons_text: Management.BrandingThemeFontButtonsText;
    /** Font URL */
    font_url: string;
    input_labels: Management.BrandingThemeFontInputLabels;
    links: Management.BrandingThemeFontLinks;
    links_style: Management.BrandingThemeFontLinksStyleEnum;
    /** Reference text size */
    reference_text_size: number;
    subtitle: Management.BrandingThemeFontSubtitle;
    title: Management.BrandingThemeFontTitle;
}

export interface BrandingThemePageBackground {
    /** Background color */
    background_color: string;
    /** Background image url */
    background_image_url: string;
    page_layout: Management.BrandingThemePageBackgroundPageLayoutEnum;
}

/** Page Layout */
export const BrandingThemePageBackgroundPageLayoutEnum = {
    Center: "center",
    Left: "left",
    Right: "right",
} as const;
export type BrandingThemePageBackgroundPageLayoutEnum =
    (typeof BrandingThemePageBackgroundPageLayoutEnum)[keyof typeof BrandingThemePageBackgroundPageLayoutEnum];

export interface BrandingThemeWidget {
    header_text_alignment: Management.BrandingThemeWidgetHeaderTextAlignmentEnum;
    /** Logo height */
    logo_height: number;
    logo_position: Management.BrandingThemeWidgetLogoPositionEnum;
    /** Logo url */
    logo_url: string;
    social_buttons_layout: Management.BrandingThemeWidgetSocialButtonsLayoutEnum;
}

/** Header text alignment */
export const BrandingThemeWidgetHeaderTextAlignmentEnum = {
    Center: "center",
    Left: "left",
    Right: "right",
} as const;
export type BrandingThemeWidgetHeaderTextAlignmentEnum =
    (typeof BrandingThemeWidgetHeaderTextAlignmentEnum)[keyof typeof BrandingThemeWidgetHeaderTextAlignmentEnum];

/** Logo position */
export const BrandingThemeWidgetLogoPositionEnum = {
    Center: "center",
    Left: "left",
    None: "none",
    Right: "right",
} as const;
export type BrandingThemeWidgetLogoPositionEnum =
    (typeof BrandingThemeWidgetLogoPositionEnum)[keyof typeof BrandingThemeWidgetLogoPositionEnum];

/** Social buttons layout */
export const BrandingThemeWidgetSocialButtonsLayoutEnum = {
    Bottom: "bottom",
    Top: "top",
} as const;
export type BrandingThemeWidgetSocialButtonsLayoutEnum =
    (typeof BrandingThemeWidgetSocialButtonsLayoutEnum)[keyof typeof BrandingThemeWidgetSocialButtonsLayoutEnum];

export const BreachedPasswordDetectionAdminNotificationFrequencyEnum = {
    Immediately: "immediately",
    Daily: "daily",
    Weekly: "weekly",
    Monthly: "monthly",
} as const;
export type BreachedPasswordDetectionAdminNotificationFrequencyEnum =
    (typeof BreachedPasswordDetectionAdminNotificationFrequencyEnum)[keyof typeof BreachedPasswordDetectionAdminNotificationFrequencyEnum];

/**
 * The subscription level for breached password detection methods. Use "enhanced" to enable Credential Guard.
 *         Possible values: <code>standard</code>, <code>enhanced</code>.
 */
export const BreachedPasswordDetectionMethodEnum = {
    Standard: "standard",
    Enhanced: "enhanced",
} as const;
export type BreachedPasswordDetectionMethodEnum =
    (typeof BreachedPasswordDetectionMethodEnum)[keyof typeof BreachedPasswordDetectionMethodEnum];

export const BreachedPasswordDetectionPreChangePasswordShieldsEnum = {
    Block: "block",
    AdminNotification: "admin_notification",
} as const;
export type BreachedPasswordDetectionPreChangePasswordShieldsEnum =
    (typeof BreachedPasswordDetectionPreChangePasswordShieldsEnum)[keyof typeof BreachedPasswordDetectionPreChangePasswordShieldsEnum];

export interface BreachedPasswordDetectionPreChangePasswordStage {
    /**
     * Action to take when a breached password is detected during a password reset.
     *               Possible values: <code>block</code>, <code>admin_notification</code>.
     */
    shields?: Management.BreachedPasswordDetectionPreChangePasswordShieldsEnum[];
}

export const BreachedPasswordDetectionPreUserRegistrationShieldsEnum = {
    Block: "block",
    AdminNotification: "admin_notification",
} as const;
export type BreachedPasswordDetectionPreUserRegistrationShieldsEnum =
    (typeof BreachedPasswordDetectionPreUserRegistrationShieldsEnum)[keyof typeof BreachedPasswordDetectionPreUserRegistrationShieldsEnum];

export interface BreachedPasswordDetectionPreUserRegistrationStage {
    /**
     * Action to take when a breached password is detected during a signup.
     *               Possible values: <code>block</code>, <code>admin_notification</code>.
     */
    shields?: Management.BreachedPasswordDetectionPreUserRegistrationShieldsEnum[];
}

export const BreachedPasswordDetectionShieldsEnum = {
    Block: "block",
    UserNotification: "user_notification",
    AdminNotification: "admin_notification",
} as const;
export type BreachedPasswordDetectionShieldsEnum =
    (typeof BreachedPasswordDetectionShieldsEnum)[keyof typeof BreachedPasswordDetectionShieldsEnum];

export interface BreachedPasswordDetectionStage {
    "pre-user-registration"?: Management.BreachedPasswordDetectionPreUserRegistrationStage;
    "pre-change-password"?: Management.BreachedPasswordDetectionPreChangePasswordStage;
}

export interface BulkUpdateAculResponseContent {
    configs: Management.AculConfigs;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface ChangePasswordTicketResponseContent {
    /** URL representing the ticket. */
    ticket: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface Client {
    /** ID of this client. */
    client_id?: string;
    /** Name of the tenant this client belongs to. */
    tenant?: string;
    /** Name of this client (min length: 1 character, does not allow `<` or `>`). */
    name?: string;
    /** Free text description of this client (max length: 140 characters). */
    description?: string;
    /** Whether this is your global 'All Applications' client representing legacy tenant settings (true) or a regular client (false). */
    global?: boolean;
    /** Client secret (which you must not make public). */
    client_secret?: string;
    app_type?: Management.ClientAppTypeEnum;
    /** URL of the logo to display for this client. Recommended size is 150x150 pixels. */
    logo_uri?: string;
    /** Whether this client a first party client (true) or not (false). */
    is_first_party?: boolean;
    /** Whether this client conforms to <a href='https://auth0.com/docs/api-auth/tutorials/adoption'>strict OIDC specifications</a> (true) or uses legacy features (false). */
    oidc_conformant?: boolean;
    /** Comma-separated list of URLs whitelisted for Auth0 to use as a callback to the client after authentication. */
    callbacks?: string[];
    /** Comma-separated list of URLs allowed to make requests from JavaScript to Auth0 API (typically used with CORS). By default, all your callback URLs will be allowed. This field allows you to enter other origins if necessary. You can also use wildcards at the subdomain level (e.g., https://*.contoso.com). Query strings and hash information are not taken into account when validating these URLs. */
    allowed_origins?: string[];
    /** Comma-separated list of allowed origins for use with <a href='https://auth0.com/docs/cross-origin-authentication'>Cross-Origin Authentication</a>, <a href='https://auth0.com/docs/flows/concepts/device-auth'>Device Flow</a>, and <a href='https://auth0.com/docs/protocols/oauth2#how-response-mode-works'>web message response mode</a>. */
    web_origins?: string[];
    /** List of audiences/realms for SAML protocol. Used by the wsfed addon. */
    client_aliases?: string[];
    /** List of allow clients and API ids that are allowed to make delegation requests. Empty means all all your clients are allowed. */
    allowed_clients?: string[];
    /** Comma-separated list of URLs that are valid to redirect to after logout from Auth0. Wildcards are allowed for subdomains. */
    allowed_logout_urls?: string[];
    session_transfer?: Management.ClientSessionTransferConfiguration | null;
    oidc_logout?: Management.ClientOidcBackchannelLogoutSettings;
    /** List of grant types supported for this application. Can include `authorization_code`, `implicit`, `refresh_token`, `client_credentials`, `password`, `http://auth0.com/oauth/grant-type/password-realm`, `http://auth0.com/oauth/grant-type/mfa-oob`, `http://auth0.com/oauth/grant-type/mfa-otp`, `http://auth0.com/oauth/grant-type/mfa-recovery-code`, `urn:openid:params:grant-type:ciba`, `urn:ietf:params:oauth:grant-type:device_code`, and `urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token`. */
    grant_types?: string[];
    jwt_configuration?: Management.ClientJwtConfiguration;
    signing_keys?: Management.ClientSigningKeys;
    encryption_key?: Management.ClientEncryptionKey | null;
    /** Applies only to SSO clients and determines whether Auth0 will handle Single Sign On (true) or whether the Identity Provider will (false). */
    sso?: boolean;
    /** Whether Single Sign On is disabled (true) or enabled (true). Defaults to true. */
    sso_disabled?: boolean;
    /** Whether this client can be used to make cross-origin authentication requests (true) or it is not allowed to make such requests (false). */
    cross_origin_authentication?: boolean;
    /** URL of the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page. */
    cross_origin_loc?: string;
    /** Whether a custom login page is to be used (true) or the default provided login page (false). */
    custom_login_page_on?: boolean;
    /** The content (HTML, CSS, JS) of the custom login page. */
    custom_login_page?: string;
    /** The content (HTML, CSS, JS) of the custom login page. (Used on Previews) */
    custom_login_page_preview?: string;
    /** HTML form template to be used for WS-Federation. */
    form_template?: string;
    addons?: Management.ClientAddons;
    token_endpoint_auth_method?: Management.ClientTokenEndpointAuthMethodEnum;
    /** If true, trust that the IP specified in the `auth0-forwarded-for` header is the end-user's IP for brute-force-protection on token endpoint. */
    is_token_endpoint_ip_header_trusted?: boolean;
    client_metadata?: Management.ClientMetadata;
    mobile?: Management.ClientMobile;
    /** Initiate login uri, must be https */
    initiate_login_uri?: string;
    refresh_token?: Management.ClientRefreshTokenConfiguration | null;
    default_organization?: Management.ClientDefaultOrganization | null;
    organization_usage?: Management.ClientOrganizationUsageEnum;
    organization_require_behavior?: Management.ClientOrganizationRequireBehaviorEnum;
    /** Defines the available methods for organization discovery during the `pre_login_prompt`. Users can discover their organization either by `email`, `organization_name` or both. */
    organization_discovery_methods?: Management.ClientOrganizationDiscoveryEnum[];
    client_authentication_methods?: Management.ClientAuthenticationMethod | null;
    /** Makes the use of Pushed Authorization Requests mandatory for this client */
    require_pushed_authorization_requests?: boolean;
    /** Makes the use of Proof-of-Possession mandatory for this client */
    require_proof_of_possession?: boolean;
    signed_request_object?: Management.ClientSignedRequestObjectWithCredentialId;
    compliance_level?: Management.ClientComplianceLevelEnum | null;
    /**
     * Controls whether a confirmation prompt is shown during login flows when the redirect URI uses non-verifiable callback URIs (for example, a custom URI schema such as `myapp://`, or `localhost`).
     * If set to true, a confirmation prompt will not be shown. We recommend that this is set to false for improved protection from malicious apps.
     * See https://auth0.com/docs/secure/security-guidance/measures-against-app-impersonation for more information.
     */
    skip_non_verifiable_callback_uri_confirmation_prompt?: boolean;
    /** Specifies how long, in seconds, a Pushed Authorization Request URI remains valid */
    par_request_expiry?: number | null;
    token_quota?: Management.TokenQuota;
    express_configuration?: Management.ExpressConfiguration;
    /** The identifier of the resource server that this client is linked to. */
    resource_server_identifier?: string;
    async_approval_notification_channels?: Management.ClientAsyncApprovalNotificationsChannelsApiPostConfiguration;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * AWS addon configuration.
 */
export interface ClientAddonAws {
    /** AWS principal ARN, e.g. `arn:aws:iam::010616021751:saml-provider/idpname` */
    principal?: string;
    /** AWS role ARN, e.g. `arn:aws:iam::010616021751:role/foo` */
    role?: string;
    /** AWS token lifetime in seconds */
    lifetime_in_seconds?: number;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Azure Blob Storage addon configuration.
 */
export interface ClientAddonAzureBlob {
    /** Your Azure storage account name. Usually first segment in your Azure storage URL. e.g. `https://acme-org.blob.core.windows.net` would be the account name `acme-org`. */
    accountName?: string;
    /** Access key associated with this storage account. */
    storageAccessKey?: string;
    /** Container to request a token for. e.g. `my-container`. */
    containerName?: string;
    /** Entity to request a token for. e.g. `my-blob`. If blank the computed SAS will apply to the entire storage container. */
    blobName?: string;
    /** Expiration in minutes for the generated token (default of 5 minutes). */
    expiration?: number;
    /** Shared access policy identifier defined in your storage account resource. */
    signedIdentifier?: string;
    /** Indicates if the issued token has permission to read the content, properties, metadata and block list. Use the blob as the source of a copy operation. */
    blob_read?: boolean;
    /** Indicates if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account. */
    blob_write?: boolean;
    /** Indicates if the issued token has permission to delete the blob. */
    blob_delete?: boolean;
    /** Indicates if the issued token has permission to read the content, properties, metadata or block list of any blob in the container. Use any blob in the container as the source of a copy operation */
    container_read?: boolean;
    /** Indicates that for any blob in the container if the issued token has permission to create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only). Use the blob as the destination of a copy operation within the same account. */
    container_write?: boolean;
    /** Indicates if issued token has permission to delete any blob in the container. */
    container_delete?: boolean;
    /** Indicates if the issued token has permission to list blobs in the container. */
    container_list?: boolean;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Azure Storage Bus addon configuration.
 */
export interface ClientAddonAzureSb {
    /** Your Azure Service Bus namespace. Usually the first segment of your Service Bus URL (e.g. `https://acme-org.servicebus.windows.net` would be `acme-org`). */
    namespace?: string;
    /** Your shared access policy name defined in your Service Bus entity. */
    sasKeyName?: string;
    /** Primary Key associated with your shared access policy. */
    sasKey?: string;
    /** Entity you want to request a token for. e.g. `my-queue`.' */
    entityPath?: string;
    /** Optional expiration in minutes for the generated token. Defaults to 5 minutes. */
    expiration?: number;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Box SSO indicator (no configuration settings needed for Box SSO).
 */
export type ClientAddonBox = Record<string, unknown>;

/**
 * CloudBees SSO indicator (no configuration settings needed for CloudBees SSO).
 */
export type ClientAddonCloudBees = Record<string, unknown>;

/**
 * Concur SSO indicator (no configuration settings needed for Concur SSO).
 */
export type ClientAddonConcur = Record<string, unknown>;

/**
 * Dropbox SSO indicator (no configuration settings needed for Dropbox SSO).
 */
export type ClientAddonDropbox = Record<string, unknown>;

/**
 * Adobe EchoSign SSO configuration.
 */
export interface ClientAddonEchoSign {
    /** Your custom domain found in your EchoSign URL. e.g. `https://acme-org.echosign.com` would be `acme-org`. */
    domain?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Egnyte SSO configuration.
 */
export interface ClientAddonEgnyte {
    /** Your custom domain found in your Egnyte URL. e.g. `https://acme-org.egnyte.com` would be `acme-org`. */
    domain?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Google Firebase addon configuration.
 */
export interface ClientAddonFirebase {
    /** Google Firebase Secret. (SDK 2 only). */
    secret?: string;
    /** Optional ID of the private key to obtain kid header in the issued token (SDK v3+ tokens only). */
    private_key_id?: string;
    /** Private Key for signing the token (SDK v3+ tokens only). */
    private_key?: string;
    /** ID of the Service Account you have created (shown as `client_email` in the generated JSON file, SDK v3+ tokens only). */
    client_email?: string;
    /** Optional expiration in seconds for the generated token. Defaults to 3600 seconds (SDK v3+ tokens only). */
    lifetime_in_seconds?: number;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Layer addon configuration.
 */
export interface ClientAddonLayer {
    /** Provider ID of your Layer account */
    providerId: string;
    /** Authentication Key identifier used to sign the Layer token. */
    keyId: string;
    /** Private key for signing the Layer token. */
    privateKey: string;
    /** Name of the property used as the unique user id in Layer. If not specified `user_id` is used. */
    principal?: string;
    /** Optional expiration in minutes for the generated token. Defaults to 5 minutes. */
    expiration?: number;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Microsoft Dynamics CRM SSO configuration.
 */
export interface ClientAddonMscrm {
    /** Microsoft Dynamics CRM application URL. */
    url: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * New Relic SSO configuration.
 */
export interface ClientAddonNewRelic {
    /** Your New Relic Account ID found in your New Relic URL after the `/accounts/` path. e.g. `https://rpm.newrelic.com/accounts/123456/query` would be `123456`. */
    account?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Okta Access Gateway SSO configuration
 */
export interface ClientAddonOag {}

/**
 * Microsoft Office 365 SSO configuration.
 */
export interface ClientAddonOffice365 {
    /** Your Office 365 domain name. e.g. `acme-org.com`. */
    domain?: string;
    /** Optional Auth0 database connection for testing an already-configured Office 365 tenant. */
    connection?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Active Directory Rights Management Service SSO configuration.
 */
export interface ClientAddonRms {
    /** URL of your Rights Management Server. It can be internal or external, but users will have to be able to reach it. */
    url: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * SAML2 addon indicator (no configuration settings needed for SAML2 addon).
 */
export interface ClientAddonSaml {
    mappings?: Management.ClientAddonSamlMapping;
    audience?: string;
    recipient?: string;
    createUpnClaim?: boolean;
    mapUnknownClaimsAsIs?: boolean;
    passthroughClaimsWithNoMapping?: boolean;
    mapIdentities?: boolean;
    signatureAlgorithm?: string;
    digestAlgorithm?: string;
    issuer?: string;
    destination?: string;
    lifetimeInSeconds?: number;
    signResponse?: boolean;
    nameIdentifierFormat?: string;
    nameIdentifierProbes?: string[];
    authnContextClassRef?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export type ClientAddonSamlMapping = Record<string, unknown>;

/**
 * SAP API addon configuration.
 */
export interface ClientAddonSapapi {
    /** If activated in the OAuth 2.0 client configuration (transaction SOAUTH2) the SAML attribute client_id must be set and equal the client_id form parameter of the access token request. */
    clientid?: string;
    /** Name of the property in the user object that maps to a SAP username. e.g. `email`. */
    usernameAttribute?: string;
    /** Your SAP OData server OAuth2 token endpoint URL. */
    tokenEndpointUrl?: string;
    /** Requested scope for SAP APIs. */
    scope?: string;
    /** Service account password to use to authenticate API calls to the token endpoint. */
    servicePassword?: string;
    /** NameID element of the Subject which can be used to express the user's identity. Defaults to `urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified`. */
    nameIdentifierFormat?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface ClientAddonSsoIntegration {
    /** SSO integration name */
    name?: string;
    /** SSO integration version installed */
    version?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Salesforce SSO configuration.
 */
export interface ClientAddonSalesforce {
    /** Arbitrary logical URL that identifies the Saleforce resource. e.g. `https://acme-org.com`. */
    entity_id?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Salesforce API addon configuration.
 */
export interface ClientAddonSalesforceApi {
    /** Consumer Key assigned by Salesforce to the Connected App. */
    clientid?: string;
    /** Name of the property in the user object that maps to a Salesforce username. e.g. `email`. */
    principal?: string;
    /** Community name. */
    communityName?: string;
    /** Community url section. */
    community_url_section?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Salesforce Sandbox addon configuration.
 */
export interface ClientAddonSalesforceSandboxApi {
    /** Consumer Key assigned by Salesforce to the Connected App. */
    clientid?: string;
    /** Name of the property in the user object that maps to a Salesforce username. e.g. `email`. */
    principal?: string;
    /** Community name. */
    communityName?: string;
    /** Community url section. */
    community_url_section?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Sentry SSO configuration.
 */
export interface ClientAddonSentry {
    /** Generated slug for your Sentry organization. Found in your Sentry URL. e.g. `https://sentry.acme.com/acme-org/` would be `acme-org`. */
    org_slug?: string;
    /** URL prefix only if running Sentry Community Edition, otherwise leave should be blank. */
    base_url?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * SharePoint SSO configuration.
 */
export interface ClientAddonSharePoint {
    /** Internal SharePoint application URL. */
    url?: string;
    external_url?: Management.ClientAddonSharePointExternalUrl;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * External SharePoint application URLs if exposed to the Internet.
 */
export type ClientAddonSharePointExternalUrl = string[] | string;

/**
 * Slack team or workspace name usually first segment in your Slack URL. e.g. `https://acme-org.slack.com` would be `acme-org`.
 */
export interface ClientAddonSlack {
    /** Slack team name. */
    team: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * SpringCM SSO configuration.
 */
export interface ClientAddonSpringCm {
    /** SpringCM ACS URL, e.g. `https://na11.springcm.com/atlas/sso/SSOEndpoint.ashx`. */
    acsurl?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Windows Azure Mobile Services addon configuration.
 */
export interface ClientAddonWams {
    /** Your master key for Windows Azure Mobile Services. */
    masterkey?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * WS-Fed (WIF) addon indicator. Actual configuration is stored in `callback` and `client_aliases` properties on the client.
 */
export type ClientAddonWsFed = Record<string, unknown>;

/**
 * Zendesk SSO configuration.
 */
export interface ClientAddonZendesk {
    /** Zendesk account name usually first segment in your Zendesk URL. e.g. `https://acme-org.zendesk.com` would be `acme-org`. */
    accountName?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Zoom SSO configuration.
 */
export interface ClientAddonZoom {
    /** Zoom account name usually first segment of your Zoom URL, e.g. `https://acme-org.zoom.us` would be `acme-org`. */
    account?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Addons enabled for this client and their associated configurations.
 */
export interface ClientAddons {
    aws?: Management.ClientAddonAws;
    azure_blob?: Management.ClientAddonAzureBlob;
    azure_sb?: Management.ClientAddonAzureSb;
    rms?: Management.ClientAddonRms;
    mscrm?: Management.ClientAddonMscrm;
    slack?: Management.ClientAddonSlack;
    sentry?: Management.ClientAddonSentry;
    box?: Management.ClientAddonBox;
    cloudbees?: Management.ClientAddonCloudBees;
    concur?: Management.ClientAddonConcur;
    dropbox?: Management.ClientAddonDropbox;
    echosign?: Management.ClientAddonEchoSign;
    egnyte?: Management.ClientAddonEgnyte;
    firebase?: Management.ClientAddonFirebase;
    newrelic?: Management.ClientAddonNewRelic;
    office365?: Management.ClientAddonOffice365;
    salesforce?: Management.ClientAddonSalesforce;
    salesforce_api?: Management.ClientAddonSalesforceApi;
    salesforce_sandbox_api?: Management.ClientAddonSalesforceSandboxApi;
    samlp?: Management.ClientAddonSaml;
    layer?: Management.ClientAddonLayer;
    sap_api?: Management.ClientAddonSapapi;
    sharepoint?: Management.ClientAddonSharePoint;
    springcm?: Management.ClientAddonSpringCm;
    wams?: Management.ClientAddonWams;
    wsfed?: Management.ClientAddonWsFed;
    zendesk?: Management.ClientAddonZendesk;
    zoom?: Management.ClientAddonZoom;
    sso_integration?: Management.ClientAddonSsoIntegration;
    oag?: Management.ClientAddonOag | null;
}

/** The type of application this client represents */
export const ClientAppTypeEnum = {
    Native: "native",
    Spa: "spa",
    RegularWeb: "regular_web",
    NonInteractive: "non_interactive",
    ResourceServer: "resource_server",
    ExpressConfiguration: "express_configuration",
    Rms: "rms",
    Box: "box",
    Cloudbees: "cloudbees",
    Concur: "concur",
    Dropbox: "dropbox",
    Mscrm: "mscrm",
    Echosign: "echosign",
    Egnyte: "egnyte",
    Newrelic: "newrelic",
    Office365: "office365",
    Salesforce: "salesforce",
    Sentry: "sentry",
    Sharepoint: "sharepoint",
    Slack: "slack",
    Springcm: "springcm",
    Zendesk: "zendesk",
    Zoom: "zoom",
    SsoIntegration: "sso_integration",
    Oag: "oag",
} as const;
export type ClientAppTypeEnum = (typeof ClientAppTypeEnum)[keyof typeof ClientAppTypeEnum];

/**
 * Array of notification channels for contacting the user when their approval is required. Valid values are `guardian-push`, `email`.
 */
export type ClientAsyncApprovalNotificationsChannelsApiPatchConfiguration =
    Management.AsyncApprovalNotificationsChannelsEnum[];

/**
 * Array of notification channels for contacting the user when their approval is required. Valid values are `guardian-push`, `email`.
 */
export type ClientAsyncApprovalNotificationsChannelsApiPostConfiguration =
    Management.AsyncApprovalNotificationsChannelsEnum[];

/**
 * Defines client authentication methods.
 */
export interface ClientAuthenticationMethod {
    private_key_jwt?: Management.PrivateKeyJwt;
    tls_client_auth?: Management.ClientAuthenticationMethodTlsClientAuth;
    self_signed_tls_client_auth?: Management.ClientAuthenticationMethodSelfSignedTlsClientAuth;
}

/**
 * Defines `self_signed_tls_client_auth` client authentication method. If the property is defined, the client is configured to use mTLS authentication method utilizing self-signed certificate.
 */
export interface ClientAuthenticationMethodSelfSignedTlsClientAuth {
    /** A list of unique and previously created credential IDs enabled on the client for mTLS authentication utilizing self-signed certificate. */
    credentials: Management.CredentialId[];
}

/**
 * Defines `tls_client_auth` client authentication method. If the property is defined, the client is configured to use CA-based mTLS authentication method.
 */
export interface ClientAuthenticationMethodTlsClientAuth {
    /** A list of unique and previously created credential IDs enabled on the client for CA-based mTLS authentication. */
    credentials: Management.CredentialId[];
}

/** Defines the compliance level for this client, which may restrict it's capabilities */
export const ClientComplianceLevelEnum = {
    None: "none",
    Fapi1AdvPkjPar: "fapi1_adv_pkj_par",
    Fapi1AdvMtlsPar: "fapi1_adv_mtls_par",
    Fapi2SpPkjMtls: "fapi2_sp_pkj_mtls",
    Fapi2SpMtlsMtls: "fapi2_sp_mtls_mtls",
} as const;
export type ClientComplianceLevelEnum = (typeof ClientComplianceLevelEnum)[keyof typeof ClientComplianceLevelEnum];

/**
 * Defines client authentication methods.
 */
export interface ClientCreateAuthenticationMethod {
    private_key_jwt?: Management.PrivateKeyJwt;
    tls_client_auth?: Management.ClientAuthenticationMethodTlsClientAuth;
    self_signed_tls_client_auth?: Management.ClientAuthenticationMethodSelfSignedTlsClientAuth;
}

export interface ClientCredential {
    /** ID of the credential. Generated on creation. */
    id?: string;
    /** The name given to the credential by the user. */
    name?: string;
    /** The key identifier of the credential, generated on creation. */
    kid?: string;
    alg?: Management.ClientCredentialAlgorithmEnum;
    credential_type?: Management.ClientCredentialTypeEnum;
    /** The X509 certificate's Subject Distinguished Name */
    subject_dn?: string;
    /** The X509 certificate's SHA256 thumbprint */
    thumbprint_sha256?: string;
    /** The ISO 8601 formatted date the credential was created. */
    created_at?: string;
    /** The ISO 8601 formatted date the credential was updated. */
    updated_at?: string;
    /** The ISO 8601 formatted date representing the expiration of the credential. */
    expires_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** Algorithm which will be used with the credential. Supported algorithms: RS256,RS384,PS256 */
export const ClientCredentialAlgorithmEnum = {
    Rs256: "RS256",
    Rs384: "RS384",
    Ps256: "PS256",
} as const;
export type ClientCredentialAlgorithmEnum =
    (typeof ClientCredentialAlgorithmEnum)[keyof typeof ClientCredentialAlgorithmEnum];

/** The type of credential. */
export const ClientCredentialTypeEnum = {
    PublicKey: "public_key",
    CertSubjectDn: "cert_subject_dn",
    X509Cert: "x509_cert",
} as const;
export type ClientCredentialTypeEnum = (typeof ClientCredentialTypeEnum)[keyof typeof ClientCredentialTypeEnum];

/**
 * Defines the default Organization ID and flows
 */
export interface ClientDefaultOrganization {
    /** The default Organization ID to be used */
    organization_id: string;
    /** The default Organization usage */
    flows: Management.ClientDefaultOrganizationFlowsEnum[];
}

export type ClientDefaultOrganizationFlowsEnum = "client_credentials";

/**
 * Encryption used for WsFed responses with this client.
 */
export interface ClientEncryptionKey {
    /** Encryption Public RSA Key. */
    pub?: string;
    /** Encryption certificate for public key in X.509 (.CER) format. */
    cert?: string;
    /** Encryption certificate name for this certificate in the format `/CN={domain}`. */
    subject?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Optional filter on allow_any_organization.
 */
export type ClientGrantAllowAnyOrganizationEnum = boolean;

/** Controls how organizations may be used with this grant */
export const ClientGrantOrganizationNullableUsageEnum = {
    Deny: "deny",
    Allow: "allow",
    Require: "require",
} as const;
export type ClientGrantOrganizationNullableUsageEnum =
    (typeof ClientGrantOrganizationNullableUsageEnum)[keyof typeof ClientGrantOrganizationNullableUsageEnum];

/** Defines whether organizations can be used with client credentials exchanges for this grant. */
export const ClientGrantOrganizationUsageEnum = {
    Deny: "deny",
    Allow: "allow",
    Require: "require",
} as const;
export type ClientGrantOrganizationUsageEnum =
    (typeof ClientGrantOrganizationUsageEnum)[keyof typeof ClientGrantOrganizationUsageEnum];

export interface ClientGrantResponseContent {
    /** ID of the client grant. */
    id?: string;
    /** ID of the client. */
    client_id?: string;
    /** The audience (API identifier) of this client grant. */
    audience?: string;
    /** Scopes allowed for this client grant. */
    scope?: string[];
    organization_usage?: Management.ClientGrantOrganizationUsageEnum;
    /** If enabled, any organization can be used with this grant. If disabled (default), the grant must be explicitly assigned to the desired organizations. */
    allow_any_organization?: boolean;
    /** If enabled, this grant is a special grant created by Auth0. It cannot be modified or deleted directly. */
    is_system?: boolean;
    subject_type?: Management.ClientGrantSubjectTypeEnum;
    /** Types of authorization_details allowed for this client grant. Use of this field is subject to the applicable Free Trial terms in Oktaâ€™s <a href= "https://www.okta.com/legal/"> Master Subscription Agreement.</a> */
    authorization_details_types?: string[];
}

/** The type of application access the client grant allows. Use of this field is subject to the applicable Free Trial terms in Oktaâ€™s <a href="https://www.okta.com/legal/"> Master Subscription Agreement.</a> */
export const ClientGrantSubjectTypeEnum = {
    Client: "client",
    User: "user",
} as const;
export type ClientGrantSubjectTypeEnum = (typeof ClientGrantSubjectTypeEnum)[keyof typeof ClientGrantSubjectTypeEnum];

/**
 * Configuration related to JWTs for the client.
 */
export interface ClientJwtConfiguration {
    /** Number of seconds the JWT will be valid for (affects `exp` claim). */
    lifetime_in_seconds?: number;
    /** Whether the client secret is base64 encoded (true) or unencoded (false). */
    secret_encoded?: boolean;
    scopes?: Management.ClientJwtConfigurationScopes;
    alg?: Management.SigningAlgorithmEnum;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Configuration related to id token claims for the client.
 */
export type ClientJwtConfigurationScopes = Record<string, unknown>;

/**
 * Metadata associated with the client, in the form of an object with string values (max 255 chars).  Maximum of 10 metadata properties allowed.  Field names (max 255 chars) are alphanumeric and may only include the following special characters:  :,-+=_*?"/\()<>@	[Tab] [Space]
 */
export type ClientMetadata = Record<string, unknown>;

/**
 * Additional configuration for native mobile apps.
 */
export interface ClientMobile {
    android?: Management.ClientMobileAndroid;
    ios?: Management.ClientMobileiOs;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Android native app configuration.
 */
export interface ClientMobileAndroid {
    /** App package name found in AndroidManifest.xml. */
    app_package_name?: string;
    /** SHA256 fingerprints of the app's signing certificate. Multiple fingerprints can be used to support different versions of your app, such as debug and production builds. */
    sha256_cert_fingerprints?: string[];
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * iOS native app configuration.
 */
export interface ClientMobileiOs {
    /** Identifier assigned to the Apple account that signs and uploads the app to the store. */
    team_id?: string;
    /** Assigned by developer to the app as its unique identifier inside the store. Usually this is a reverse domain plus the app name, e.g. `com.you.MyApp`. */
    app_bundle_identifier?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Configuration for OIDC backchannel logout initiators
 */
export interface ClientOidcBackchannelLogoutInitiators {
    mode?: Management.ClientOidcBackchannelLogoutInitiatorsModeEnum;
    selected_initiators?: Management.ClientOidcBackchannelLogoutInitiatorsEnum[];
    /** Accepts any additional properties */
    [key: string]: any;
}

/** The `selected_initiators` property contains the list of initiators to be enabled for the given application. */
export const ClientOidcBackchannelLogoutInitiatorsEnum = {
    RpLogout: "rp-logout",
    IdpLogout: "idp-logout",
    PasswordChanged: "password-changed",
    SessionExpired: "session-expired",
    SessionRevoked: "session-revoked",
    AccountDeleted: "account-deleted",
    EmailIdentifierChanged: "email-identifier-changed",
    MfaPhoneUnenrolled: "mfa-phone-unenrolled",
    AccountDeactivated: "account-deactivated",
} as const;
export type ClientOidcBackchannelLogoutInitiatorsEnum =
    (typeof ClientOidcBackchannelLogoutInitiatorsEnum)[keyof typeof ClientOidcBackchannelLogoutInitiatorsEnum];

/** The `mode` property determines the configuration method for enabling initiators. `custom` enables only the initiators listed in the selected_initiators array, `all` enables all current and future initiators. */
export const ClientOidcBackchannelLogoutInitiatorsModeEnum = {
    Custom: "custom",
    All: "all",
} as const;
export type ClientOidcBackchannelLogoutInitiatorsModeEnum =
    (typeof ClientOidcBackchannelLogoutInitiatorsModeEnum)[keyof typeof ClientOidcBackchannelLogoutInitiatorsModeEnum];

/**
 * Controls whether session metadata is included in the logout token. Default value is null.
 */
export interface ClientOidcBackchannelLogoutSessionMetadata {
    /** The `include` property determines whether session metadata is included in the logout token. */
    include?: boolean;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Configuration for OIDC backchannel logout
 */
export interface ClientOidcBackchannelLogoutSettings {
    /** Comma-separated list of URLs that are valid to call back from Auth0 for OIDC backchannel logout. Currently only one URL is allowed. */
    backchannel_logout_urls?: string[];
    backchannel_logout_initiators?: Management.ClientOidcBackchannelLogoutInitiators;
    backchannel_logout_session_metadata?: Management.ClientOidcBackchannelLogoutSessionMetadata | null;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** Method for discovering organizations during the `pre_login_prompt`. `email` allows users to find their organization by entering their email address and performing domain matching, while `organization_name` requires users to enter the organization name directly. These methods can be combined. */
export const ClientOrganizationDiscoveryEnum = {
    Email: "email",
    OrganizationName: "organization_name",
} as const;
export type ClientOrganizationDiscoveryEnum =
    (typeof ClientOrganizationDiscoveryEnum)[keyof typeof ClientOrganizationDiscoveryEnum];

/** Defines how to proceed during an authentication transaction when `client.organization_usage: 'require'`. Can be `no_prompt` (default), `pre_login_prompt` or `post_login_prompt`. `post_login_prompt` requires `oidc_conformant: true`. */
export const ClientOrganizationRequireBehaviorEnum = {
    NoPrompt: "no_prompt",
    PreLoginPrompt: "pre_login_prompt",
    PostLoginPrompt: "post_login_prompt",
} as const;
export type ClientOrganizationRequireBehaviorEnum =
    (typeof ClientOrganizationRequireBehaviorEnum)[keyof typeof ClientOrganizationRequireBehaviorEnum];

/** Defines how to proceed during an authentication transaction when `client.organization_usage: 'require'`. Can be `no_prompt` (default), `pre_login_prompt` or `post_login_prompt`. `post_login_prompt` requires `oidc_conformant: true`. */
export const ClientOrganizationRequireBehaviorPatchEnum = {
    NoPrompt: "no_prompt",
    PreLoginPrompt: "pre_login_prompt",
    PostLoginPrompt: "post_login_prompt",
} as const;
export type ClientOrganizationRequireBehaviorPatchEnum =
    (typeof ClientOrganizationRequireBehaviorPatchEnum)[keyof typeof ClientOrganizationRequireBehaviorPatchEnum];

/** Defines how to proceed during an authentication transaction with regards an organization. Can be `deny` (default), `allow` or `require`. */
export const ClientOrganizationUsageEnum = {
    Deny: "deny",
    Allow: "allow",
    Require: "require",
} as const;
export type ClientOrganizationUsageEnum =
    (typeof ClientOrganizationUsageEnum)[keyof typeof ClientOrganizationUsageEnum];

/** Defines how to proceed during an authentication transaction with regards an organization. Can be `deny` (default), `allow` or `require`. */
export const ClientOrganizationUsagePatchEnum = {
    Deny: "deny",
    Allow: "allow",
    Require: "require",
} as const;
export type ClientOrganizationUsagePatchEnum =
    (typeof ClientOrganizationUsagePatchEnum)[keyof typeof ClientOrganizationUsagePatchEnum];

/**
 * Refresh token configuration
 */
export interface ClientRefreshTokenConfiguration {
    rotation_type: Management.RefreshTokenRotationTypeEnum;
    expiration_type: Management.RefreshTokenExpirationTypeEnum;
    /** Period in seconds where the previous refresh token can be exchanged without triggering breach detection */
    leeway?: number;
    /** Period (in seconds) for which refresh tokens will remain valid */
    token_lifetime?: number;
    /** Prevents tokens from having a set lifetime when `true` (takes precedence over `token_lifetime` values) */
    infinite_token_lifetime?: boolean;
    /** Period (in seconds) for which refresh tokens will remain valid without use */
    idle_token_lifetime?: number;
    /** Prevents tokens from expiring without use when `true` (takes precedence over `idle_token_lifetime` values) */
    infinite_idle_token_lifetime?: boolean;
}

export const ClientSessionTransferAllowedAuthenticationMethodsEnum = {
    Cookie: "cookie",
    Query: "query",
} as const;
export type ClientSessionTransferAllowedAuthenticationMethodsEnum =
    (typeof ClientSessionTransferAllowedAuthenticationMethodsEnum)[keyof typeof ClientSessionTransferAllowedAuthenticationMethodsEnum];

/**
 * Native to Web SSO Configuration
 */
export interface ClientSessionTransferConfiguration {
    /** Indicates whether an app can issue a Session Transfer Token through Token Exchange. If set to 'false', the app will not be able to issue a Session Transfer Token. Usually configured in the native application. */
    can_create_session_transfer_token?: boolean;
    /** Indicates whether revoking the parent Refresh Token that initiated a Native to Web flow and was used to issue a Session Transfer Token should trigger a cascade revocation affecting its dependent child entities. Usually configured in the native application. */
    enforce_cascade_revocation?: boolean;
    /** Indicates whether an app can create a session from a Session Transfer Token received via indicated methods. Can include `cookie` and/or `query`. Usually configured in the web application. */
    allowed_authentication_methods?: Management.ClientSessionTransferAllowedAuthenticationMethodsEnum[];
    enforce_device_binding?: Management.ClientSessionTransferDeviceBindingEnum;
    /** Indicates whether Refresh Tokens are allowed to be issued when authenticating with a Session Transfer Token. Usually configured in the web application. */
    allow_refresh_token?: boolean;
    /** Indicates whether Refresh Tokens created during a native-to-web session are tied to that session's lifetime. This determines if such refresh tokens should be automatically revoked when their corresponding sessions are. Usually configured in the web application. */
    enforce_online_refresh_tokens?: boolean;
}

/** Indicates whether device binding security should be enforced for the app. If set to 'ip', the app will enforce device binding by IP, meaning that consumption of Session Transfer Token must be done from the same IP of the issuer. Likewise, if set to 'asn', device binding is enforced by ASN, meaning consumption of Session Transfer Token must be done from the same ASN as the issuer. If set to 'null', device binding is not enforced. Usually configured in the web application. */
export const ClientSessionTransferDeviceBindingEnum = {
    Ip: "ip",
    Asn: "asn",
    None: "none",
} as const;
export type ClientSessionTransferDeviceBindingEnum =
    (typeof ClientSessionTransferDeviceBindingEnum)[keyof typeof ClientSessionTransferDeviceBindingEnum];

/**
 * JWT-secured Authorization Requests (JAR) settings.
 */
export interface ClientSignedRequestObjectWithCredentialId {
    /** Indicates whether the JAR requests are mandatory */
    required?: boolean;
    credentials?: Management.CredentialId[];
}

/**
 * JWT-secured Authorization Requests (JAR) settings.
 */
export interface ClientSignedRequestObjectWithPublicKey {
    /** Indicates whether the JAR requests are mandatory */
    required?: boolean;
    credentials?: Management.PublicKeyCredential[];
}

export interface ClientSigningKey {
    /** Signing certificate public key and chain in PKCS#7 (.P7B) format. */
    pkcs7?: string;
    /** Signing certificate public key in X.509 (.CER) format. */
    cert?: string;
    /** Subject name for this certificate in the format `/CN={domain}`. */
    subject?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Signing certificates associated with this client.
 */
export type ClientSigningKeys = Management.ClientSigningKey[];

/** Defines the requested authentication method for the token endpoint. Can be `none` (public client without a client secret), `client_secret_post` (client uses HTTP POST parameters), or `client_secret_basic` (client uses HTTP Basic). */
export const ClientTokenEndpointAuthMethodEnum = {
    None: "none",
    ClientSecretPost: "client_secret_post",
    ClientSecretBasic: "client_secret_basic",
} as const;
export type ClientTokenEndpointAuthMethodEnum =
    (typeof ClientTokenEndpointAuthMethodEnum)[keyof typeof ClientTokenEndpointAuthMethodEnum];

/** Defines the requested authentication method for the token endpoint. Can be `none` (public client without a client secret), `client_secret_post` (client uses HTTP POST parameters), or `client_secret_basic` (client uses HTTP Basic). */
export const ClientTokenEndpointAuthMethodOrNullEnum = {
    None: "none",
    ClientSecretPost: "client_secret_post",
    ClientSecretBasic: "client_secret_basic",
} as const;
export type ClientTokenEndpointAuthMethodOrNullEnum =
    (typeof ClientTokenEndpointAuthMethodOrNullEnum)[keyof typeof ClientTokenEndpointAuthMethodOrNullEnum];

export interface ConnectedAccount {
    /** The unique identifier for the connected account. */
    id: string;
    /** The name of the connection associated with the account. */
    connection: string;
    /** The unique identifier of the connection associated with the account. */
    connection_id: string;
    /** The authentication strategy used by the connection. */
    strategy: string;
    access_type: Management.ConnectedAccountAccessTypeEnum;
    /** The scopes granted for this connected account. */
    scopes?: string[];
    /** ISO 8601 timestamp when the connected account was created. */
    created_at: string;
    /** ISO 8601 timestamp when the connected account expires. */
    expires_at?: string;
}

/**
 * The access type for the connected account.
 */
export type ConnectedAccountAccessTypeEnum = "offline";

export interface ConnectionAttributeIdentifier {
    /** Determines if the attribute is used for identification */
    active?: boolean;
}

/**
 * Attribute configuration
 */
export interface ConnectionAttributes {
    email?: Management.EmailAttribute;
    phone_number?: Management.PhoneAttribute;
    username?: Management.UsernameAttribute;
}

/**
 * Options for enabling authentication methods.
 */
export interface ConnectionAuthenticationMethods {
    password?: Management.ConnectionPasswordAuthenticationMethod;
    passkey?: Management.ConnectionPasskeyAuthenticationMethod;
}

/**
 * Configure the purpose of a connection to be used for authentication during login.
 */
export interface ConnectionAuthenticationPurpose {
    active: boolean;
}

/**
 * Indicates whether brute force protection is enabled.
 */
export type ConnectionBruteForceProtection = boolean;

/**
 * The client ID of the connection.
 */
export type ConnectionClientId = string;

/**
 * The client secret of the connection.
 */
export type ConnectionClientSecret = string;

/**
 * A hash of configuration key/value pairs.
 */
export type ConnectionConfiguration = Record<string, string>;

/**
 * Configure the purpose of a connection to be used for connected accounts and Token Vault.
 */
export interface ConnectionConnectedAccountsPurpose {
    active: boolean;
    cross_app_access?: boolean;
}

/**
 * A map of scripts used to integrate with a custom database.
 */
export interface ConnectionCustomScripts {
    login?: string;
    get_user?: string;
    delete?: string;
    change_password?: string;
    verify?: string;
    create?: string;
    change_username?: string;
    change_email?: string;
    change_phone_number?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Indicates whether to disable self-service change password. Set to true to stop the "Forgot Password" being displayed on login pages
 */
export type ConnectionDisableSelfServiceChangePassword = boolean;

/**
 * Set to true to disable signups
 */
export type ConnectionDisableSignup = boolean;

/**
 * Connection name used in the new universal login experience
 */
export type ConnectionDisplayName = string;

/**
 * Set to true to inject context into custom DB scripts (warning: cannot be disabled once enabled)
 */
export type ConnectionEnableScriptContext = boolean;

export interface ConnectionEnabledClient {
    /** The client id */
    client_id: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * DEPRECATED property. Use the PATCH /v2/connections/{id}/clients endpoint to enable the connection for a set of clients.
 */
export type ConnectionEnabledClients = string[];

/**
 * Set to true to use a legacy user store
 */
export type ConnectionEnabledDatabaseCustomization = boolean;

/**
 * Federated Connections Access Tokens
 */
export interface ConnectionFederatedConnectionsAccessTokens {
    /** Enables refresh tokens and access tokens collection for federated connections */
    active?: boolean;
}

export interface ConnectionForList {
    /** The name of the connection */
    name?: string;
    /** Connection name used in login screen */
    display_name?: string;
    options?: Management.ConnectionOptions;
    /** The connection's identifier */
    id?: string;
    /** The type of the connection, related to the identity provider */
    strategy?: string;
    /** Defines the realms for which the connection will be used (ie: email domains). If the array is empty or the property is not specified, the connection name will be added as realm. */
    realms?: string[];
    /** True if the connection is domain level */
    is_domain_connection?: boolean;
    /** Enables showing a button for the connection in the login page (new experience only). If false, it will be usable only by HRD. */
    show_as_button?: boolean;
    metadata?: Management.ConnectionsMetadata;
    authentication?: Management.ConnectionAuthenticationPurpose;
    connected_accounts?: Management.ConnectionConnectedAccountsPurpose;
}

/**
 * Connection to be added to the organization.
 */
export interface ConnectionForOrganization {
    /** ID of the connection. */
    connection_id: string;
    /** When true, all users that log in with this connection will be automatically granted membership in the organization. When false, users must be granted membership in the organization before logging in with this connection. */
    assign_membership_on_login?: boolean;
    /** Determines whether a connection should be displayed on this organizationâ€™s login prompt. Only applicable for enterprise connections. Default: true. */
    show_as_button?: boolean;
    /** Determines whether organization signup should be enabled for this organization connection. Only applicable for database connections. Default: false. */
    is_signup_enabled?: boolean;
}

/**
 * Array of freeform scopes
 */
export type ConnectionFreeformScopes = string[];

/**
 * Token-based authentication settings to be applied when connection is using an sms strategy.
 */
export interface ConnectionGatewayAuthentication {
    /** The Authorization header type. */
    method: string;
    /** The subject to be added to the JWT payload. */
    subject?: string;
    /** The audience to be added to the JWT payload. */
    audience: string;
    /** The secret to be used for signing tokens. */
    secret: string;
    /** Set to true if the provided secret is base64 encoded. */
    secret_base64_encoded?: boolean;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * The connection's identifier
 */
export type ConnectionId = string;

/**
 * Order of precedence for attribute types. If the property is not specified, the default precedence of attributes will be used.
 */
export type ConnectionIdentifierPrecedence = Management.ConnectionIdentifierPrecedenceEnum[];

/** Order of precedence for attribute types */
export const ConnectionIdentifierPrecedenceEnum = {
    Email: "email",
    PhoneNumber: "phone_number",
    Username: "username",
} as const;
export type ConnectionIdentifierPrecedenceEnum =
    (typeof ConnectionIdentifierPrecedenceEnum)[keyof typeof ConnectionIdentifierPrecedenceEnum];

/** The identity provider identifier for the connection */
export const ConnectionIdentityProviderEnum = {
    Ad: "ad",
    Adfs: "adfs",
    Amazon: "amazon",
    Apple: "apple",
    Dropbox: "dropbox",
    Bitbucket: "bitbucket",
    Aol: "aol",
    Auth0Oidc: "auth0-oidc",
    Auth0: "auth0",
    Baidu: "baidu",
    Bitly: "bitly",
    Box: "box",
    Custom: "custom",
    Daccount: "daccount",
    Dwolla: "dwolla",
    Email: "email",
    EvernoteSandbox: "evernote-sandbox",
    Evernote: "evernote",
    Exact: "exact",
    Facebook: "facebook",
    Fitbit: "fitbit",
    Flickr: "flickr",
    Github: "github",
    GoogleApps: "google-apps",
    GoogleOauth2: "google-oauth2",
    Instagram: "instagram",
    Ip: "ip",
    Line: "line",
    Linkedin: "linkedin",
    Miicard: "miicard",
    Oauth1: "oauth1",
    Oauth2: "oauth2",
    Office365: "office365",
    Oidc: "oidc",
    Okta: "okta",
    Paypal: "paypal",
    PaypalSandbox: "paypal-sandbox",
    Pingfederate: "pingfederate",
    Planningcenter: "planningcenter",
    Renren: "renren",
    SalesforceCommunity: "salesforce-community",
    SalesforceSandbox: "salesforce-sandbox",
    Salesforce: "salesforce",
    Samlp: "samlp",
    Sharepoint: "sharepoint",
    Shopify: "shopify",
    Shop: "shop",
    Sms: "sms",
    Soundcloud: "soundcloud",
    ThecitySandbox: "thecity-sandbox",
    Thecity: "thecity",
    Thirtysevensignals: "thirtysevensignals",
    Twitter: "twitter",
    Untappd: "untappd",
    Vkontakte: "vkontakte",
    Waad: "waad",
    Weibo: "weibo",
    Windowslive: "windowslive",
    Wordpress: "wordpress",
    Yahoo: "yahoo",
    Yammer: "yammer",
    Yandex: "yandex",
} as const;
export type ConnectionIdentityProviderEnum =
    (typeof ConnectionIdentityProviderEnum)[keyof typeof ConnectionIdentityProviderEnum];

/**
 * Enable this if you have a legacy user store and you want to gradually migrate those users to the Auth0 user store
 */
export type ConnectionImportMode = boolean;

/**
 * <code>true</code> promotes to a domain-level connection so that third-party applications can use it. <code>false</code> does not promote the connection, so only first-party applications with the connection enabled can use it. (Defaults to <code>false</code>.)
 */
export type ConnectionIsDomainConnection = boolean;

export interface ConnectionKey {
    /** The key id of the signing key */
    kid: string;
    /** The public certificate of the signing key */
    cert: string;
    /** The public certificate of the signing key in pkcs7 format */
    pkcs?: string;
    /** True if the key is the the current key */
    current?: boolean;
    /** True if the key is the the next key */
    next?: boolean;
    /** True if the key is the the previous key */
    previous?: boolean;
    /** The date and time when the key became the current key */
    current_since?: string;
    /** The cert fingerprint */
    fingerprint: string;
    /** The cert thumbprint */
    thumbprint: string;
    /** Signing key algorithm */
    algorithm?: string;
    key_use?: Management.ConnectionKeyUseEnum;
    subject_dn?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** Signing key use, whether for encryption or signing */
export const ConnectionKeyUseEnum = {
    Encryption: "encryption",
    Signing: "signing",
} as const;
export type ConnectionKeyUseEnum = (typeof ConnectionKeyUseEnum)[keyof typeof ConnectionKeyUseEnum];

/**
 * Multi-factor authentication configuration
 */
export interface ConnectionMfa {
    /** Indicates whether MFA is active for this connection */
    active?: boolean;
    /** Indicates whether to return MFA enrollment settings */
    return_enroll_settings?: boolean;
}

/**
 * The name of the connection. Must start and end with an alphanumeric character and can only contain alphanumeric characters and '-'. Max length 128
 */
export type ConnectionName = string;

/**
 * Connection name prefix template.
 */
export type ConnectionNamePrefixTemplate = string;

/**
 * An array of user fields that should not be stored in the Auth0 database (https://auth0.com/docs/security/data-security/denylist)
 */
export type ConnectionNonPersistentAttrs = (string[] | null) | undefined;

/**
 * In order to return options in the response, the `read:connections_options` scope must be present
 */
export type ConnectionOptions = Record<string, unknown>;

/**
 * options for the 'ad' connection
 */
export type ConnectionOptionsAd = Record<string, unknown>;

/**
 * options for the 'adfs' connection
 */
export type ConnectionOptionsAdfs = Record<string, unknown>;

export type ConnectionOptionsAol = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsAmazon = Management.ConnectionOptionsOAuth2Common;

/**
 * options for the 'apple' connection
 */
export interface ConnectionOptionsApple {
    /** Apple App Secret (must be a PEM) */
    app_secret?: string | null;
    /** Apple Services ID */
    client_id?: string | null;
    /** Whether to request email from Apple */
    email?: boolean;
    /** Array of freeform scopes */
    freeform_scopes?: Management.ConnectionFreeformScopes;
    /** Apple Key ID */
    kid?: string | null;
    /** Whether to request name from Apple */
    name?: boolean;
    non_persistent_attrs?: (Management.ConnectionNonPersistentAttrs | undefined) | null;
    scope?: Management.ConnectionScopeString;
    set_user_root_attributes?: Management.ConnectionSetUserRootAttributesEnum;
    /** Apple Team ID */
    team_id?: string | null;
    upstream_params?: (Management.ConnectionUpstreamParams | undefined) | null;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * options for the 'auth0' connection
 */
export interface ConnectionOptionsAuth0 extends Management.ConnectionOptionsCommon {
    attributes?: Management.ConnectionAttributes;
    authentication_methods?: Management.ConnectionAuthenticationMethods | null;
    brute_force_protection?: Management.ConnectionBruteForceProtection;
    configuration?: Management.ConnectionConfiguration;
    customScripts?: Management.ConnectionCustomScripts;
    disable_self_service_change_password?: Management.ConnectionDisableSelfServiceChangePassword;
    disable_signup?: Management.ConnectionDisableSignup;
    enable_script_context?: Management.ConnectionEnableScriptContext;
    enabledDatabaseCustomization?: Management.ConnectionEnabledDatabaseCustomization;
    import_mode?: Management.ConnectionImportMode;
    mfa?: Management.ConnectionMfa;
    passkey_options?: Management.ConnectionPasskeyOptions | null;
    passwordPolicy?: Management.ConnectionPasswordPolicyEnum | null;
    password_complexity_options?: Management.ConnectionPasswordComplexityOptions | null;
    password_dictionary?: Management.ConnectionPasswordDictionaryOptions | null;
    password_history?: Management.ConnectionPasswordHistoryOptions | null;
    password_no_personal_info?: Management.ConnectionPasswordNoPersonalInfoOptions | null;
    precedence?: Management.ConnectionIdentifierPrecedence;
    realm_fallback?: Management.ConnectionRealmFallback;
    requires_username?: Management.ConnectionRequiresUsername;
    validation?: Management.ConnectionValidationOptions | null;
}

/**
 * options for the 'auth0-oidc' connection
 */
export type ConnectionOptionsAuth0Oidc = Record<string, unknown>;

/**
 * options for the 'waad' connection
 */
export type ConnectionOptionsAzureAd = Record<string, unknown>;

export type ConnectionOptionsBaidu = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsBitbucket = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsBitly = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsBox = Management.ConnectionOptionsOAuth2Common;

/**
 * Common attributes for connection options including non-persistent attributes and cross-app access
 */
export interface ConnectionOptionsCommon {
    non_persistent_attrs?: (Management.ConnectionNonPersistentAttrs | undefined) | null;
}

/**
 * options for the 'custom' connection
 */
export type ConnectionOptionsCustom = Record<string, unknown>;

export type ConnectionOptionsDaccount = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsDropbox = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsDwolla = Management.ConnectionOptionsOAuth2Common;

/**
 * options for the 'email' connection
 */
export type ConnectionOptionsEmail = Record<string, unknown>;

export type ConnectionOptionsEvernote = Management.ConnectionOptionsEvernoteCommon;

export type ConnectionOptionsEvernoteCommon = Record<string, unknown>;

export type ConnectionOptionsEvernoteSandbox = Management.ConnectionOptionsEvernoteCommon;

export type ConnectionOptionsExact = Management.ConnectionOptionsOAuth2Common;

/**
 * options for the 'facebook' connection
 */
export type ConnectionOptionsFacebook = Record<string, unknown>;

/**
 * options for the 'fitbit' connection
 */
export type ConnectionOptionsFitbit = Record<string, unknown>;

/**
 * options for the 'flickr' connection
 */
export type ConnectionOptionsFlickr = Record<string, unknown>;

/**
 * options for the 'github' connection
 */
export type ConnectionOptionsGitHub = Record<string, unknown>;

/**
 * options for the 'google-apps' connection
 */
export type ConnectionOptionsGoogleApps = Record<string, unknown>;

/**
 * options for the 'google-oauth2' connection
 */
export type ConnectionOptionsGoogleOAuth2 = Record<string, unknown>;

/**
 * options for the 'ip' connection
 */
export type ConnectionOptionsIp = Record<string, unknown>;

export type ConnectionOptionsInstagram = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsLine = Management.ConnectionOptionsOAuth2Common;

/**
 * options for the 'linkedin' connection
 */
export type ConnectionOptionsLinkedin = Record<string, unknown>;

export type ConnectionOptionsMiicard = Management.ConnectionOptionsOAuth2Common;

/**
 * options for the 'oauth1' connection
 */
export type ConnectionOptionsOAuth1 = Record<string, unknown>;

export type ConnectionOptionsOAuth2 = Management.ConnectionOptionsOAuth2Common;

export interface ConnectionOptionsOAuth2Common extends Management.ConnectionOptionsCommon {
    client_id?: Management.ConnectionClientId;
    client_secret?: Management.ConnectionClientSecret;
    upstream_params?: (Management.ConnectionUpstreamParams | undefined) | null;
    set_user_root_attributes?: Management.ConnectionSetUserRootAttributesEnum;
}

/**
 * options for the 'oidc' connection
 */
export type ConnectionOptionsOidc = Record<string, unknown>;

/**
 * options for the 'office365' connection
 */
export type ConnectionOptionsOffice365 = Record<string, unknown>;

/**
 * options for the 'okta' connection
 */
export type ConnectionOptionsOkta = Record<string, unknown>;

export type ConnectionOptionsPaypal = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsPaypalSandbox = Management.ConnectionOptionsOAuth2Common;

/**
 * options for the 'pingfederate' connection
 */
export type ConnectionOptionsPingFederate = Record<string, unknown>;

/**
 * options for the 'planningcenter' connection
 */
export type ConnectionOptionsPlanningCenter = Record<string, unknown>;

export type ConnectionOptionsRenren = Management.ConnectionOptionsOAuth2Common;

/**
 * options for the 'samlp' connection
 */
export type ConnectionOptionsSaml = Record<string, unknown>;

/**
 * options for the 'sms' connection
 */
export type ConnectionOptionsSms = Record<string, unknown>;

export type ConnectionOptionsSalesforce = Management.ConnectionOptionsSalesforceCommon;

export type ConnectionOptionsSalesforceCommon = Record<string, unknown>;

export type ConnectionOptionsSalesforceCommunity = Management.ConnectionOptionsSalesforceCommon;

export type ConnectionOptionsSalesforceSandbox = Management.ConnectionOptionsSalesforceCommon;

export type ConnectionOptionsSharepoint = Management.ConnectionOptionsOAuth2Common;

/**
 * options for the 'shop' connection
 */
export type ConnectionOptionsShop = Record<string, unknown>;

export type ConnectionOptionsShopify = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsSoundcloud = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsTheCity = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsTheCitySandbox = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsThirtySevenSignals = Management.ConnectionOptionsOAuth2Common;

/**
 * options for the 'twitter' connection
 */
export type ConnectionOptionsTwitter = Record<string, unknown>;

export type ConnectionOptionsUntappd = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsVkontakte = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsWeibo = Management.ConnectionOptionsOAuth2Common;

/**
 * options for the 'windowslive' connection
 */
export type ConnectionOptionsWindowsLive = Record<string, unknown>;

export type ConnectionOptionsWordpress = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsYahoo = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsYammer = Management.ConnectionOptionsOAuth2Common;

export type ConnectionOptionsYandex = Management.ConnectionOptionsOAuth2Common;

/**
 * Passkey authentication enablement
 */
export interface ConnectionPasskeyAuthenticationMethod {
    /** Determines whether passkeys are enabled */
    enabled?: boolean;
}

/** Controls the UI used to challenge the user for their passkey. */
export const ConnectionPasskeyChallengeUiEnum = {
    Both: "both",
    Autofill: "autofill",
    Button: "button",
} as const;
export type ConnectionPasskeyChallengeUiEnum =
    (typeof ConnectionPasskeyChallengeUiEnum)[keyof typeof ConnectionPasskeyChallengeUiEnum];

/**
 * Options for the passkey authentication method
 */
export interface ConnectionPasskeyOptions {
    challenge_ui?: Management.ConnectionPasskeyChallengeUiEnum;
    /** Enables or disables progressive enrollment of passkeys for the connection. */
    progressive_enrollment_enabled?: boolean;
    /** Enables or disables enrollment prompt for local passkey when user authenticates using a cross-device passkey for the connection. */
    local_enrollment_enabled?: boolean;
}

/**
 * Password authentication enablement
 */
export interface ConnectionPasswordAuthenticationMethod {
    /** Determines whether passwords are enabled */
    enabled?: boolean;
}

/**
 * Password complexity options
 */
export interface ConnectionPasswordComplexityOptions {
    /** Minimum password length */
    min_length?: number;
}

/**
 * Options for password dictionary policy
 */
export interface ConnectionPasswordDictionaryOptions {
    enable: boolean;
    /** Custom Password Dictionary. An array of up to 200 entries. */
    dictionary?: string[];
}

/**
 * Options for password history policy
 */
export interface ConnectionPasswordHistoryOptions {
    enable: boolean;
    size?: number;
}

/**
 * Options for personal info in passwords policy
 */
export interface ConnectionPasswordNoPersonalInfoOptions {
    enable: boolean;
}

/** Password strength level */
export const ConnectionPasswordPolicyEnum = {
    None: "none",
    Low: "low",
    Fair: "fair",
    Good: "good",
    Excellent: "excellent",
} as const;
export type ConnectionPasswordPolicyEnum =
    (typeof ConnectionPasswordPolicyEnum)[keyof typeof ConnectionPasswordPolicyEnum];

export interface ConnectionProfile {
    id?: Management.ConnectionProfileId;
    name?: Management.ConnectionProfileName;
    organization?: Management.ConnectionProfileOrganization;
    connection_name_prefix_template?: Management.ConnectionNamePrefixTemplate;
    enabled_features?: Management.ConnectionProfileEnabledFeatures;
    connection_config?: Management.ConnectionProfileConfig;
    strategy_overrides?: Management.ConnectionProfileStrategyOverrides;
}

/**
 * Connection profile configuration.
 */
export interface ConnectionProfileConfig {}

/**
 * Enabled features for the connection profile.
 */
export type ConnectionProfileEnabledFeatures = Management.EnabledFeaturesEnum[];

/**
 * Connection Profile identifier.
 */
export type ConnectionProfileId = string;

/**
 * The name of the connection profile.
 */
export type ConnectionProfileName = string;

/**
 * The organization of the connection profile.
 */
export interface ConnectionProfileOrganization {
    show_as_button?: Management.ConnectionProfileOrganizationShowAsButtonEnum;
    assign_membership_on_login?: Management.ConnectionProfileOrganizationAssignMembershipOnLoginEnum;
}

/** Indicates if membership should be assigned on login. */
export const ConnectionProfileOrganizationAssignMembershipOnLoginEnum = {
    None: "none",
    Optional: "optional",
    Required: "required",
} as const;
export type ConnectionProfileOrganizationAssignMembershipOnLoginEnum =
    (typeof ConnectionProfileOrganizationAssignMembershipOnLoginEnum)[keyof typeof ConnectionProfileOrganizationAssignMembershipOnLoginEnum];

/** Indicates if the organization should be shown as a button. */
export const ConnectionProfileOrganizationShowAsButtonEnum = {
    None: "none",
    Optional: "optional",
    Required: "required",
} as const;
export type ConnectionProfileOrganizationShowAsButtonEnum =
    (typeof ConnectionProfileOrganizationShowAsButtonEnum)[keyof typeof ConnectionProfileOrganizationShowAsButtonEnum];

/**
 * Connection Profile Strategy Override
 */
export interface ConnectionProfileStrategyOverride {
    enabled_features?: Management.ConnectionProfileStrategyOverridesEnabledFeatures;
    connection_config?: Management.ConnectionProfileStrategyOverridesConnectionConfig;
}

/**
 * Strategy-specific overrides for this attribute
 */
export interface ConnectionProfileStrategyOverrides {
    pingfederate?: Management.ConnectionProfileStrategyOverride;
    ad?: Management.ConnectionProfileStrategyOverride;
    adfs?: Management.ConnectionProfileStrategyOverride;
    waad?: Management.ConnectionProfileStrategyOverride;
    "google-apps"?: Management.ConnectionProfileStrategyOverride;
    okta?: Management.ConnectionProfileStrategyOverride;
    oidc?: Management.ConnectionProfileStrategyOverride;
    samlp?: Management.ConnectionProfileStrategyOverride;
}

/**
 * Connection profile strategy overrides connection configuration.
 */
export interface ConnectionProfileStrategyOverridesConnectionConfig {}

/**
 * Enabled features for a connections profile strategy override.
 */
export type ConnectionProfileStrategyOverridesEnabledFeatures = Management.EnabledFeaturesEnum[];

/**
 * The structure of the template, which can be used as the payload for creating or updating a Connection Profile.
 */
export interface ConnectionProfileTemplate {
    name?: Management.ConnectionProfileName;
    organization?: Management.ConnectionProfileOrganization;
    connection_name_prefix_template?: Management.ConnectionNamePrefixTemplate;
    enabled_features?: Management.ConnectionProfileEnabledFeatures;
    connection_config?: Management.ConnectionProfileConfig;
    strategy_overrides?: Management.ConnectionProfileStrategyOverrides;
}

export interface ConnectionProfileTemplateItem {
    /** The id of the template. */
    id?: string;
    /** The user-friendly name of the template displayed in the UI. */
    display_name?: string;
    template?: Management.ConnectionProfileTemplate;
}

/**
 * The connection's options (depend on the connection strategy)
 */
export interface ConnectionPropertiesOptions {
    validation?: Management.ConnectionValidationOptions | null;
    /** An array of user fields that should not be stored in the Auth0 database (https://auth0.com/docs/security/data-security/denylist) */
    non_persistent_attrs?: string[];
    /** Order of precedence for attribute types. If the property is not specified, the default precedence of attributes will be used. */
    precedence?: Management.ConnectionIdentifierPrecedenceEnum[];
    attributes?: Management.ConnectionAttributes;
    /** Set to true to inject context into custom DB scripts (warning: cannot be disabled once enabled) */
    enable_script_context?: boolean;
    /** Set to true to use a legacy user store */
    enabledDatabaseCustomization?: boolean;
    /** Enable this if you have a legacy user store and you want to gradually migrate those users to the Auth0 user store */
    import_mode?: boolean;
    customScripts?: Management.ConnectionCustomScripts;
    authentication_methods?: Management.ConnectionAuthenticationMethods | null;
    passkey_options?: Management.ConnectionPasskeyOptions | null;
    passwordPolicy?: Management.ConnectionPasswordPolicyEnum | null;
    password_complexity_options?: Management.ConnectionPasswordComplexityOptions | null;
    password_history?: Management.ConnectionPasswordHistoryOptions | null;
    password_no_personal_info?: Management.ConnectionPasswordNoPersonalInfoOptions | null;
    password_dictionary?: Management.ConnectionPasswordDictionaryOptions | null;
    api_enable_users?: boolean;
    basic_profile?: boolean;
    ext_admin?: boolean;
    ext_is_suspended?: boolean;
    ext_agreed_terms?: boolean;
    ext_groups?: boolean;
    ext_assigned_plans?: boolean;
    ext_profile?: boolean;
    disable_self_service_change_password?: boolean;
    upstream_params?: (Management.ConnectionUpstreamParams | undefined) | null;
    set_user_root_attributes?: Management.ConnectionSetUserRootAttributesEnum;
    gateway_authentication?: Management.ConnectionGatewayAuthentication | null;
    federated_connections_access_tokens?: Management.ConnectionFederatedConnectionsAccessTokens | null;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Indicates whether to use realm fallback.
 */
export type ConnectionRealmFallback = boolean;

/**
 * Defines the realms for which the connection will be used (ie: email domains). If the array is empty or the property is not specified, the connection name will be added as realm.
 */
export type ConnectionRealms = string[];

export interface ConnectionRequestCommon {
    display_name?: Management.ConnectionDisplayName;
    enabled_clients?: Management.ConnectionEnabledClients;
    is_domain_connection?: Management.ConnectionIsDomainConnection;
    show_as_button?: Management.ConnectionShowAsButton;
    realms?: Management.ConnectionRealms;
    metadata?: Management.ConnectionsMetadata;
    authentication?: Management.ConnectionAuthenticationPurpose;
    connected_accounts?: Management.ConnectionConnectedAccountsPurpose;
}

/**
 * Indicates whether the user is required to provide a username in addition to an email address.
 */
export type ConnectionRequiresUsername = boolean;

export interface ConnectionResponseCommon extends Management.ConnectionRequestCommon {
    id?: Management.ConnectionId;
    strategy?: Management.ConnectionIdentityProviderEnum;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=ad
 */
export interface ConnectionResponseContentAd extends Management.ConnectionRequestCommon {
    strategy: "ad";
    options?: Management.ConnectionOptionsAd;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=adfs
 */
export interface ConnectionResponseContentAdfs extends Management.ConnectionRequestCommon {
    strategy: "adfs";
    options?: Management.ConnectionOptionsAdfs;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=aol
 */
export interface ConnectionResponseContentAol extends Management.ConnectionRequestCommon {
    strategy: "aol";
    options?: Management.ConnectionOptionsAol;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=amazon
 */
export interface ConnectionResponseContentAmazon extends Management.ConnectionRequestCommon {
    strategy: "amazon";
    options?: Management.ConnectionOptionsAmazon;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=apple
 */
export interface ConnectionResponseContentApple extends Management.ConnectionRequestCommon {
    strategy: "apple";
    options?: Management.ConnectionOptionsApple;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=auth0
 */
export interface ConnectionResponseContentAuth0 extends Management.ConnectionRequestCommon {
    strategy: "auth0";
    options?: Management.ConnectionOptionsAuth0;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=auth0-oidc
 */
export interface ConnectionResponseContentAuth0Oidc extends Management.ConnectionRequestCommon {
    strategy: "auth0-oidc";
    options?: Management.ConnectionOptionsAuth0Oidc;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=waad
 */
export interface ConnectionResponseContentAzureAd extends Management.ConnectionRequestCommon {
    strategy: "waad";
    options?: Management.ConnectionOptionsAzureAd;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=baidu
 */
export interface ConnectionResponseContentBaidu extends Management.ConnectionRequestCommon {
    strategy: "baidu";
    options?: Management.ConnectionOptionsBaidu;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=bitbucket
 */
export interface ConnectionResponseContentBitbucket extends Management.ConnectionRequestCommon {
    strategy: "bitbucket";
    options?: Management.ConnectionOptionsBitbucket;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=bitly
 */
export interface ConnectionResponseContentBitly extends Management.ConnectionRequestCommon {
    strategy: "bitly";
    options?: Management.ConnectionOptionsBitly;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=box
 */
export interface ConnectionResponseContentBox extends Management.ConnectionRequestCommon {
    strategy: "box";
    options?: Management.ConnectionOptionsBox;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=custom
 */
export interface ConnectionResponseContentCustom extends Management.ConnectionRequestCommon {
    strategy: "custom";
    options?: Management.ConnectionOptionsCustom;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=daccount
 */
export interface ConnectionResponseContentDaccount extends Management.ConnectionRequestCommon {
    strategy: "daccount";
    options?: Management.ConnectionOptionsDaccount;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=dropbox
 */
export interface ConnectionResponseContentDropbox extends Management.ConnectionRequestCommon {
    strategy: "dropbox";
    options?: Management.ConnectionOptionsDropbox;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=dwolla
 */
export interface ConnectionResponseContentDwolla extends Management.ConnectionRequestCommon {
    strategy: "dwolla";
    options?: Management.ConnectionOptionsDwolla;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=email
 */
export interface ConnectionResponseContentEmail extends Management.ConnectionRequestCommon {
    strategy: "email";
    options?: Management.ConnectionOptionsEmail;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=evernote
 */
export interface ConnectionResponseContentEvernote extends Management.ConnectionRequestCommon {
    strategy: "evernote";
    options?: Management.ConnectionOptionsEvernote;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=evernote-sandbox
 */
export interface ConnectionResponseContentEvernoteSandbox extends Management.ConnectionRequestCommon {
    strategy: "evernote-sandbox";
    options?: Management.ConnectionOptionsEvernoteSandbox;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=exact
 */
export interface ConnectionResponseContentExact extends Management.ConnectionRequestCommon {
    strategy: "exact";
    options?: Management.ConnectionOptionsExact;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=facebook
 */
export interface ConnectionResponseContentFacebook extends Management.ConnectionRequestCommon {
    strategy: "facebook";
    options?: Management.ConnectionOptionsFacebook;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=fitbit
 */
export interface ConnectionResponseContentFitbit extends Management.ConnectionRequestCommon {
    strategy: "fitbit";
    options?: Management.ConnectionOptionsFitbit;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=flickr
 */
export interface ConnectionResponseContentFlickr extends Management.ConnectionRequestCommon {
    strategy: "flickr";
    options?: Management.ConnectionOptionsFlickr;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=github
 */
export interface ConnectionResponseContentGitHub extends Management.ConnectionRequestCommon {
    strategy: "github";
    options?: Management.ConnectionOptionsGitHub;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=google-apps
 */
export interface ConnectionResponseContentGoogleApps extends Management.ConnectionRequestCommon {
    strategy: "google-apps";
    options?: Management.ConnectionOptionsGoogleApps;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=google-oauth2
 */
export interface ConnectionResponseContentGoogleOAuth2 extends Management.ConnectionRequestCommon {
    strategy: "google-oauth2";
    options?: Management.ConnectionOptionsGoogleOAuth2;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=ip
 */
export interface ConnectionResponseContentIp extends Management.ConnectionRequestCommon {
    strategy: "ip";
    options?: Management.ConnectionOptionsIp;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=instagram
 */
export interface ConnectionResponseContentInstagram extends Management.ConnectionRequestCommon {
    strategy: "instagram";
    options?: Management.ConnectionOptionsInstagram;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=line
 */
export interface ConnectionResponseContentLine extends Management.ConnectionRequestCommon {
    strategy: "line";
    options?: Management.ConnectionOptionsLine;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=linkedin
 */
export interface ConnectionResponseContentLinkedin extends Management.ConnectionRequestCommon {
    strategy: "linkedin";
    options?: Management.ConnectionOptionsLinkedin;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=miicard
 */
export interface ConnectionResponseContentMiicard extends Management.ConnectionRequestCommon {
    strategy: "miicard";
    options?: Management.ConnectionOptionsMiicard;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=oauth1
 */
export interface ConnectionResponseContentOAuth1 extends Management.ConnectionRequestCommon {
    strategy: "oauth1";
    options?: Management.ConnectionOptionsOAuth1;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=oauth2
 */
export interface ConnectionResponseContentOAuth2 extends Management.ConnectionRequestCommon {
    strategy: "oauth2";
    options?: Management.ConnectionOptionsOAuth2;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=oidc
 */
export interface ConnectionResponseContentOidc extends Management.ConnectionRequestCommon {
    strategy: "oidc";
    options?: Management.ConnectionOptionsOidc;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=office365
 */
export interface ConnectionResponseContentOffice365 extends Management.ConnectionRequestCommon {
    strategy: "office365";
    options?: Management.ConnectionOptionsOffice365;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=okta
 */
export interface ConnectionResponseContentOkta extends Management.ConnectionRequestCommon {
    strategy: "okta";
    options?: Management.ConnectionOptionsOkta;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=paypal
 */
export interface ConnectionResponseContentPaypal extends Management.ConnectionRequestCommon {
    strategy: "paypal";
    options?: Management.ConnectionOptionsPaypal;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=paypal-sandbox
 */
export interface ConnectionResponseContentPaypalSandbox extends Management.ConnectionRequestCommon {
    strategy: "paypal-sandbox";
    options?: Management.ConnectionOptionsPaypalSandbox;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=pingfederate
 */
export interface ConnectionResponseContentPingFederate extends Management.ConnectionRequestCommon {
    strategy: "pingfederate";
    options?: Management.ConnectionOptionsPingFederate;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=planningcenter
 */
export interface ConnectionResponseContentPlanningCenter extends Management.ConnectionRequestCommon {
    strategy: "planningcenter";
    options?: Management.ConnectionOptionsPlanningCenter;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=renren
 */
export interface ConnectionResponseContentRenren extends Management.ConnectionRequestCommon {
    strategy: "renren";
    options?: Management.ConnectionOptionsRenren;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=samlp
 */
export interface ConnectionResponseContentSaml extends Management.ConnectionRequestCommon {
    strategy: "samlp";
    options?: Management.ConnectionOptionsSaml;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=sms
 */
export interface ConnectionResponseContentSms extends Management.ConnectionRequestCommon {
    strategy: "sms";
    options?: Management.ConnectionOptionsSms;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=salesforce
 */
export interface ConnectionResponseContentSalesforce extends Management.ConnectionRequestCommon {
    strategy: "salesforce";
    options?: Management.ConnectionOptionsSalesforce;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=salesforce-community
 */
export interface ConnectionResponseContentSalesforceCommunity extends Management.ConnectionRequestCommon {
    strategy: "salesforce-community";
    options?: Management.ConnectionOptionsSalesforceCommunity;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=salesforce-sandbox
 */
export interface ConnectionResponseContentSalesforceSandbox extends Management.ConnectionRequestCommon {
    strategy: "salesforce-sandbox";
    options?: Management.ConnectionOptionsSalesforceSandbox;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=sharepoint
 */
export interface ConnectionResponseContentSharepoint extends Management.ConnectionRequestCommon {
    strategy: "sharepoint";
    options?: Management.ConnectionOptionsSharepoint;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=shop
 */
export interface ConnectionResponseContentShop extends Management.ConnectionRequestCommon {
    strategy: "shop";
    options?: Management.ConnectionOptionsShop;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=shopify
 */
export interface ConnectionResponseContentShopify extends Management.ConnectionRequestCommon {
    strategy: "shopify";
    options?: Management.ConnectionOptionsShopify;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=soundcloud
 */
export interface ConnectionResponseContentSoundcloud extends Management.ConnectionRequestCommon {
    strategy: "soundcloud";
    options?: Management.ConnectionOptionsSoundcloud;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=thecity
 */
export interface ConnectionResponseContentTheCity extends Management.ConnectionRequestCommon {
    strategy: "thecity";
    options?: Management.ConnectionOptionsTheCity;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=thecity-sandbox
 */
export interface ConnectionResponseContentTheCitySandbox extends Management.ConnectionRequestCommon {
    strategy: "thecity-sandbox";
    options?: Management.ConnectionOptionsTheCitySandbox;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=thirtysevensignals
 */
export interface ConnectionResponseContentThirtySevenSignals extends Management.ConnectionRequestCommon {
    strategy: "thirtysevensignals";
    options?: Management.ConnectionOptionsThirtySevenSignals;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=twitter
 */
export interface ConnectionResponseContentTwitter extends Management.ConnectionRequestCommon {
    strategy: "twitter";
    options?: Management.ConnectionOptionsTwitter;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=untappd
 */
export interface ConnectionResponseContentUntappd extends Management.ConnectionRequestCommon {
    strategy: "untappd";
    options?: Management.ConnectionOptionsUntappd;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=vkontakte
 */
export interface ConnectionResponseContentVkontakte extends Management.ConnectionRequestCommon {
    strategy: "vkontakte";
    options?: Management.ConnectionOptionsVkontakte;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=weibo
 */
export interface ConnectionResponseContentWeibo extends Management.ConnectionRequestCommon {
    strategy: "weibo";
    options?: Management.ConnectionOptionsWeibo;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=windowslive
 */
export interface ConnectionResponseContentWindowsLive extends Management.ConnectionRequestCommon {
    strategy: "windowslive";
    options?: Management.ConnectionOptionsWindowsLive;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=wordpress
 */
export interface ConnectionResponseContentWordpress extends Management.ConnectionRequestCommon {
    strategy: "wordpress";
    options?: Management.ConnectionOptionsWordpress;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=yahoo
 */
export interface ConnectionResponseContentYahoo extends Management.ConnectionRequestCommon {
    strategy: "yahoo";
    options?: Management.ConnectionOptionsYahoo;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=yammer
 */
export interface ConnectionResponseContentYammer extends Management.ConnectionRequestCommon {
    strategy: "yammer";
    options?: Management.ConnectionOptionsYammer;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Response for connections with strategy=yandex
 */
export interface ConnectionResponseContentYandex extends Management.ConnectionRequestCommon {
    strategy: "yandex";
    options?: Management.ConnectionOptionsYandex;
    id?: Management.ConnectionId;
    name?: Management.ConnectionName;
}

/**
 * Space separated list of scopes
 */
export type ConnectionScopeString = string;

/** When using an external IdP, this flag determines  whether 'name', 'given_name', 'family_name', 'nickname', and 'picture' attributes are updated. In addition, it also determines whether the user is created when user doesnt exist previously. Possible values are 'on_each_login' (default value, it configures the connection to automatically create the user if necessary and update the root attributes from the external IdP with each user login. When this setting is used, root attributes cannot be independently updated), 'on_first_login' (configures the connection to create the user and set the root attributes on first login only, allowing them to be independently updated thereafter), and 'never_on_login' (configures the connection not to create the user and not to set the root attributes from the external IdP, allowing them to be independently updated). */
export const ConnectionSetUserRootAttributesEnum = {
    OnEachLogin: "on_each_login",
    OnFirstLogin: "on_first_login",
    NeverOnLogin: "never_on_login",
} as const;
export type ConnectionSetUserRootAttributesEnum =
    (typeof ConnectionSetUserRootAttributesEnum)[keyof typeof ConnectionSetUserRootAttributesEnum];

/**
 * Enables showing a button for the connection in the login page (new experience only). If false, it will be usable only by HRD. (Defaults to <code>false</code>.)
 */
export type ConnectionShowAsButton = boolean;

export const ConnectionStrategyEnum = {
    Ad: "ad",
    Adfs: "adfs",
    Amazon: "amazon",
    Apple: "apple",
    Dropbox: "dropbox",
    Bitbucket: "bitbucket",
    Aol: "aol",
    Auth0Oidc: "auth0-oidc",
    Auth0: "auth0",
    Baidu: "baidu",
    Bitly: "bitly",
    Box: "box",
    Custom: "custom",
    Daccount: "daccount",
    Dwolla: "dwolla",
    Email: "email",
    EvernoteSandbox: "evernote-sandbox",
    Evernote: "evernote",
    Exact: "exact",
    Facebook: "facebook",
    Fitbit: "fitbit",
    Flickr: "flickr",
    Github: "github",
    GoogleApps: "google-apps",
    GoogleOauth2: "google-oauth2",
    Instagram: "instagram",
    Ip: "ip",
    Line: "line",
    Linkedin: "linkedin",
    Miicard: "miicard",
    Oauth1: "oauth1",
    Oauth2: "oauth2",
    Office365: "office365",
    Oidc: "oidc",
    Okta: "okta",
    Paypal: "paypal",
    PaypalSandbox: "paypal-sandbox",
    Pingfederate: "pingfederate",
    Planningcenter: "planningcenter",
    Renren: "renren",
    SalesforceCommunity: "salesforce-community",
    SalesforceSandbox: "salesforce-sandbox",
    Salesforce: "salesforce",
    Samlp: "samlp",
    Sharepoint: "sharepoint",
    Shopify: "shopify",
    Shop: "shop",
    Sms: "sms",
    Soundcloud: "soundcloud",
    ThecitySandbox: "thecity-sandbox",
    Thecity: "thecity",
    Thirtysevensignals: "thirtysevensignals",
    Twitter: "twitter",
    Untappd: "untappd",
    Vkontakte: "vkontakte",
    Waad: "waad",
    Weibo: "weibo",
    Windowslive: "windowslive",
    Wordpress: "wordpress",
    Yahoo: "yahoo",
    Yammer: "yammer",
    Yandex: "yandex",
    Auth0Adldap: "auth0-adldap",
} as const;
export type ConnectionStrategyEnum = (typeof ConnectionStrategyEnum)[keyof typeof ConnectionStrategyEnum];

export type ConnectionUpstreamAdditionalProperties =
    | Management.ConnectionUpstreamAlias
    | Management.ConnectionUpstreamValue;

export interface ConnectionUpstreamAlias {
    alias?: Management.ConnectionUpstreamAliasEnum;
}

export const ConnectionUpstreamAliasEnum = {
    AcrValues: "acr_values",
    Audience: "audience",
    ClientId: "client_id",
    Display: "display",
    IdTokenHint: "id_token_hint",
    LoginHint: "login_hint",
    MaxAge: "max_age",
    Prompt: "prompt",
    Resource: "resource",
    ResponseMode: "response_mode",
    ResponseType: "response_type",
    UiLocales: "ui_locales",
} as const;
export type ConnectionUpstreamAliasEnum =
    (typeof ConnectionUpstreamAliasEnum)[keyof typeof ConnectionUpstreamAliasEnum];

/**
 * Options for adding parameters in the request to the upstream IdP
 */
export type ConnectionUpstreamParams =
    | (Record<string, (Management.ConnectionUpstreamAdditionalProperties | null) | undefined> | null)
    | undefined;

export interface ConnectionUpstreamValue {
    value?: string;
}

export interface ConnectionUsernameValidationOptions {
    min: number;
    max: number;
}

/**
 * Options for validation
 */
export interface ConnectionValidationOptions {
    username?: Management.ConnectionUsernameValidationOptions | null;
}

/**
 * Metadata associated with the connection in the form of an object with string values (max 255 chars).  Maximum of 10 metadata properties allowed.
 */
export type ConnectionsMetadata = Record<string, (string | null) | undefined>;

export interface CreateActionResponseContent {
    /** The unique ID of the action. */
    id?: string;
    /** The name of an action. */
    name?: string;
    /** The list of triggers that this action supports. At this time, an action can only target a single trigger at a time. */
    supported_triggers?: Management.ActionTrigger[];
    /** True if all of an Action's contents have been deployed. */
    all_changes_deployed?: boolean;
    /** The time when this action was created. */
    created_at?: string;
    /** The time when this action was updated. */
    updated_at?: string;
    /** The source code of the action. */
    code?: string;
    /** The list of third party npm modules, and their versions, that this action depends on. */
    dependencies?: Management.ActionVersionDependency[];
    /** The Node runtime. For example: `node22`, defaults to `node22` */
    runtime?: string;
    /** The list of secrets that are included in an action or a version of an action. */
    secrets?: Management.ActionSecretResponse[];
    deployed_version?: Management.ActionDeployedVersion;
    /** installed_integration_id is the fk reference to the InstalledIntegration entity. */
    installed_integration_id?: string;
    integration?: Management.Integration;
    status?: Management.ActionBuildStatusEnum;
    /** The time when this action was built successfully. */
    built_at?: string;
    /** True if the action should be deployed after creation. */
    deploy?: boolean;
}

/**
 * Phone provider configuration schema
 */
export interface CreateBrandingPhoneProviderResponseContent {
    id?: string;
    /** The name of the tenant */
    tenant?: string;
    name: Management.PhoneProviderNameEnum;
    channel?: Management.PhoneProviderChannelEnum;
    /** Whether the provider is enabled (false) or disabled (true). */
    disabled?: boolean;
    configuration?: Management.PhoneProviderConfiguration;
    /** The provider's creation date and time in ISO 8601 format */
    created_at?: string;
    /** The date and time of the last update to the provider in ISO 8601 format */
    updated_at?: string;
}

export interface CreateBrandingThemeResponseContent {
    borders: Management.BrandingThemeBorders;
    colors: Management.BrandingThemeColors;
    /** Display Name */
    displayName: string;
    fonts: Management.BrandingThemeFonts;
    page_background: Management.BrandingThemePageBackground;
    /** Theme Id */
    themeId: string;
    widget: Management.BrandingThemeWidget;
}

export interface CreateClientGrantResponseContent {
    /** ID of the client grant. */
    id?: string;
    /** ID of the client. */
    client_id?: string;
    /** The audience (API identifier) of this client grant. */
    audience?: string;
    /** Scopes allowed for this client grant. */
    scope?: string[];
    organization_usage?: Management.ClientGrantOrganizationUsageEnum;
    /** If enabled, any organization can be used with this grant. If disabled (default), the grant must be explicitly assigned to the desired organizations. */
    allow_any_organization?: boolean;
    /** If enabled, this grant is a special grant created by Auth0. It cannot be modified or deleted directly. */
    is_system?: boolean;
    subject_type?: Management.ClientGrantSubjectTypeEnum;
    /** Types of authorization_details allowed for this client grant. Use of this field is subject to the applicable Free Trial terms in Oktaâ€™s <a href= "https://www.okta.com/legal/"> Master Subscription Agreement.</a> */
    authorization_details_types?: string[];
}

export interface CreateClientResponseContent {
    /** ID of this client. */
    client_id?: string;
    /** Name of the tenant this client belongs to. */
    tenant?: string;
    /** Name of this client (min length: 1 character, does not allow `<` or `>`). */
    name?: string;
    /** Free text description of this client (max length: 140 characters). */
    description?: string;
    /** Whether this is your global 'All Applications' client representing legacy tenant settings (true) or a regular client (false). */
    global?: boolean;
    /** Client secret (which you must not make public). */
    client_secret?: string;
    app_type?: Management.ClientAppTypeEnum;
    /** URL of the logo to display for this client. Recommended size is 150x150 pixels. */
    logo_uri?: string;
    /** Whether this client a first party client (true) or not (false). */
    is_first_party?: boolean;
    /** Whether this client conforms to <a href='https://auth0.com/docs/api-auth/tutorials/adoption'>strict OIDC specifications</a> (true) or uses legacy features (false). */
    oidc_conformant?: boolean;
    /** Comma-separated list of URLs whitelisted for Auth0 to use as a callback to the client after authentication. */
    callbacks?: string[];
    /** Comma-separated list of URLs allowed to make requests from JavaScript to Auth0 API (typically used with CORS). By default, all your callback URLs will be allowed. This field allows you to enter other origins if necessary. You can also use wildcards at the subdomain level (e.g., https://*.contoso.com). Query strings and hash information are not taken into account when validating these URLs. */
    allowed_origins?: string[];
    /** Comma-separated list of allowed origins for use with <a href='https://auth0.com/docs/cross-origin-authentication'>Cross-Origin Authentication</a>, <a href='https://auth0.com/docs/flows/concepts/device-auth'>Device Flow</a>, and <a href='https://auth0.com/docs/protocols/oauth2#how-response-mode-works'>web message response mode</a>. */
    web_origins?: string[];
    /** List of audiences/realms for SAML protocol. Used by the wsfed addon. */
    client_aliases?: string[];
    /** List of allow clients and API ids that are allowed to make delegation requests. Empty means all all your clients are allowed. */
    allowed_clients?: string[];
    /** Comma-separated list of URLs that are valid to redirect to after logout from Auth0. Wildcards are allowed for subdomains. */
    allowed_logout_urls?: string[];
    session_transfer?: Management.ClientSessionTransferConfiguration | null;
    oidc_logout?: Management.ClientOidcBackchannelLogoutSettings;
    /** List of grant types supported for this application. Can include `authorization_code`, `implicit`, `refresh_token`, `client_credentials`, `password`, `http://auth0.com/oauth/grant-type/password-realm`, `http://auth0.com/oauth/grant-type/mfa-oob`, `http://auth0.com/oauth/grant-type/mfa-otp`, `http://auth0.com/oauth/grant-type/mfa-recovery-code`, `urn:openid:params:grant-type:ciba`, `urn:ietf:params:oauth:grant-type:device_code`, and `urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token`. */
    grant_types?: string[];
    jwt_configuration?: Management.ClientJwtConfiguration;
    signing_keys?: Management.ClientSigningKeys;
    encryption_key?: Management.ClientEncryptionKey | null;
    /** Applies only to SSO clients and determines whether Auth0 will handle Single Sign On (true) or whether the Identity Provider will (false). */
    sso?: boolean;
    /** Whether Single Sign On is disabled (true) or enabled (true). Defaults to true. */
    sso_disabled?: boolean;
    /** Whether this client can be used to make cross-origin authentication requests (true) or it is not allowed to make such requests (false). */
    cross_origin_authentication?: boolean;
    /** URL of the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page. */
    cross_origin_loc?: string;
    /** Whether a custom login page is to be used (true) or the default provided login page (false). */
    custom_login_page_on?: boolean;
    /** The content (HTML, CSS, JS) of the custom login page. */
    custom_login_page?: string;
    /** The content (HTML, CSS, JS) of the custom login page. (Used on Previews) */
    custom_login_page_preview?: string;
    /** HTML form template to be used for WS-Federation. */
    form_template?: string;
    addons?: Management.ClientAddons;
    token_endpoint_auth_method?: Management.ClientTokenEndpointAuthMethodEnum;
    /** If true, trust that the IP specified in the `auth0-forwarded-for` header is the end-user's IP for brute-force-protection on token endpoint. */
    is_token_endpoint_ip_header_trusted?: boolean;
    client_metadata?: Management.ClientMetadata;
    mobile?: Management.ClientMobile;
    /** Initiate login uri, must be https */
    initiate_login_uri?: string;
    refresh_token?: Management.ClientRefreshTokenConfiguration | null;
    default_organization?: Management.ClientDefaultOrganization | null;
    organization_usage?: Management.ClientOrganizationUsageEnum;
    organization_require_behavior?: Management.ClientOrganizationRequireBehaviorEnum;
    /** Defines the available methods for organization discovery during the `pre_login_prompt`. Users can discover their organization either by `email`, `organization_name` or both. */
    organization_discovery_methods?: Management.ClientOrganizationDiscoveryEnum[];
    client_authentication_methods?: Management.ClientAuthenticationMethod | null;
    /** Makes the use of Pushed Authorization Requests mandatory for this client */
    require_pushed_authorization_requests?: boolean;
    /** Makes the use of Proof-of-Possession mandatory for this client */
    require_proof_of_possession?: boolean;
    signed_request_object?: Management.ClientSignedRequestObjectWithCredentialId;
    compliance_level?: Management.ClientComplianceLevelEnum | null;
    /**
     * Controls whether a confirmation prompt is shown during login flows when the redirect URI uses non-verifiable callback URIs (for example, a custom URI schema such as `myapp://`, or `localhost`).
     * If set to true, a confirmation prompt will not be shown. We recommend that this is set to false for improved protection from malicious apps.
     * See https://auth0.com/docs/secure/security-guidance/measures-against-app-impersonation for more information.
     */
    skip_non_verifiable_callback_uri_confirmation_prompt?: boolean;
    /** Specifies how long, in seconds, a Pushed Authorization Request URI remains valid */
    par_request_expiry?: number | null;
    token_quota?: Management.TokenQuota;
    express_configuration?: Management.ExpressConfiguration;
    /** The identifier of the resource server that this client is linked to. */
    resource_server_identifier?: string;
    async_approval_notification_channels?: Management.ClientAsyncApprovalNotificationsChannelsApiPostConfiguration;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface CreateConnectionProfileResponseContent {
    id?: Management.ConnectionProfileId;
    name?: Management.ConnectionProfileName;
    organization?: Management.ConnectionProfileOrganization;
    connection_name_prefix_template?: Management.ConnectionNamePrefixTemplate;
    enabled_features?: Management.ConnectionProfileEnabledFeatures;
    connection_config?: Management.ConnectionProfileConfig;
    strategy_overrides?: Management.ConnectionProfileStrategyOverrides;
}

/**
 * Create a connection with strategy=ad
 */
export interface CreateConnectionRequestContentAd extends Management.ConnectionRequestCommon {
    strategy: "ad";
    options?: Management.ConnectionOptionsAd;
}

/**
 * Create a connection with strategy=adfs
 */
export interface CreateConnectionRequestContentAdfs extends Management.ConnectionRequestCommon {
    strategy: "adfs";
    options?: Management.ConnectionOptionsAdfs;
}

/**
 * Create a connection with strategy=aol
 */
export interface CreateConnectionRequestContentAol extends Management.ConnectionRequestCommon {
    strategy: "aol";
    options?: Management.ConnectionOptionsAol;
}

/**
 * Create a connection with strategy=amazon
 */
export interface CreateConnectionRequestContentAmazon extends Management.ConnectionRequestCommon {
    strategy: "amazon";
    options?: Management.ConnectionOptionsAmazon;
}

/**
 * Create a connection with strategy=apple
 */
export interface CreateConnectionRequestContentApple extends Management.ConnectionRequestCommon {
    strategy: "apple";
    options?: Management.ConnectionOptionsApple;
}

/**
 * Create a connection with strategy=auth0
 */
export interface CreateConnectionRequestContentAuth0 extends Management.ConnectionRequestCommon {
    strategy: "auth0";
    options?: Management.ConnectionOptionsAuth0;
}

/**
 * Create a connection with strategy=auth0-oidc
 */
export interface CreateConnectionRequestContentAuth0Oidc extends Management.ConnectionRequestCommon {
    strategy: "auth0-oidc";
    options?: Management.ConnectionOptionsAuth0Oidc;
}

/**
 * Create a connection with strategy=waad
 */
export interface CreateConnectionRequestContentAzureAd extends Management.ConnectionRequestCommon {
    strategy: "waad";
    options?: Management.ConnectionOptionsAzureAd;
}

/**
 * Create a connection with strategy=baidu
 */
export interface CreateConnectionRequestContentBaidu extends Management.ConnectionRequestCommon {
    strategy: "baidu";
    options?: Management.ConnectionOptionsBaidu;
}

/**
 * Create a connection with strategy=bitbucket
 */
export interface CreateConnectionRequestContentBitbucket extends Management.ConnectionRequestCommon {
    strategy: "bitbucket";
    options?: Management.ConnectionOptionsBitbucket;
}

/**
 * Create a connection with strategy=bitly
 */
export interface CreateConnectionRequestContentBitly extends Management.ConnectionRequestCommon {
    strategy: "bitly";
    options?: Management.ConnectionOptionsBitly;
}

/**
 * Create a connection with strategy=box
 */
export interface CreateConnectionRequestContentBox extends Management.ConnectionRequestCommon {
    strategy: "box";
    options?: Management.ConnectionOptionsBox;
}

/**
 * Create a connection with strategy=custom
 */
export interface CreateConnectionRequestContentCustom extends Management.ConnectionRequestCommon {
    strategy: "custom";
    options?: Management.ConnectionOptionsCustom;
}

/**
 * Create a connection with strategy=daccount
 */
export interface CreateConnectionRequestContentDaccount extends Management.ConnectionRequestCommon {
    strategy: "daccount";
    options?: Management.ConnectionOptionsDaccount;
}

/**
 * Create a connection with strategy=dropbox
 */
export interface CreateConnectionRequestContentDropbox extends Management.ConnectionRequestCommon {
    strategy: "dropbox";
    options?: Management.ConnectionOptionsDropbox;
}

/**
 * Create a connection with strategy=dwolla
 */
export interface CreateConnectionRequestContentDwolla extends Management.ConnectionRequestCommon {
    strategy: "dwolla";
    options?: Management.ConnectionOptionsDwolla;
}

/**
 * Create a connection with strategy=email
 */
export interface CreateConnectionRequestContentEmail extends Management.ConnectionRequestCommon {
    strategy: "email";
    options?: Management.ConnectionOptionsEmail;
}

/**
 * Create a connection with strategy=evernote
 */
export interface CreateConnectionRequestContentEvernote extends Management.ConnectionRequestCommon {
    strategy: "evernote";
    options?: Management.ConnectionOptionsEvernote;
}

/**
 * Create a connection with strategy=evernote-sandbox
 */
export interface CreateConnectionRequestContentEvernoteSandbox extends Management.ConnectionRequestCommon {
    strategy: "evernote-sandbox";
    options?: Management.ConnectionOptionsEvernoteSandbox;
}

/**
 * Create a connection with strategy=exact
 */
export interface CreateConnectionRequestContentExact extends Management.ConnectionRequestCommon {
    strategy: "exact";
    options?: Management.ConnectionOptionsExact;
}

/**
 * Create a connection with strategy=facebook
 */
export interface CreateConnectionRequestContentFacebook extends Management.ConnectionRequestCommon {
    strategy: "facebook";
    options?: Management.ConnectionOptionsFacebook;
}

/**
 * Create a connection with strategy=fitbit
 */
export interface CreateConnectionRequestContentFitbit extends Management.ConnectionRequestCommon {
    strategy: "fitbit";
    options?: Management.ConnectionOptionsFitbit;
}

/**
 * Create a connection with strategy=flickr
 */
export interface CreateConnectionRequestContentFlickr extends Management.ConnectionRequestCommon {
    strategy: "flickr";
    options?: Management.ConnectionOptionsFlickr;
}

/**
 * Create a connection with strategy=github
 */
export interface CreateConnectionRequestContentGitHub extends Management.ConnectionRequestCommon {
    strategy: "github";
    options?: Management.ConnectionOptionsGitHub;
}

/**
 * Create a connection with strategy=google-apps
 */
export interface CreateConnectionRequestContentGoogleApps extends Management.ConnectionRequestCommon {
    strategy: "google-apps";
    options?: Management.ConnectionOptionsGoogleApps;
}

/**
 * Create a connection with strategy=google-oauth2
 */
export interface CreateConnectionRequestContentGoogleOAuth2 extends Management.ConnectionRequestCommon {
    strategy: "google-oauth2";
    options?: Management.ConnectionOptionsGoogleOAuth2;
}

/**
 * Create a connection with strategy=ip
 */
export interface CreateConnectionRequestContentIp extends Management.ConnectionRequestCommon {
    strategy: "ip";
    options?: Management.ConnectionOptionsIp;
}

/**
 * Create a connection with strategy=instagram
 */
export interface CreateConnectionRequestContentInstagram extends Management.ConnectionRequestCommon {
    strategy: "instagram";
    options?: Management.ConnectionOptionsInstagram;
}

/**
 * Create a connection with strategy=line
 */
export interface CreateConnectionRequestContentLine extends Management.ConnectionRequestCommon {
    strategy: "line";
    options?: Management.ConnectionOptionsLine;
}

/**
 * Create a connection with strategy=linkedin
 */
export interface CreateConnectionRequestContentLinkedin extends Management.ConnectionRequestCommon {
    strategy: "linkedin";
    options?: Management.ConnectionOptionsLinkedin;
}

/**
 * Create a connection with strategy=miicard
 */
export interface CreateConnectionRequestContentMiicard extends Management.ConnectionRequestCommon {
    strategy: "miicard";
    options?: Management.ConnectionOptionsMiicard;
}

/**
 * Create a connection with strategy=oauth1
 */
export interface CreateConnectionRequestContentOAuth1 extends Management.ConnectionRequestCommon {
    strategy: "oauth1";
    options?: Management.ConnectionOptionsOAuth1;
}

/**
 * Create a connection with strategy=oauth2
 */
export interface CreateConnectionRequestContentOAuth2 extends Management.ConnectionRequestCommon {
    strategy: "oauth2";
    options?: Management.ConnectionOptionsOAuth2;
}

/**
 * Create a connection with strategy=oidc
 */
export interface CreateConnectionRequestContentOidc extends Management.ConnectionRequestCommon {
    strategy: "oidc";
    options?: Management.ConnectionOptionsOidc;
}

/**
 * Create a connection with strategy=office365
 */
export interface CreateConnectionRequestContentOffice365 extends Management.ConnectionRequestCommon {
    strategy: "office365";
    options?: Management.ConnectionOptionsOffice365;
}

/**
 * Create a connection with strategy=okta
 */
export interface CreateConnectionRequestContentOkta extends Management.ConnectionRequestCommon {
    strategy: "okta";
    options?: Management.ConnectionOptionsOkta;
}

/**
 * Create a connection with strategy=paypal
 */
export interface CreateConnectionRequestContentPaypal extends Management.ConnectionRequestCommon {
    strategy: "paypal";
    options?: Management.ConnectionOptionsPaypal;
}

/**
 * Create a connection with strategy=paypal-sandbox
 */
export interface CreateConnectionRequestContentPaypalSandbox extends Management.ConnectionRequestCommon {
    strategy: "paypal-sandbox";
    options?: Management.ConnectionOptionsPaypalSandbox;
}

/**
 * Create a connection with strategy=pingfederate
 */
export interface CreateConnectionRequestContentPingFederate extends Management.ConnectionRequestCommon {
    strategy: "pingfederate";
    options?: Management.ConnectionOptionsPingFederate;
}

/**
 * Create a connection with strategy=planningcenter
 */
export interface CreateConnectionRequestContentPlanningCenter extends Management.ConnectionRequestCommon {
    strategy: "planningcenter";
    options?: Management.ConnectionOptionsPlanningCenter;
}

/**
 * Create a connection with strategy=renren
 */
export interface CreateConnectionRequestContentRenren extends Management.ConnectionRequestCommon {
    strategy: "renren";
    options?: Management.ConnectionOptionsRenren;
}

/**
 * Create a connection with strategy=samlp
 */
export interface CreateConnectionRequestContentSaml extends Management.ConnectionRequestCommon {
    strategy: "samlp";
    options?: Management.ConnectionOptionsSaml;
}

/**
 * Create a connection with strategy=sms
 */
export interface CreateConnectionRequestContentSms extends Management.ConnectionRequestCommon {
    strategy: "sms";
    options?: Management.ConnectionOptionsSms;
}

/**
 * Create a connection with strategy=salesforce
 */
export interface CreateConnectionRequestContentSalesforce extends Management.ConnectionRequestCommon {
    strategy: "salesforce";
    options?: Management.ConnectionOptionsSalesforce;
}

/**
 * Create a connection with strategy=salesforce-community
 */
export interface CreateConnectionRequestContentSalesforceCommunity extends Management.ConnectionRequestCommon {
    strategy: "salesforce-community";
    options?: Management.ConnectionOptionsSalesforceCommunity;
}

/**
 * Create a connection with strategy=salesforce-sandbox
 */
export interface CreateConnectionRequestContentSalesforceSandbox extends Management.ConnectionRequestCommon {
    strategy: "salesforce-sandbox";
    options?: Management.ConnectionOptionsSalesforceSandbox;
}

/**
 * Create a connection with strategy=sharepoint
 */
export interface CreateConnectionRequestContentSharepoint extends Management.ConnectionRequestCommon {
    strategy: "sharepoint";
    options?: Management.ConnectionOptionsSharepoint;
}

/**
 * Create a connection with strategy=shop
 */
export interface CreateConnectionRequestContentShop extends Management.ConnectionRequestCommon {
    strategy: "shop";
    options?: Management.ConnectionOptionsShop;
}

/**
 * Create a connection with strategy=shopify
 */
export interface CreateConnectionRequestContentShopify extends Management.ConnectionRequestCommon {
    strategy: "shopify";
    options?: Management.ConnectionOptionsShopify;
}

/**
 * Create a connection with strategy=soundcloud
 */
export interface CreateConnectionRequestContentSoundcloud extends Management.ConnectionRequestCommon {
    strategy: "soundcloud";
    options?: Management.ConnectionOptionsSoundcloud;
}

/**
 * Create a connection with strategy=thecity
 */
export interface CreateConnectionRequestContentTheCity extends Management.ConnectionRequestCommon {
    strategy: "thecity";
    options?: Management.ConnectionOptionsTheCity;
}

/**
 * Create a connection with strategy=thecity-sandbox
 */
export interface CreateConnectionRequestContentTheCitySandbox extends Management.ConnectionRequestCommon {
    strategy: "thecity-sandbox";
    options?: Management.ConnectionOptionsTheCitySandbox;
}

/**
 * Create a connection with strategy=thirtysevensignals
 */
export interface CreateConnectionRequestContentThirtySevenSignals extends Management.ConnectionRequestCommon {
    strategy: "thirtysevensignals";
    options?: Management.ConnectionOptionsThirtySevenSignals;
}

/**
 * Create a connection with strategy=twitter
 */
export interface CreateConnectionRequestContentTwitter extends Management.ConnectionRequestCommon {
    strategy: "twitter";
    options?: Management.ConnectionOptionsTwitter;
}

/**
 * Create a connection with strategy=untappd
 */
export interface CreateConnectionRequestContentUntappd extends Management.ConnectionRequestCommon {
    strategy: "untappd";
    options?: Management.ConnectionOptionsUntappd;
}

/**
 * Create a connection with strategy=vkontakte
 */
export interface CreateConnectionRequestContentVkontakte extends Management.ConnectionRequestCommon {
    strategy: "vkontakte";
    options?: Management.ConnectionOptionsVkontakte;
}

/**
 * Create a connection with strategy=weibo
 */
export interface CreateConnectionRequestContentWeibo extends Management.ConnectionRequestCommon {
    strategy: "weibo";
    options?: Management.ConnectionOptionsWeibo;
}

/**
 * Create a connection with strategy=windowslive
 */
export interface CreateConnectionRequestContentWindowsLive extends Management.ConnectionRequestCommon {
    strategy: "windowslive";
    options?: Management.ConnectionOptionsWindowsLive;
}

/**
 * Create a connection with strategy=wordpress
 */
export interface CreateConnectionRequestContentWordpress extends Management.ConnectionRequestCommon {
    strategy: "wordpress";
    options?: Management.ConnectionOptionsWordpress;
}

/**
 * Create a connection with strategy=yahoo
 */
export interface CreateConnectionRequestContentYahoo extends Management.ConnectionRequestCommon {
    strategy: "yahoo";
    options?: Management.ConnectionOptionsYahoo;
}

/**
 * Create a connection with strategy=yammer
 */
export interface CreateConnectionRequestContentYammer extends Management.ConnectionRequestCommon {
    strategy: "yammer";
    options?: Management.ConnectionOptionsYammer;
}

/**
 * Create a connection with strategy=yandex
 */
export interface CreateConnectionRequestContentYandex extends Management.ConnectionRequestCommon {
    strategy: "yandex";
    options?: Management.ConnectionOptionsYandex;
}

export interface CreateConnectionResponseContent {
    /** The name of the connection */
    name?: string;
    /** Connection name used in login screen */
    display_name?: string;
    options?: Management.ConnectionOptions;
    /** The connection's identifier */
    id?: string;
    /** The type of the connection, related to the identity provider */
    strategy?: string;
    /** Defines the realms for which the connection will be used (ie: email domains). If the array is empty or the property is not specified, the connection name will be added as realm. */
    realms?: string[];
    /** DEPRECATED property. Use the GET /connections/:id/clients endpoint to get the ids of the clients for which the connection is enabled */
    enabled_clients?: string[];
    /** True if the connection is domain level */
    is_domain_connection?: boolean;
    /** Enables showing a button for the connection in the login page (new experience only). If false, it will be usable only by HRD. */
    show_as_button?: boolean;
    metadata?: Management.ConnectionsMetadata;
    authentication?: Management.ConnectionAuthenticationPurpose;
    connected_accounts?: Management.ConnectionConnectedAccountsPurpose;
}

export interface CreateCustomDomainResponseContent {
    /** ID of the custom domain. */
    custom_domain_id: string;
    /** Domain name. */
    domain: string;
    /** Whether this is a primary domain (true) or not (false). */
    primary: boolean;
    status: Management.CustomDomainStatusFilterEnum;
    type: Management.CustomDomainTypeEnum;
    verification: Management.DomainVerification;
    /** The HTTP header to fetch the client's IP address */
    custom_client_ip_header?: string | null;
    /** The TLS version policy */
    tls_policy?: string;
    certificate?: Management.DomainCertificate;
}

export interface CreateEmailProviderResponseContent {
    /** Name of the email provider. Can be `mailgun`, `mandrill`, `sendgrid`, `ses`, `sparkpost`, `smtp`, `azure_cs`, `ms365`, or `custom`. */
    name?: string;
    /** Whether the provider is enabled (true) or disabled (false). */
    enabled?: boolean;
    /** Email address to use as "from" when no other address specified. */
    default_from_address?: string;
    credentials?: Management.EmailProviderCredentials;
    settings?: Management.EmailProviderSettings;
}

export interface CreateEmailTemplateResponseContent {
    template: Management.EmailTemplateNameEnum;
    /** Body of the email template. */
    body?: string | null;
    /** Senders `from` email address. */
    from?: string | null;
    /** URL to redirect the user to after a successful action. */
    resultUrl?: string | null;
    /** Subject line of the email. */
    subject?: string | null;
    /** Syntax of the template body. */
    syntax?: string | null;
    /** Lifetime in seconds that the link within the email will be valid for. */
    urlLifetimeInSeconds?: number | null;
    /** Whether the `reset_email` and `verify_email` templates should include the user's email address as the `email` parameter in the returnUrl (true) or whether no email address should be included in the redirect (false). Defaults to true. */
    includeEmailInRedirect?: boolean;
    /** Whether the template is enabled (true) or disabled (false). */
    enabled?: boolean | null;
}

export interface CreateEncryptionKeyPublicWrappingResponseContent {
    /** Public wrapping key in PEM format */
    public_key: string;
    algorithm: Management.EncryptionKeyPublicWrappingAlgorithm;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Encryption key
 */
export interface CreateEncryptionKeyResponseContent {
    /** Key ID */
    kid: string;
    type: Management.EncryptionKeyType;
    state: Management.EncryptionKeyState;
    /** Key creation timestamp */
    created_at: string;
    /** Key update timestamp */
    updated_at: string;
    /** ID of parent wrapping key */
    parent_kid: string;
    /** Public key in PEM format */
    public_key?: string;
}

/** Type of the encryption key to be created. */
export const CreateEncryptionKeyType = {
    CustomerProvidedRootKey: "customer-provided-root-key",
    TenantEncryptionKey: "tenant-encryption-key",
} as const;
export type CreateEncryptionKeyType = (typeof CreateEncryptionKeyType)[keyof typeof CreateEncryptionKeyType];

export interface CreateEventStreamActionRequestContent {
    /** Name of the event stream. */
    name?: string;
    /** List of event types subscribed to in this stream. */
    subscriptions?: Management.EventStreamSubscription[];
    destination: Management.EventStreamActionDestination;
    status?: Management.EventStreamStatusEnum;
}

export interface CreateEventStreamEventBridgeRequestContent {
    /** Name of the event stream. */
    name?: string;
    /** List of event types subscribed to in this stream. */
    subscriptions?: Management.EventStreamSubscription[];
    destination: Management.EventStreamEventBridgeDestination;
    status?: Management.EventStreamStatusEnum;
}

export interface CreateEventStreamRedeliveryResponseContent {
    /** An RFC-3339 date-time for redelivery start, inclusive. Does not allow sub-second precision. */
    date_from?: string;
    /** An RFC-3339 date-time for redelivery end, exclusive. Does not allow sub-second precision. */
    date_to?: string;
    /** Filter by status */
    statuses?: Management.EventStreamDeliveryStatusEnum[];
    /** Filter by event type */
    event_types?: Management.EventStreamEventTypeEnum[];
}

export type CreateEventStreamResponseContent =
    | Management.EventStreamWebhookResponseContent
    | Management.EventStreamEventBridgeResponseContent
    | Management.EventStreamActionResponseContent;

/**
 * Metadata about a specific attempt to deliver an event
 */
export interface CreateEventStreamTestEventResponseContent {
    /** Unique identifier for the delivery */
    id: string;
    /** Unique identifier for the event stream. */
    event_stream_id: string;
    status: Management.EventStreamDeliveryStatusEnum;
    event_type: Management.EventStreamDeliveryEventTypeEnum;
    /** Results of delivery attempts */
    attempts: Management.EventStreamDeliveryAttempt[];
    event?: Management.EventStreamCloudEvent;
}

export interface CreateEventStreamWebHookRequestContent {
    /** Name of the event stream. */
    name?: string;
    /** List of event types subscribed to in this stream. */
    subscriptions?: Management.EventStreamSubscription[];
    destination: Management.EventStreamWebhookDestination;
    status?: Management.EventStreamStatusEnum;
}

export interface CreateExportUsersFields {
    /** Name of the field in the profile. */
    name: string;
    /** Title of the column in the exported CSV. */
    export_as?: string;
}

export interface CreateExportUsersResponseContent {
    /** Status of this job. */
    status: string;
    /** Type of job this is. */
    type: string;
    /** When this job was created. */
    created_at?: string;
    /** ID of this job. */
    id: string;
    /** connection_id of the connection from which users will be exported. */
    connection_id?: string;
    format?: Management.JobFileFormatEnum;
    /** Limit the number of records. */
    limit?: number;
    /** List of fields to be included in the CSV. Defaults to a predefined set of fields. */
    fields?: Management.CreateExportUsersFields[];
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface CreateFlowResponseContent {
    id: string;
    name: string;
    actions?: Management.FlowAction[];
    created_at: string;
    updated_at: string;
    executed_at?: string;
}

export type CreateFlowsVaultConnectionActivecampaign =
    | Management.CreateFlowsVaultConnectionActivecampaignApiKey
    | Management.CreateFlowsVaultConnectionActivecampaignUninitialized;

export interface CreateFlowsVaultConnectionActivecampaignApiKey {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdActivecampaignEnum;
    setup: Management.FlowsVaultConnectioSetupApiKeyWithBaseUrl;
}

export interface CreateFlowsVaultConnectionActivecampaignUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdActivecampaignEnum;
}

export type CreateFlowsVaultConnectionAirtable =
    | Management.CreateFlowsVaultConnectionAirtableApiKey
    | Management.CreateFlowsVaultConnectionAirtableUninitialized;

export interface CreateFlowsVaultConnectionAirtableApiKey {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdAirtableEnum;
    setup: Management.FlowsVaultConnectioSetupApiKey;
}

export interface CreateFlowsVaultConnectionAirtableUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdAirtableEnum;
}

export type CreateFlowsVaultConnectionAuth0 =
    | Management.CreateFlowsVaultConnectionAuth0OauthApp
    | Management.CreateFlowsVaultConnectionAuth0Uninitialized;

export interface CreateFlowsVaultConnectionAuth0OauthApp {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdAuth0Enum;
    setup: Management.FlowsVaultConnectioSetupOauthApp;
}

export interface CreateFlowsVaultConnectionAuth0Uninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdAuth0Enum;
}

export type CreateFlowsVaultConnectionBigquery =
    | Management.CreateFlowsVaultConnectionBigqueryJwt
    | Management.CreateFlowsVaultConnectionBigqueryUninitialized;

export interface CreateFlowsVaultConnectionBigqueryJwt {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdBigqueryEnum;
    setup: Management.FlowsVaultConnectioSetupBigqueryOauthJwt;
}

export interface CreateFlowsVaultConnectionBigqueryUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdBigqueryEnum;
}

export type CreateFlowsVaultConnectionClearbit =
    | Management.CreateFlowsVaultConnectionClearbitApiKey
    | Management.CreateFlowsVaultConnectionClearbitUninitialized;

export interface CreateFlowsVaultConnectionClearbitApiKey {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdClearbitEnum;
    setup: Management.FlowsVaultConnectioSetupSecretApiKey;
}

export interface CreateFlowsVaultConnectionClearbitUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdClearbitEnum;
}

export type CreateFlowsVaultConnectionDocusign =
    | Management.CreateFlowsVaultConnectionDocusignOauthCode
    | Management.CreateFlowsVaultConnectionDocusignUninitialized;

export interface CreateFlowsVaultConnectionDocusignOauthCode {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdDocusignEnum;
    setup: Management.FlowsVaultConnectioSetupOauthCode;
}

export interface CreateFlowsVaultConnectionDocusignUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdDocusignEnum;
}

export type CreateFlowsVaultConnectionGoogleSheets =
    | Management.CreateFlowsVaultConnectionGoogleSheetsOauthCode
    | Management.CreateFlowsVaultConnectionGoogleSheetsUninitialized;

export interface CreateFlowsVaultConnectionGoogleSheetsOauthCode {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdGoogleSheetsEnum;
    setup: Management.FlowsVaultConnectioSetupOauthCode;
}

export interface CreateFlowsVaultConnectionGoogleSheetsUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdGoogleSheetsEnum;
}

export type CreateFlowsVaultConnectionHttp =
    | Management.CreateFlowsVaultConnectionHttpBearer
    | Management.CreateFlowsVaultConnectionHttpUninitialized;

export interface CreateFlowsVaultConnectionHttpBearer {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdHttpEnum;
    setup: Management.FlowsVaultConnectioSetupHttpBearer;
}

export interface CreateFlowsVaultConnectionHttpUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdHttpEnum;
}

export type CreateFlowsVaultConnectionHubspot =
    | Management.CreateFlowsVaultConnectionHubspotApiKey
    | Management.CreateFlowsVaultConnectionHubspotOauthCode
    | Management.CreateFlowsVaultConnectionHubspotUninitialized;

export interface CreateFlowsVaultConnectionHubspotApiKey {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdHubspotEnum;
    setup: Management.FlowsVaultConnectioSetupApiKey;
}

export interface CreateFlowsVaultConnectionHubspotOauthCode {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdHubspotEnum;
    setup: Management.FlowsVaultConnectioSetupOauthCode;
}

export interface CreateFlowsVaultConnectionHubspotUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdHubspotEnum;
}

export type CreateFlowsVaultConnectionJwt =
    | Management.CreateFlowsVaultConnectionJwtJwt
    | Management.CreateFlowsVaultConnectionJwtUninitialized;

export interface CreateFlowsVaultConnectionJwtJwt {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdJwtEnum;
    setup: Management.FlowsVaultConnectioSetupJwt;
}

export interface CreateFlowsVaultConnectionJwtUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdJwtEnum;
}

export type CreateFlowsVaultConnectionMailchimp =
    | Management.CreateFlowsVaultConnectionMailchimpApiKey
    | Management.CreateFlowsVaultConnectionMailchimpOauthCode
    | Management.CreateFlowsVaultConnectionMailchimpUninitialized;

export interface CreateFlowsVaultConnectionMailchimpApiKey {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdMailchimpEnum;
    setup: Management.FlowsVaultConnectioSetupSecretApiKey;
}

export interface CreateFlowsVaultConnectionMailchimpOauthCode {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdMailchimpEnum;
    setup: Management.FlowsVaultConnectioSetupOauthCode;
}

export interface CreateFlowsVaultConnectionMailchimpUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdMailchimpEnum;
}

export type CreateFlowsVaultConnectionMailjet =
    | Management.CreateFlowsVaultConnectionMailjetApiKey
    | Management.CreateFlowsVaultConnectionMailjetUninitialized;

export interface CreateFlowsVaultConnectionMailjetApiKey {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdMailjetEnum;
    setup: Management.FlowsVaultConnectioSetupMailjetApiKey;
}

export interface CreateFlowsVaultConnectionMailjetUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdMailjetEnum;
}

export type CreateFlowsVaultConnectionPipedrive =
    | Management.CreateFlowsVaultConnectionPipedriveToken
    | Management.CreateFlowsVaultConnectionPipedriveOauthCode
    | Management.CreateFlowsVaultConnectionPipedriveUninitialized;

export interface CreateFlowsVaultConnectionPipedriveOauthCode {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdPipedriveEnum;
    setup: Management.FlowsVaultConnectioSetupOauthCode;
}

export interface CreateFlowsVaultConnectionPipedriveToken {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdPipedriveEnum;
    setup: Management.FlowsVaultConnectioSetupToken;
}

export interface CreateFlowsVaultConnectionPipedriveUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdPipedriveEnum;
}

export type CreateFlowsVaultConnectionRequestContent =
    | Management.CreateFlowsVaultConnectionActivecampaign
    | Management.CreateFlowsVaultConnectionAirtable
    | Management.CreateFlowsVaultConnectionAuth0
    | Management.CreateFlowsVaultConnectionBigquery
    | Management.CreateFlowsVaultConnectionClearbit
    | Management.CreateFlowsVaultConnectionDocusign
    | Management.CreateFlowsVaultConnectionGoogleSheets
    | Management.CreateFlowsVaultConnectionHttp
    | Management.CreateFlowsVaultConnectionHubspot
    | Management.CreateFlowsVaultConnectionJwt
    | Management.CreateFlowsVaultConnectionMailchimp
    | Management.CreateFlowsVaultConnectionMailjet
    | Management.CreateFlowsVaultConnectionPipedrive
    | Management.CreateFlowsVaultConnectionSalesforce
    | Management.CreateFlowsVaultConnectionSendgrid
    | Management.CreateFlowsVaultConnectionSlack
    | Management.CreateFlowsVaultConnectionStripe
    | Management.CreateFlowsVaultConnectionTelegram
    | Management.CreateFlowsVaultConnectionTwilio
    | Management.CreateFlowsVaultConnectionWhatsapp
    | Management.CreateFlowsVaultConnectionZapier;

export interface CreateFlowsVaultConnectionResponseContent {
    /** Flows Vault Connection identifier. */
    id: string;
    /** Flows Vault Connection app identifier. */
    app_id: string;
    /** Flows Vault Connection environment. */
    environment?: string;
    /** Flows Vault Connection name. */
    name: string;
    /** Flows Vault Connection custom account name. */
    account_name?: string;
    /** Whether the Flows Vault Connection is configured. */
    ready: boolean;
    /** The ISO 8601 formatted date when this Flows Vault Connection was created. */
    created_at: string;
    /** The ISO 8601 formatted date when this Flows Vault Connection was updated. */
    updated_at: string;
    /** The ISO 8601 formatted date when this Flows Vault Connection was refreshed. */
    refreshed_at?: string;
    fingerprint: string;
}

export type CreateFlowsVaultConnectionSalesforce =
    | Management.CreateFlowsVaultConnectionSalesforceOauthCode
    | Management.CreateFlowsVaultConnectionSalesforceUninitialized;

export interface CreateFlowsVaultConnectionSalesforceOauthCode {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdSalesforceEnum;
    setup: Management.FlowsVaultConnectioSetupOauthCode;
}

export interface CreateFlowsVaultConnectionSalesforceUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdSalesforceEnum;
}

export type CreateFlowsVaultConnectionSendgrid =
    | Management.CreateFlowsVaultConnectionSendgridApiKey
    | Management.CreateFlowsVaultConnectionSendgridUninitialized;

export interface CreateFlowsVaultConnectionSendgridApiKey {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdSendgridEnum;
    setup: Management.FlowsVaultConnectioSetupApiKey;
}

export interface CreateFlowsVaultConnectionSendgridUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdSendgridEnum;
}

export type CreateFlowsVaultConnectionSlack =
    | Management.CreateFlowsVaultConnectionSlackWebhook
    | Management.CreateFlowsVaultConnectionSlackOauthCode
    | Management.CreateFlowsVaultConnectionSlackUninitialized;

export interface CreateFlowsVaultConnectionSlackOauthCode {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdSlackEnum;
    setup: Management.FlowsVaultConnectioSetupOauthCode;
}

export interface CreateFlowsVaultConnectionSlackUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdSlackEnum;
}

export interface CreateFlowsVaultConnectionSlackWebhook {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdSlackEnum;
    setup: Management.FlowsVaultConnectioSetupWebhook;
}

export type CreateFlowsVaultConnectionStripe =
    | Management.CreateFlowsVaultConnectionStripeKeyPair
    | Management.CreateFlowsVaultConnectionStripeOauthCode
    | Management.CreateFlowsVaultConnectionStripeUninitialized;

export interface CreateFlowsVaultConnectionStripeKeyPair {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdStripeEnum;
    setup: Management.FlowsVaultConnectioSetupStripeKeyPair;
}

export interface CreateFlowsVaultConnectionStripeOauthCode {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdStripeEnum;
    setup: Management.FlowsVaultConnectioSetupOauthCode;
}

export interface CreateFlowsVaultConnectionStripeUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdStripeEnum;
}

export type CreateFlowsVaultConnectionTelegram =
    | Management.CreateFlowsVaultConnectionTelegramToken
    | Management.CreateFlowsVaultConnectionTelegramUninitialized;

export interface CreateFlowsVaultConnectionTelegramToken {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdTelegramEnum;
    setup: Management.FlowsVaultConnectioSetupToken;
}

export interface CreateFlowsVaultConnectionTelegramUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdTelegramEnum;
}

export type CreateFlowsVaultConnectionTwilio =
    | Management.CreateFlowsVaultConnectionTwilioApiKey
    | Management.CreateFlowsVaultConnectionTwilioUninitialized;

export interface CreateFlowsVaultConnectionTwilioApiKey {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdTwilioEnum;
    setup: Management.FlowsVaultConnectioSetupTwilioApiKey;
}

export interface CreateFlowsVaultConnectionTwilioUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdTwilioEnum;
}

export type CreateFlowsVaultConnectionWhatsapp =
    | Management.CreateFlowsVaultConnectionWhatsappToken
    | Management.CreateFlowsVaultConnectionWhatsappUninitialized;

export interface CreateFlowsVaultConnectionWhatsappToken {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdWhatsappEnum;
    setup: Management.FlowsVaultConnectioSetupToken;
}

export interface CreateFlowsVaultConnectionWhatsappUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdWhatsappEnum;
}

export type CreateFlowsVaultConnectionZapier =
    | Management.CreateFlowsVaultConnectionZapierWebhook
    | Management.CreateFlowsVaultConnectionZapierUninitialized;

export interface CreateFlowsVaultConnectionZapierUninitialized {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdZapierEnum;
}

export interface CreateFlowsVaultConnectionZapierWebhook {
    /** Flows Vault Connection name. */
    name: string;
    app_id: Management.FlowsVaultConnectionAppIdZapierEnum;
    setup: Management.FlowsVaultConnectioSetupWebhook;
}

export interface CreateFormResponseContent {
    id: string;
    name: string;
    messages?: Management.FormMessages;
    languages?: Management.FormLanguages;
    translations?: Management.FormTranslations;
    nodes?: Management.FormNodeList;
    start?: Management.FormStartNode;
    ending?: Management.FormEndingNode;
    style?: Management.FormStyle;
    created_at: string;
    updated_at: string;
    embedded_at?: string;
    submitted_at?: string;
}

export interface CreateGuardianEnrollmentTicketResponseContent {
    /** The ticket_id used to identify the enrollment */
    ticket_id?: string;
    /** The url you can use to start enrollment */
    ticket_url?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface CreateHookResponseContent {
    /** Trigger ID */
    triggerId?: string;
    /** ID of this hook. */
    id?: string;
    /** Name of this hook. */
    name?: string;
    /** Whether this hook will be executed (true) or ignored (false). */
    enabled?: boolean;
    /** Code to be executed when this hook runs. */
    script?: string;
    dependencies?: Management.HookDependencies;
}

/**
 * Hashmap of key-value pairs where the value must be a string.
 */
export type CreateHookSecretRequestContent = Record<string, string>;

export interface CreateImportUsersResponseContent {
    /** Status of this job. */
    status: string;
    /** Type of job this is. */
    type: string;
    /** When this job was created. */
    created_at: string;
    /** ID of this job. */
    id: string;
    /** connection_id of the connection to which users will be imported. */
    connection_id: string;
    /** Customer-defined ID. */
    external_id?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface CreateLogStreamDatadogRequestBody {
    /** log stream name */
    name?: string;
    type: Management.LogStreamDatadogEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink: Management.LogStreamDatadogSink;
    /** The optional datetime (ISO 8601) to start streaming logs from */
    startFrom?: string;
}

export interface CreateLogStreamEventBridgeRequestBody {
    /** log stream name */
    name?: string;
    type: Management.LogStreamEventBridgeEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink: Management.LogStreamEventBridgeSink;
    /** The optional datetime (ISO 8601) to start streaming logs from */
    startFrom?: string;
}

export interface CreateLogStreamEventGridRequestBody {
    /** log stream name */
    name?: string;
    type: Management.LogStreamEventGridEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink: Management.LogStreamEventGridSink;
    /** The optional datetime (ISO 8601) to start streaming logs from */
    startFrom?: string;
}

export interface CreateLogStreamHttpRequestBody {
    /** log stream name */
    name?: string;
    type: Management.LogStreamHttpEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink: Management.LogStreamHttpSink;
    /** The optional datetime (ISO 8601) to start streaming logs from */
    startFrom?: string;
}

export interface CreateLogStreamMixpanelRequestBody {
    /** log stream name */
    name?: string;
    type: Management.LogStreamMixpanelEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink: Management.LogStreamMixpanelSink;
    /** The optional datetime (ISO 8601) to start streaming logs from */
    startFrom?: string;
}

export type CreateLogStreamRequestContent =
    | Management.CreateLogStreamHttpRequestBody
    | Management.CreateLogStreamEventBridgeRequestBody
    | Management.CreateLogStreamEventGridRequestBody
    | Management.CreateLogStreamDatadogRequestBody
    | Management.CreateLogStreamSplunkRequestBody
    | Management.CreateLogStreamSumoRequestBody
    | Management.CreateLogStreamSegmentRequestBody
    | Management.CreateLogStreamMixpanelRequestBody;

export type CreateLogStreamResponseContent =
    | Management.LogStreamHttpResponseSchema
    | Management.LogStreamEventBridgeResponseSchema
    | Management.LogStreamEventGridResponseSchema
    | Management.LogStreamDatadogResponseSchema
    | Management.LogStreamSplunkResponseSchema
    | Management.LogStreamSumoResponseSchema
    | Management.LogStreamSegmentResponseSchema
    | Management.LogStreamMixpanelResponseSchema;

export interface CreateLogStreamSegmentRequestBody {
    /** log stream name */
    name?: string;
    type: Management.LogStreamSegmentEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink: Management.LogStreamSegmentSinkWriteKey;
    /** The optional datetime (ISO 8601) to start streaming logs from */
    startFrom?: string;
}

export interface CreateLogStreamSplunkRequestBody {
    /** log stream name */
    name?: string;
    type: Management.LogStreamSplunkEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink: Management.LogStreamSplunkSink;
    /** The optional datetime (ISO 8601) to start streaming logs from */
    startFrom?: string;
}

export interface CreateLogStreamSumoRequestBody {
    /** log stream name */
    name?: string;
    type: Management.LogStreamSumoEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink: Management.LogStreamSumoSink;
    /** The optional datetime (ISO 8601) to start streaming logs from */
    startFrom?: string;
}

export interface CreateOrganizationDiscoveryDomainResponseContent {
    /** Organization discovery domain identifier. */
    id: string;
    /** The domain name to associate with the organization e.g. acme.com. */
    domain: string;
    status: Management.OrganizationDiscoveryDomainStatus;
    /** A unique token generated for the discovery domain. This must be placed in a DNS TXT record at the location specified by the verification_host field to prove domain ownership. */
    verification_txt: string;
    /** The full domain where the TXT record should be added. */
    verification_host: string;
}

export interface CreateOrganizationInvitationResponseContent {
    /** The id of the user invitation. */
    id?: string;
    /** Organization identifier. */
    organization_id?: string;
    inviter?: Management.OrganizationInvitationInviter;
    invitee?: Management.OrganizationInvitationInvitee;
    /** The invitation url to be send to the invitee. */
    invitation_url?: string;
    /** The ISO 8601 formatted timestamp representing the creation time of the invitation. */
    created_at?: string;
    /** The ISO 8601 formatted timestamp representing the expiration time of the invitation. */
    expires_at?: string;
    /** Auth0 client ID. Used to resolve the application's login initiation endpoint. */
    client_id?: string;
    /** The id of the connection to force invitee to authenticate with. */
    connection_id?: string;
    app_metadata?: Management.AppMetadata;
    user_metadata?: Management.UserMetadata;
    /** List of roles IDs to associated with the user. */
    roles?: string[];
    /** The id of the invitation ticket */
    ticket_id?: string;
}

export interface CreateOrganizationResponseContent {
    /** Organization identifier. */
    id?: string;
    /** The name of this organization. */
    name?: string;
    /** Friendly name of this organization. */
    display_name?: string;
    branding?: Management.OrganizationBranding;
    metadata?: Management.OrganizationMetadata;
    token_quota?: Management.TokenQuota;
    enabled_connections?: Management.OrganizationEnabledConnection[];
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface CreatePhoneProviderSendTestResponseContent {
    /** The status code of the operation. */
    code?: number;
    /** The description of the operation status. */
    message?: string;
}

export interface CreatePhoneTemplateResponseContent {
    id: string;
    channel?: string;
    customizable?: boolean;
    tenant?: string;
    content: Management.PhoneTemplateContent;
    type: Management.PhoneTemplateNotificationTypeEnum;
    /** Whether the template is enabled (false) or disabled (true). */
    disabled: boolean;
}

export interface CreatePhoneTemplateTestNotificationResponseContent {
    message: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface CreatePublicKeyDeviceCredentialResponseContent {
    /** The credential's identifier */
    id: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface CreateResourceServerResponseContent {
    /** ID of the API (resource server). */
    id?: string;
    /** Friendly name for this resource server. Can not contain `<` or `>` characters. */
    name?: string;
    /** Whether this is an Auth0 system API (true) or a custom API (false). */
    is_system?: boolean;
    /** Unique identifier for the API used as the audience parameter on authorization calls. Can not be changed once set. */
    identifier?: string;
    /** List of permissions (scopes) that this API uses. */
    scopes?: Management.ResourceServerScope[];
    signing_alg?: Management.SigningAlgorithmEnum;
    /** Secret used to sign tokens when using symmetric algorithms (HS256). */
    signing_secret?: string;
    /** Whether refresh tokens can be issued for this API (true) or not (false). */
    allow_offline_access?: boolean;
    /** Whether to skip user consent for applications flagged as first party (true) or not (false). */
    skip_consent_for_verifiable_first_party_clients?: boolean;
    /** Expiration value (in seconds) for access tokens issued for this API from the token endpoint. */
    token_lifetime?: number;
    /** Expiration value (in seconds) for access tokens issued for this API via Implicit or Hybrid Flows. Cannot be greater than the `token_lifetime` value. */
    token_lifetime_for_web?: number;
    /** Whether authorization polices are enforced (true) or unenforced (false). */
    enforce_policies?: boolean;
    token_dialect?: Management.ResourceServerTokenDialectResponseEnum;
    token_encryption?: Management.ResourceServerTokenEncryption | null;
    consent_policy?: (Management.ResourceServerConsentPolicyEnum | undefined) | null;
    authorization_details?: unknown[];
    proof_of_possession?: Management.ResourceServerProofOfPossession | null;
    subject_type_authorization?: Management.ResourceServerSubjectTypeAuthorization;
    /** The client ID of the client that this resource server is linked to */
    client_id?: string;
}

export interface CreateRoleResponseContent {
    /** ID for this role. */
    id?: string;
    /** Name of this role. */
    name?: string;
    /** Description of this role. */
    description?: string;
}

export interface CreateRuleResponseContent {
    /** Name of this rule. */
    name?: string;
    /** ID of this rule. */
    id?: string;
    /** Whether the rule is enabled (true), or disabled (false). */
    enabled?: boolean;
    /** Code to be executed when this rule runs. */
    script?: string;
    /** Order that this rule should execute in relative to other rules. Lower-valued rules execute first. */
    order?: number;
    /** Execution stage of this rule. Can be `login_success`, `login_failure`, or `pre_authorize`. */
    stage?: string;
}

export interface CreateScimConfigurationRequestContent {
    /** User ID attribute for generating unique user ids */
    user_id_attribute?: string;
    /** The mapping between auth0 and SCIM */
    mapping?: Management.ScimMappingItem[];
}

export interface CreateScimConfigurationResponseContent {
    /** The connection's identifier */
    connection_id?: string;
    /** The connection's identifier */
    connection_name?: string;
    /** The connection's strategy */
    strategy?: string;
    /** The tenant's name */
    tenant_name?: string;
    /** User ID attribute for generating unique user ids */
    user_id_attribute?: string;
    /** The mapping between auth0 and SCIM */
    mapping?: Management.ScimMappingItem[];
    /** The Date Time Scim Configuration was created */
    created_at?: string;
    /** The Date Time Scim Configuration was last updated */
    updated_on?: string;
}

export interface CreateScimTokenResponseContent {
    /** The token's identifier */
    token_id?: string;
    /** The scim client's token */
    token?: string;
    /** The scopes of the scim token */
    scopes?: string[];
    /** The token's created at timestamp */
    created_at?: string;
    /** The token's valid until at timestamp */
    valid_until?: string;
}

export interface CreateSelfServiceProfileResponseContent {
    /** The unique ID of the self-service Profile. */
    id?: string;
    /** The name of the self-service Profile. */
    name?: string;
    /** The description of the self-service Profile. */
    description?: string;
    /** List of attributes to be mapped that will be shown to the user during the SS-SSO flow. */
    user_attributes?: Management.SelfServiceProfileUserAttribute[];
    /** The time when this self-service Profile was created. */
    created_at?: string;
    /** The time when this self-service Profile was updated. */
    updated_at?: string;
    branding?: Management.SelfServiceProfileBrandingProperties;
    /** List of IdP strategies that will be shown to users during the Self-Service SSO flow. Possible values: [`oidc`, `samlp`, `waad`, `google-apps`, `adfs`, `okta`, `keycloak-samlp`, `pingfederate`] */
    allowed_strategies?: Management.SelfServiceProfileAllowedStrategyEnum[];
    /** ID of the user-attribute-profile to associate with this self-service profile. */
    user_attribute_profile_id?: string;
}

export interface CreateSelfServiceProfileSsoTicketResponseContent {
    /** The URL for the created ticket. */
    ticket?: string;
}

export interface CreateTokenExchangeProfileResponseContent {
    /** The unique ID of the token exchange profile. */
    id?: string;
    /** Friendly name of this profile. */
    name?: string;
    /** Subject token type for this profile. When receiving a token exchange request on the Authentication API, the corresponding token exchange profile with a matching subject_token_type will be executed. This must be a URI. */
    subject_token_type?: string;
    /** The ID of the Custom Token Exchange action to execute for this profile, in order to validate the subject_token. The action must use the custom-token-exchange trigger. */
    action_id?: string;
    type?: Management.TokenExchangeProfileTypeEnum;
    /** The time when this profile was created. */
    created_at?: string;
    /** The time when this profile was updated. */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface CreateTokenQuota {
    client_credentials: Management.TokenQuotaClientCredentials;
}

export interface CreateUserAttributeProfileResponseContent {
    id?: Management.UserAttributeProfileId;
    name?: Management.UserAttributeProfileName;
    user_id?: Management.UserAttributeProfileUserId;
    user_attributes?: Management.UserAttributeProfileUserAttributes;
}

/**
 * The successfully created authentication method.
 */
export interface CreateUserAuthenticationMethodResponseContent {
    /** The ID of the newly created authentication method (automatically generated by the application) */
    id?: string;
    type: Management.CreatedUserAuthenticationMethodTypeEnum;
    /** A human-readable label to identify the authentication method. */
    name?: string;
    /** Base32 encoded secret for TOTP generation */
    totp_secret?: string;
    /** Applies to phone authentication methods only. The destination phone number used to send verification codes via text and voice. */
    phone_number?: string;
    /** Applies to email authentication methods only. The email address used to send verification messages. */
    email?: string;
    authentication_methods?: Management.UserAuthenticationMethodProperties[];
    preferred_authentication_method?: Management.PreferredAuthenticationMethodEnum;
    /** Applies to webauthn authenticators only. The id of the credential. */
    key_id?: string;
    /** Applies to webauthn authenticators only. The public key. */
    public_key?: string;
    /** Applies to passkeys only. Authenticator Attestation Globally Unique Identifier. */
    aaguid?: string;
    /** Applies to webauthn authenticators only. The relying party identifier. */
    relying_party_identifier?: string;
    /** Authentication method creation date */
    created_at?: string;
}

export interface CreateUserResponseContent {
    /** ID of the user which can be used when interacting with other APIs. */
    user_id?: string;
    /** Email address of this user. */
    email?: string;
    /** Whether this email address is verified (true) or unverified (false). */
    email_verified?: boolean;
    /** Username of this user. */
    username?: string;
    /** Phone number for this user. Follows the <a href="https://en.wikipedia.org/wiki/E.164">E.164 recommendation</a>. */
    phone_number?: string;
    /** Whether this phone number has been verified (true) or not (false). */
    phone_verified?: boolean;
    created_at?: Management.UserDateSchema;
    updated_at?: Management.UserDateSchema;
    /** Array of user identity objects when accounts are linked. */
    identities?: Management.UserIdentitySchema[];
    app_metadata?: Management.UserAppMetadataSchema;
    user_metadata?: Management.UserMetadataSchema;
    /** URL to picture, photo, or avatar of this user. */
    picture?: string;
    /** Name of this user. */
    name?: string;
    /** Preferred nickname or alias of this user. */
    nickname?: string;
    /** List of multi-factor authentication providers with which this user has enrolled. */
    multifactor?: string[];
    /** Last IP address from which this user logged in. */
    last_ip?: string;
    last_login?: Management.UserDateSchema;
    /** Total number of logins this user has performed. */
    logins_count?: number;
    /** Whether this user was blocked by an administrator (true) or is not (false). */
    blocked?: boolean;
    /** Given name/first name/forename of this user. */
    given_name?: string;
    /** Family name/last name/surname of this user. */
    family_name?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface CreateVerifiableCredentialTemplateResponseContent {
    /** The id of the template. */
    id?: string;
    /** The name of the template. */
    name?: string;
    /** The type of the template. */
    type?: string;
    /** The dialect of the template. */
    dialect?: string;
    presentation?: Management.MdlPresentationRequest;
    /** The custom certificate authority. */
    custom_certificate_authority?: string;
    /** The well-known trusted issuers, comma separated. */
    well_known_trusted_issuers?: string;
    /** The date and time the template was created. */
    created_at?: string;
    /** The date and time the template was created. */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface CreateVerificationEmailResponseContent {
    /** Status of this job. */
    status: string;
    /** Type of job this is. */
    type: string;
    /** When this job was created. */
    created_at?: string;
    /** ID of this job. */
    id: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export const CreatedAuthenticationMethodTypeEnum = {
    Phone: "phone",
    Email: "email",
    Totp: "totp",
    WebauthnRoaming: "webauthn-roaming",
} as const;
export type CreatedAuthenticationMethodTypeEnum =
    (typeof CreatedAuthenticationMethodTypeEnum)[keyof typeof CreatedAuthenticationMethodTypeEnum];

export const CreatedUserAuthenticationMethodTypeEnum = {
    Phone: "phone",
    Email: "email",
    Totp: "totp",
    WebauthnRoaming: "webauthn-roaming",
    Passkey: "passkey",
} as const;
export type CreatedUserAuthenticationMethodTypeEnum =
    (typeof CreatedUserAuthenticationMethodTypeEnum)[keyof typeof CreatedUserAuthenticationMethodTypeEnum];

export interface CredentialId {
    /** Credential ID */
    id: string;
}

export interface CustomDomain {
    /** ID of the custom domain. */
    custom_domain_id: string;
    /** Domain name. */
    domain: string;
    /** Whether this is a primary domain (true) or not (false). */
    primary: boolean;
    status: Management.CustomDomainStatusFilterEnum;
    type: Management.CustomDomainTypeEnum;
    /** Intermediate address. */
    origin_domain_name?: string;
    verification?: Management.DomainVerification;
    /** The HTTP header to fetch the client's IP address */
    custom_client_ip_header?: string | null;
    /** The TLS version policy */
    tls_policy?: string;
    certificate?: Management.DomainCertificate;
}

export type CustomDomainCustomClientIpHeader = (Management.CustomDomainCustomClientIpHeaderEnum | null) | undefined;

/** The HTTP header to fetch the client's IP address */
export const CustomDomainCustomClientIpHeaderEnum = {
    TrueClientIp: "true-client-ip",
    CfConnectingIp: "cf-connecting-ip",
    XForwardedFor: "x-forwarded-for",
    XAzureClientip: "x-azure-clientip",
    Empty: "",
} as const;
export type CustomDomainCustomClientIpHeaderEnum =
    (typeof CustomDomainCustomClientIpHeaderEnum)[keyof typeof CustomDomainCustomClientIpHeaderEnum];

/** Custom domain provisioning type. Must be `auth0_managed_certs` or `self_managed_certs`. */
export const CustomDomainProvisioningTypeEnum = {
    Auth0ManagedCerts: "auth0_managed_certs",
    SelfManagedCerts: "self_managed_certs",
} as const;
export type CustomDomainProvisioningTypeEnum =
    (typeof CustomDomainProvisioningTypeEnum)[keyof typeof CustomDomainProvisioningTypeEnum];

/** Custom domain configuration status. Can be `failed`, `pending_verification`, or `ready`. */
export const CustomDomainStatusFilterEnum = {
    PendingVerification: "pending_verification",
    Ready: "ready",
    Failed: "failed",
} as const;
export type CustomDomainStatusFilterEnum =
    (typeof CustomDomainStatusFilterEnum)[keyof typeof CustomDomainStatusFilterEnum];

/**
 * Custom domain TLS policy. Must be `recommended`, includes TLS 1.2.
 */
export type CustomDomainTlsPolicyEnum = "recommended";

/** Custom domain provisioning type. Can be `auth0_managed_certs` or `self_managed_certs`. */
export const CustomDomainTypeEnum = {
    Auth0ManagedCerts: "auth0_managed_certs",
    SelfManagedCerts: "self_managed_certs",
} as const;
export type CustomDomainTypeEnum = (typeof CustomDomainTypeEnum)[keyof typeof CustomDomainTypeEnum];

/**
 * Custom domain verification method. Must be `txt`.
 */
export type CustomDomainVerificationMethodEnum = "txt";

export interface CustomProviderConfiguration {
    delivery_methods: Management.CustomProviderDeliveryMethodEnum[];
}

export interface CustomProviderCredentials {}

export const CustomProviderDeliveryMethodEnum = {
    Text: "text",
    Voice: "voice",
} as const;
export type CustomProviderDeliveryMethodEnum =
    (typeof CustomProviderDeliveryMethodEnum)[keyof typeof CustomProviderDeliveryMethodEnum];

/** Key algorithm */
export const CustomSigningKeyAlgorithmEnum = {
    Rs256: "RS256",
    Rs384: "RS384",
    Rs512: "RS512",
    Es256: "ES256",
    Es384: "ES384",
    Es512: "ES512",
    Ps256: "PS256",
    Ps384: "PS384",
    Ps512: "PS512",
} as const;
export type CustomSigningKeyAlgorithmEnum =
    (typeof CustomSigningKeyAlgorithmEnum)[keyof typeof CustomSigningKeyAlgorithmEnum];

/** Curve */
export const CustomSigningKeyCurveEnum = {
    P256: "P-256",
    P384: "P-384",
    P521: "P-521",
} as const;
export type CustomSigningKeyCurveEnum = (typeof CustomSigningKeyCurveEnum)[keyof typeof CustomSigningKeyCurveEnum];

/**
 * JWK representing a custom public signing key.
 */
export interface CustomSigningKeyJwk {
    kty: Management.CustomSigningKeyTypeEnum;
    /** Key identifier */
    kid?: string;
    use?: Management.CustomSigningKeyUseEnum;
    /** Key operations */
    key_ops?: Management.CustomSigningKeyOperationEnum[];
    alg?: Management.CustomSigningKeyAlgorithmEnum;
    /** Key modulus */
    n?: string;
    /** Key exponent */
    e?: string;
    crv?: Management.CustomSigningKeyCurveEnum;
    /** X coordinate */
    x?: string;
    /** Y coordinate */
    y?: string;
    /** X.509 URL */
    x5u?: string;
    /** X.509 certificate chain */
    x5c?: string[];
    /** X.509 certificate SHA-1 thumbprint */
    x5t?: string;
    /** X.509 certificate SHA-256 thumbprint */
    "x5t#S256"?: string;
}

export type CustomSigningKeyOperationEnum = "verify";

/** Key type */
export const CustomSigningKeyTypeEnum = {
    Ec: "EC",
    Rsa: "RSA",
} as const;
export type CustomSigningKeyTypeEnum = (typeof CustomSigningKeyTypeEnum)[keyof typeof CustomSigningKeyTypeEnum];

/**
 * Key use
 */
export type CustomSigningKeyUseEnum = "sig";

export interface DailyStats {
    /** Date these events occurred in ISO 8601 format. */
    date?: string;
    /** Number of logins on this date. */
    logins?: number;
    /** Number of signups on this date. */
    signups?: number;
    /** Number of breached-password detections on this date (subscription required). */
    leaked_passwords?: number;
    /** Date and time this stats entry was last updated in ISO 8601 format. */
    updated_at?: string;
    /** Approximate date and time the first event occurred in ISO 8601 format. */
    created_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Token Quota configuration, to configure quotas for token issuance for clients and organizations. Applied to all clients and organizations unless overridden in individual client or organization settings.
 */
export interface DefaultTokenQuota {
    clients?: Management.TokenQuotaConfiguration;
    organizations?: Management.TokenQuotaConfiguration;
}

/**
 * Array of secret names to delete.
 */
export type DeleteHookSecretRequestContent = string[];

export interface DeleteUserIdentityResponseContentItem {
    /** The name of the connection for the identity. */
    connection: string;
    /** The unique identifier for the user for the identity. */
    user_id: string;
    /** The type of identity provider. */
    provider: string;
    /** <code>true</code> if the identity provider is a social provider, <code>false</code>s otherwise */
    isSocial?: boolean;
    /** IDP access token returned only if scope read:user_idp_tokens is defined */
    access_token?: string;
    /** IDP access token secret returned only if scope read:user_idp_tokens is defined. */
    access_token_secret?: string;
    /** IDP refresh token returned only if scope read:user_idp_tokens is defined. */
    refresh_token?: string;
    profileData?: Management.UserProfileData;
}

/**
 * An array of objects with information about the user's identities.
 */
export type DeleteUserIdentityResponseContent = Management.DeleteUserIdentityResponseContentItem[];

export interface DeployActionResponseContent {
    /** The unique id of an action version. */
    id?: string;
    /** The id of the action to which this version belongs. */
    action_id?: string;
    /** The source code of this specific version of the action. */
    code?: string;
    /** The list of third party npm modules, and their versions, that this specific version depends on. */
    dependencies?: Management.ActionVersionDependency[];
    /** Indicates if this specific version is the currently one deployed. */
    deployed?: boolean;
    /** The Node runtime. For example: `node22` */
    runtime?: string;
    /** The list of secrets that are included in an action or a version of an action. */
    secrets?: Management.ActionSecretResponse[];
    status?: Management.ActionVersionBuildStatusEnum;
    /** The index of this version in list of versions for the action. */
    number?: number;
    /** Any errors that occurred while the version was being built. */
    errors?: Management.ActionError[];
    action?: Management.ActionBase;
    /** The time when this version was built successfully. */
    built_at?: string;
    /** The time when this version was created. */
    created_at?: string;
    /** The time when a version was updated. Versions are never updated externally. Only Auth0 will update an action version as it is being built. */
    updated_at?: string;
    /** The list of triggers that this version supports. At this time, a version can only target a single trigger at a time. */
    supported_triggers?: Management.ActionTrigger[];
}

export interface DeployActionVersionRequestBodyParams {
    /** True if the draft of the action should be updated with the reverted version. */
    update_draft?: boolean;
}

export type DeployActionVersionRequestContent = (Management.DeployActionVersionRequestBodyParams | null) | undefined;

export interface DeployActionVersionResponseContent {
    /** The unique id of an action version. */
    id?: string;
    /** The id of the action to which this version belongs. */
    action_id?: string;
    /** The source code of this specific version of the action. */
    code?: string;
    /** The list of third party npm modules, and their versions, that this specific version depends on. */
    dependencies?: Management.ActionVersionDependency[];
    /** Indicates if this specific version is the currently one deployed. */
    deployed?: boolean;
    /** The Node runtime. For example: `node22` */
    runtime?: string;
    /** The list of secrets that are included in an action or a version of an action. */
    secrets?: Management.ActionSecretResponse[];
    status?: Management.ActionVersionBuildStatusEnum;
    /** The index of this version in list of versions for the action. */
    number?: number;
    /** Any errors that occurred while the version was being built. */
    errors?: Management.ActionError[];
    action?: Management.ActionBase;
    /** The time when this version was built successfully. */
    built_at?: string;
    /** The time when this version was created. */
    created_at?: string;
    /** The time when a version was updated. Versions are never updated externally. Only Auth0 will update an action version as it is being built. */
    updated_at?: string;
    /** The list of triggers that this version supports. At this time, a version can only target a single trigger at a time. */
    supported_triggers?: Management.ActionTrigger[];
}

export interface DeviceCredential {
    /** ID of this device. */
    id?: string;
    /** User agent for this device */
    device_name?: string;
    /** Unique identifier for the device. NOTE: This field is generally not populated for refresh_tokens and rotating_refresh_tokens */
    device_id?: string;
    type?: Management.DeviceCredentialTypeEnum;
    /** user_id this credential is associated with. */
    user_id?: string;
    /** client_id of the client (application) this credential is for. */
    client_id?: string;
}

/**
 * Type of credential. Must be `public_key`.
 */
export type DeviceCredentialPublicKeyTypeEnum = "public_key";

/** Type of credentials to retrieve. Must be `public_key`, `refresh_token` or `rotating_refresh_token`. The property will default to `refresh_token` when paging is requested */
export const DeviceCredentialTypeEnum = {
    PublicKey: "public_key",
    RefreshToken: "refresh_token",
    RotatingRefreshToken: "rotating_refresh_token",
} as const;
export type DeviceCredentialTypeEnum = (typeof DeviceCredentialTypeEnum)[keyof typeof DeviceCredentialTypeEnum];

/**
 * Certificate information. This object is relevant only for Custom Domains with Auth0-Managed Certificates.
 */
export interface DomainCertificate {
    status?: Management.DomainCertificateStatusEnum;
    /** A user-friendly error message will be presented if the certificate status is provisioning_failed or renewing_failed. */
    error_msg?: string;
    certificate_authority?: Management.DomainCertificateAuthorityEnum;
    /** The certificate will be renewed prior to this date. */
    renews_before?: string;
}

/** The Certificate Authority issued the certificate. */
export const DomainCertificateAuthorityEnum = {
    Letsencrypt: "letsencrypt",
    Googletrust: "googletrust",
} as const;
export type DomainCertificateAuthorityEnum =
    (typeof DomainCertificateAuthorityEnum)[keyof typeof DomainCertificateAuthorityEnum];

/** The provisioning status of the certificate. */
export const DomainCertificateStatusEnum = {
    Provisioning: "provisioning",
    ProvisioningFailed: "provisioning_failed",
    Provisioned: "provisioned",
    RenewingFailed: "renewing_failed",
} as const;
export type DomainCertificateStatusEnum =
    (typeof DomainCertificateStatusEnum)[keyof typeof DomainCertificateStatusEnum];

/**
 * Domain verification settings.
 */
export interface DomainVerification {
    /** Domain verification methods. */
    methods?: Management.DomainVerificationMethod[];
    status?: Management.DomainVerificationStatusEnum;
    /** The user0-friendly error message in case of failed verification. This field is relevant only for Custom Domains with Auth0-Managed Certificates. */
    error_msg?: string;
    /** The date and time when the custom domain was last verified. This field is relevant only for Custom Domains with Auth0-Managed Certificates. */
    last_verified_at?: string;
}

export interface DomainVerificationMethod {
    name: Management.DomainVerificationMethodNameEnum;
    /** Value used to verify the domain. */
    record: string;
    /** The name of the txt record for verification */
    domain?: string;
}

/** Domain verification method. */
export const DomainVerificationMethodNameEnum = {
    Cname: "cname",
    Txt: "txt",
} as const;
export type DomainVerificationMethodNameEnum =
    (typeof DomainVerificationMethodNameEnum)[keyof typeof DomainVerificationMethodNameEnum];

/** The DNS record verification status. This field is relevant only for Custom Domains with Auth0-Managed Certificates. */
export const DomainVerificationStatusEnum = {
    Verified: "verified",
    Pending: "pending",
    Failed: "failed",
} as const;
export type DomainVerificationStatusEnum =
    (typeof DomainVerificationStatusEnum)[keyof typeof DomainVerificationStatusEnum];

/**
 * Configuration for the email attribute for users.
 */
export interface EmailAttribute {
    identifier?: Management.ConnectionAttributeIdentifier;
    /** Determines if property should be required for users */
    profile_required?: boolean;
    verification_method?: Management.VerificationMethodEnum;
    signup?: Management.SignupVerified;
}

/**
 * Set to <code>eu</code> if your domain is provisioned to use Mailgun's EU region. Otherwise, set to <code>null</code>.
 */
export type EmailMailgunRegionEnum = "eu";

/**
 * Credentials required to use the provider.
 */
export interface EmailProviderCredentials {
    /** API User. */
    api_user?: string;
    /** AWS or SparkPost region. */
    region?: string;
    /** SMTP host. */
    smtp_host?: string;
    /** SMTP port. */
    smtp_port?: number;
    /** SMTP username. */
    smtp_user?: string;
}

/**
 * Credentials required to use the provider.
 */
export type EmailProviderCredentialsSchema =
    | {
          api_key: string;
      }
    | {
          accessKeyId?: string | undefined;
          secretAccessKey?: string | undefined;
          region?: string | undefined;
      }
    | {
          smtp_host?: Management.EmailSmtpHost | undefined;
          smtp_port?: number | undefined;
          smtp_user?: string | undefined;
          smtp_pass?: string | undefined;
      }
    | {
          api_key?: string | undefined;
          region?: Management.EmailSparkPostRegionEnum | undefined;
      }
    | {
          api_key?: string | undefined;
          domain?: string | undefined;
          region?: Management.EmailMailgunRegionEnum | undefined;
      }
    | {
          connectionString?: string | undefined;
      }
    | {
          tenantId?: string | undefined;
          clientId?: string | undefined;
          clientSecret?: string | undefined;
      }
    | Management.ExtensibilityEmailProviderCredentials;

/** Name of the email provider. Can be `mailgun`, `mandrill`, `sendgrid`, `ses`, `sparkpost`, `smtp`, `azure_cs`, `ms365`, or `custom`. */
export const EmailProviderNameEnum = {
    Mailgun: "mailgun",
    Mandrill: "mandrill",
    Sendgrid: "sendgrid",
    Ses: "ses",
    Sparkpost: "sparkpost",
    Smtp: "smtp",
    AzureCs: "azure_cs",
    Ms365: "ms365",
    Custom: "custom",
} as const;
export type EmailProviderNameEnum = (typeof EmailProviderNameEnum)[keyof typeof EmailProviderNameEnum];

/**
 * Specific provider setting
 */
export type EmailProviderSettings = Record<string, unknown>;

/**
 * SMTP host.
 */
export type EmailSmtpHost = string;

/**
 * Set to <code>eu</code> to use SparkPost service hosted in Western Europe. To use SparkPost hosted in North America, set it to <code>null</code>.
 */
export type EmailSparkPostRegionEnum = "eu";

/**
 * Specific provider setting
 */
export type EmailSpecificProviderSettingsWithAdditionalProperties = (Record<string, unknown> | null) | undefined;

/** Template name. Can be `verify_email`, `verify_email_by_code`, `reset_email`, `reset_email_by_code`, `welcome_email`, `blocked_account`, `stolen_credentials`, `enrollment_email`, `mfa_oob_code`, `user_invitation`, `async_approval`, `change_password` (legacy), or `password_reset` (legacy). */
export const EmailTemplateNameEnum = {
    VerifyEmail: "verify_email",
    VerifyEmailByCode: "verify_email_by_code",
    ResetEmail: "reset_email",
    ResetEmailByCode: "reset_email_by_code",
    WelcomeEmail: "welcome_email",
    BlockedAccount: "blocked_account",
    StolenCredentials: "stolen_credentials",
    EnrollmentEmail: "enrollment_email",
    MfaOobCode: "mfa_oob_code",
    UserInvitation: "user_invitation",
    ChangePassword: "change_password",
    PasswordReset: "password_reset",
    AsyncApproval: "async_approval",
} as const;
export type EmailTemplateNameEnum = (typeof EmailTemplateNameEnum)[keyof typeof EmailTemplateNameEnum];

/** Enum for enabled features. */
export const EnabledFeaturesEnum = {
    Scim: "scim",
    UniversalLogout: "universal_logout",
} as const;
export type EnabledFeaturesEnum = (typeof EnabledFeaturesEnum)[keyof typeof EnabledFeaturesEnum];

/**
 * Encryption key
 */
export interface EncryptionKey {
    /** Key ID */
    kid: string;
    type: Management.EncryptionKeyType;
    state: Management.EncryptionKeyState;
    /** Key creation timestamp */
    created_at: string;
    /** Key update timestamp */
    updated_at: string;
    /** ID of parent wrapping key */
    parent_kid: string;
    /** Public key in PEM format */
    public_key?: string;
}

/**
 * Encryption algorithm that shall be used to wrap your key material
 */
export type EncryptionKeyPublicWrappingAlgorithm = "CKM_RSA_AES_KEY_WRAP";

/** Key state */
export const EncryptionKeyState = {
    PreActivation: "pre-activation",
    Active: "active",
    Deactivated: "deactivated",
    Destroyed: "destroyed",
} as const;
export type EncryptionKeyState = (typeof EncryptionKeyState)[keyof typeof EncryptionKeyState];

/** Key type */
export const EncryptionKeyType = {
    CustomerProvidedRootKey: "customer-provided-root-key",
    EnvironmentRootKey: "environment-root-key",
    TenantMasterKey: "tenant-master-key",
    TenantEncryptionKey: "tenant-encryption-key",
} as const;
export type EncryptionKeyType = (typeof EncryptionKeyType)[keyof typeof EncryptionKeyType];

/**
 * Configuration specific to an action destination.
 */
export interface EventStreamActionConfiguration {
    /** Action ID for the action destination. */
    action_id: string;
}

export interface EventStreamActionDestination {
    type: Management.EventStreamActionDestinationTypeEnum;
    configuration: Management.EventStreamActionConfiguration;
}

export type EventStreamActionDestinationTypeEnum = "action";

export interface EventStreamActionResponseContent {
    /** Unique identifier for the event stream. */
    id?: string;
    /** Name of the event stream. */
    name?: string;
    /** List of event types subscribed to in this stream. */
    subscriptions?: Management.EventStreamSubscription[];
    destination?: Management.EventStreamActionDestination;
    status?: Management.EventStreamStatusEnum;
    /** Timestamp when the event stream was created. */
    created_at?: string;
    /** Timestamp when the event stream was last updated. */
    updated_at?: string;
}

/**
 * Event content. This will only be set if delivery failed.
 */
export interface EventStreamCloudEvent {
    /** Unique identifier for the event */
    id?: string;
    /** Where the event originated */
    source?: string;
    /** Version of CloudEvents spec */
    specversion?: string;
    /** Type of the event (e.g., user.created) */
    type?: string;
    /** Timestamp at which the event was generated */
    time?: string;
    /** Event contents encoded as a string. */
    data?: string;
}

/**
 * Metadata about a specific attempt to deliver an event
 */
export interface EventStreamDelivery {
    /** Unique identifier for the delivery */
    id: string;
    /** Unique identifier for the event stream. */
    event_stream_id: string;
    status: Management.EventStreamDeliveryStatusEnum;
    event_type: Management.EventStreamDeliveryEventTypeEnum;
    /** Results of delivery attempts */
    attempts: Management.EventStreamDeliveryAttempt[];
    event?: Management.EventStreamCloudEvent;
}

export interface EventStreamDeliveryAttempt {
    status: Management.EventStreamDeliveryStatusEnum;
    /** Timestamp of delivery attempt */
    timestamp: string;
    /** Delivery error message, if applicable */
    error_message?: string;
}

/** Type of event */
export const EventStreamDeliveryEventTypeEnum = {
    UserCreated: "user.created",
    UserDeleted: "user.deleted",
    UserUpdated: "user.updated",
    OrganizationCreated: "organization.created",
    OrganizationUpdated: "organization.updated",
    OrganizationDeleted: "organization.deleted",
    OrganizationMemberAdded: "organization.member.added",
    OrganizationMemberDeleted: "organization.member.deleted",
    OrganizationMemberRoleAssigned: "organization.member.role.assigned",
    OrganizationMemberRoleDeleted: "organization.member.role.deleted",
    OrganizationConnectionAdded: "organization.connection.added",
    OrganizationConnectionUpdated: "organization.connection.updated",
    OrganizationConnectionRemoved: "organization.connection.removed",
    GroupCreated: "group.created",
    GroupUpdated: "group.updated",
    GroupDeleted: "group.deleted",
    GroupMemberAdded: "group.member.added",
    GroupMemberDeleted: "group.member.deleted",
} as const;
export type EventStreamDeliveryEventTypeEnum =
    (typeof EventStreamDeliveryEventTypeEnum)[keyof typeof EventStreamDeliveryEventTypeEnum];

/**
 * Delivery status
 */
export type EventStreamDeliveryStatusEnum = "failed";

export type EventStreamDestinationPatch =
    | Management.EventStreamWebhookDestination
    | Management.EventStreamActionDestination;

/** AWS Region for EventBridge destination. */
export const EventStreamEventBridgeAwsRegionEnum = {
    AfSouth1: "af-south-1",
    ApEast1: "ap-east-1",
    ApEast2: "ap-east-2",
    ApNortheast1: "ap-northeast-1",
    ApNortheast2: "ap-northeast-2",
    ApNortheast3: "ap-northeast-3",
    ApSouth1: "ap-south-1",
    ApSouth2: "ap-south-2",
    ApSoutheast1: "ap-southeast-1",
    ApSoutheast2: "ap-southeast-2",
    ApSoutheast3: "ap-southeast-3",
    ApSoutheast4: "ap-southeast-4",
    ApSoutheast5: "ap-southeast-5",
    ApSoutheast6: "ap-southeast-6",
    ApSoutheast7: "ap-southeast-7",
    CaCentral1: "ca-central-1",
    CaWest1: "ca-west-1",
    EuCentral1: "eu-central-1",
    EuCentral2: "eu-central-2",
    EuNorth1: "eu-north-1",
    EuSouth1: "eu-south-1",
    EuSouth2: "eu-south-2",
    EuWest1: "eu-west-1",
    EuWest2: "eu-west-2",
    EuWest3: "eu-west-3",
    IlCentral1: "il-central-1",
    MeCentral1: "me-central-1",
    MeSouth1: "me-south-1",
    MxCentral1: "mx-central-1",
    SaEast1: "sa-east-1",
    UsGovEast1: "us-gov-east-1",
    UsGovWest1: "us-gov-west-1",
    UsEast1: "us-east-1",
    UsEast2: "us-east-2",
    UsWest1: "us-west-1",
    UsWest2: "us-west-2",
} as const;
export type EventStreamEventBridgeAwsRegionEnum =
    (typeof EventStreamEventBridgeAwsRegionEnum)[keyof typeof EventStreamEventBridgeAwsRegionEnum];

/**
 * Configuration specific to an eventbridge destination.
 */
export interface EventStreamEventBridgeConfiguration {
    /** AWS Account ID for EventBridge destination. */
    aws_account_id: string;
    aws_region: Management.EventStreamEventBridgeAwsRegionEnum;
    /** AWS Partner Event Source for EventBridge destination. */
    aws_partner_event_source?: string;
}

export interface EventStreamEventBridgeDestination {
    type: Management.EventStreamEventBridgeDestinationTypeEnum;
    configuration: Management.EventStreamEventBridgeConfiguration;
}

export type EventStreamEventBridgeDestinationTypeEnum = "eventbridge";

export interface EventStreamEventBridgeResponseContent {
    /** Unique identifier for the event stream. */
    id?: string;
    /** Name of the event stream. */
    name?: string;
    /** List of event types subscribed to in this stream. */
    subscriptions?: Management.EventStreamSubscription[];
    destination?: Management.EventStreamEventBridgeDestination;
    status?: Management.EventStreamStatusEnum;
    /** Timestamp when the event stream was created. */
    created_at?: string;
    /** Timestamp when the event stream was last updated. */
    updated_at?: string;
}

export const EventStreamEventTypeEnum = {
    UserCreated: "user.created",
    UserDeleted: "user.deleted",
    UserUpdated: "user.updated",
    OrganizationCreated: "organization.created",
    OrganizationUpdated: "organization.updated",
    OrganizationDeleted: "organization.deleted",
    OrganizationMemberAdded: "organization.member.added",
    OrganizationMemberDeleted: "organization.member.deleted",
    OrganizationMemberRoleAssigned: "organization.member.role.assigned",
    OrganizationMemberRoleDeleted: "organization.member.role.deleted",
    OrganizationConnectionAdded: "organization.connection.added",
    OrganizationConnectionUpdated: "organization.connection.updated",
    OrganizationConnectionRemoved: "organization.connection.removed",
    GroupCreated: "group.created",
    GroupUpdated: "group.updated",
    GroupDeleted: "group.deleted",
    GroupMemberAdded: "group.member.added",
    GroupMemberDeleted: "group.member.deleted",
} as const;
export type EventStreamEventTypeEnum = (typeof EventStreamEventTypeEnum)[keyof typeof EventStreamEventTypeEnum];

export type EventStreamResponseContent =
    | Management.EventStreamWebhookResponseContent
    | Management.EventStreamEventBridgeResponseContent
    | Management.EventStreamActionResponseContent;

/** Indicates whether the event stream is actively forwarding events. */
export const EventStreamStatusEnum = {
    Enabled: "enabled",
    Disabled: "disabled",
} as const;
export type EventStreamStatusEnum = (typeof EventStreamStatusEnum)[keyof typeof EventStreamStatusEnum];

/**
 * Event types
 */
export interface EventStreamSubscription {
    event_type?: string;
}

/** The type of event this test event represents. */
export const EventStreamTestEventTypeEnum = {
    UserCreated: "user.created",
    UserDeleted: "user.deleted",
    UserUpdated: "user.updated",
    OrganizationCreated: "organization.created",
    OrganizationUpdated: "organization.updated",
    OrganizationDeleted: "organization.deleted",
    OrganizationMemberAdded: "organization.member.added",
    OrganizationMemberDeleted: "organization.member.deleted",
    OrganizationMemberRoleAssigned: "organization.member.role.assigned",
    OrganizationMemberRoleDeleted: "organization.member.role.deleted",
    OrganizationConnectionAdded: "organization.connection.added",
    OrganizationConnectionUpdated: "organization.connection.updated",
    OrganizationConnectionRemoved: "organization.connection.removed",
    GroupCreated: "group.created",
    GroupUpdated: "group.updated",
    GroupDeleted: "group.deleted",
    GroupMemberAdded: "group.member.added",
    GroupMemberDeleted: "group.member.deleted",
} as const;
export type EventStreamTestEventTypeEnum =
    (typeof EventStreamTestEventTypeEnum)[keyof typeof EventStreamTestEventTypeEnum];

export type EventStreamWebhookAuthorizationResponse =
    | Management.EventStreamWebhookBasicAuth
    | Management.EventStreamWebhookBearerAuth;

/**
 * Basic Authorization for HTTP requests (e.g., 'Basic credentials').
 */
export interface EventStreamWebhookBasicAuth {
    method: Management.EventStreamWebhookBasicAuthMethodEnum;
    /** Username */
    username: string;
}

/**
 * Type of authorization.
 */
export type EventStreamWebhookBasicAuthMethodEnum = "basic";

/**
 * Bearer Authorization for HTTP requests (e.g., 'Bearer token').
 */
export interface EventStreamWebhookBearerAuth {
    method: Management.EventStreamWebhookBearerAuthMethodEnum;
}

/**
 * Type of authorization.
 */
export type EventStreamWebhookBearerAuthMethodEnum = "bearer";

/**
 * Configuration specific to a webhook destination.
 */
export interface EventStreamWebhookConfiguration {
    /** Target HTTP endpoint URL. */
    webhook_endpoint: string;
    webhook_authorization: Management.EventStreamWebhookAuthorizationResponse;
}

export interface EventStreamWebhookDestination {
    type: Management.EventStreamWebhookDestinationTypeEnum;
    configuration: Management.EventStreamWebhookConfiguration;
}

export type EventStreamWebhookDestinationTypeEnum = "webhook";

export interface EventStreamWebhookResponseContent {
    /** Unique identifier for the event stream. */
    id?: string;
    /** Name of the event stream. */
    name?: string;
    /** List of event types subscribed to in this stream. */
    subscriptions?: Management.EventStreamSubscription[];
    destination?: Management.EventStreamWebhookDestination;
    status?: Management.EventStreamStatusEnum;
    /** Timestamp when the event stream was created. */
    created_at?: string;
    /** Timestamp when the event stream was last updated. */
    updated_at?: string;
}

/**
 * Application specific configuration for use with the OIN Express Configuration feature.
 */
export interface ExpressConfiguration {
    /** The URI users should bookmark to log in to this application. Variable substitution is permitted for the following properties: organization_name, organization_id, and connection_name. */
    initiate_login_uri_template: string;
    /** The ID of the user attribute profile to use for this application. */
    user_attribute_profile_id: string;
    /** The ID of the connection profile to use for this application. */
    connection_profile_id: string;
    /** When true, all connections made via express configuration will be enabled for this application. */
    enable_client: boolean;
    /** When true, all connections made via express configuration will have the associated organization enabled. */
    enable_organization: boolean;
    /** List of client IDs that are linked to this express configuration (e.g. web or mobile clients). */
    linked_clients?: Management.LinkedClientConfiguration[];
    /** This is the unique identifier for the Okta OIN Express Configuration Client, which Okta will use for this application. */
    okta_oin_client_id: string;
    /** This is the domain that admins are expected to log in via for authenticating for express configuration. It can be either the canonical domain or a registered custom domain. */
    admin_login_domain: string;
    /** The identifier of the published application in the OKTA OIN. */
    oin_submission_id?: string;
}

/**
 * Application specific configuration for use with the OIN Express Configuration feature.
 */
export interface ExpressConfigurationOrNull {
    /** The URI users should bookmark to log in to this application. Variable substitution is permitted for the following properties: organization_name, organization_id, and connection_name. */
    initiate_login_uri_template: string;
    /** The ID of the user attribute profile to use for this application. */
    user_attribute_profile_id: string;
    /** The ID of the connection profile to use for this application. */
    connection_profile_id: string;
    /** When true, all connections made via express configuration will be enabled for this application. */
    enable_client: boolean;
    /** When true, all connections made via express configuration will have the associated organization enabled. */
    enable_organization: boolean;
    /** List of client IDs that are linked to this express configuration (e.g. web or mobile clients). */
    linked_clients?: Management.LinkedClientConfiguration[];
    /** This is the unique identifier for the Okta OIN Express Configuration Client, which Okta will use for this application. */
    okta_oin_client_id: string;
    /** This is the domain that admins are expected to log in via for authenticating for express configuration. It can be either the canonical domain or a registered custom domain. */
    admin_login_domain: string;
    /** The identifier of the published application in the OKTA OIN. */
    oin_submission_id?: string;
}

export interface ExtensibilityEmailProviderCredentials {}

export interface FederatedConnectionTokenSet {
    id?: string;
    connection?: string;
    scope?: string;
    expires_at?: string;
    issued_at?: string;
    last_used_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export type FlowAction =
    | Management.FlowActionActivecampaign
    | Management.FlowActionAirtable
    | Management.FlowActionAuth0
    | Management.FlowActionBigquery
    | Management.FlowActionClearbit
    | Management.FlowActionEmail
    | Management.FlowActionFlow
    | Management.FlowActionGoogleSheets
    | Management.FlowActionHttp
    | Management.FlowActionHubspot
    | Management.FlowActionJson
    | Management.FlowActionJwt
    | Management.FlowActionMailchimp
    | Management.FlowActionMailjet
    | Management.FlowActionOtp
    | Management.FlowActionPipedrive
    | Management.FlowActionSalesforce
    | Management.FlowActionSendgrid
    | Management.FlowActionSlack
    | Management.FlowActionStripe
    | Management.FlowActionTelegram
    | Management.FlowActionTwilio
    | Management.FlowActionWhatsapp
    | Management.FlowActionXml
    | Management.FlowActionZapier;

export type FlowActionActivecampaign =
    | Management.FlowActionActivecampaignListContacts
    | Management.FlowActionActivecampaignUpsertContact;

export interface FlowActionActivecampaignListContacts {
    id: string;
    alias?: string;
    type: "ACTIVECAMPAIGN";
    action: "LIST_CONTACTS";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionActivecampaignListContactsParams;
}

export interface FlowActionActivecampaignListContactsParams {
    connection_id: string;
    email: string;
}

export interface FlowActionActivecampaignUpsertContact {
    id: string;
    alias?: string;
    type: "ACTIVECAMPAIGN";
    action: "UPSERT_CONTACT";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionActivecampaignUpsertContactParams;
}

export interface FlowActionActivecampaignUpsertContactParams {
    connection_id: string;
    email: string;
    first_name?: string;
    last_name?: string;
    phone?: string;
    custom_fields?: Management.FlowActionActivecampaignUpsertContactParamsCustomFields;
}

export type FlowActionActivecampaignUpsertContactParamsCustomFields = Record<string, unknown>;

export type FlowActionAirtable =
    | Management.FlowActionAirtableCreateRecord
    | Management.FlowActionAirtableListRecords
    | Management.FlowActionAirtableUpdateRecord;

export interface FlowActionAirtableCreateRecord {
    id: string;
    alias?: string;
    type: "AIRTABLE";
    action: "CREATE_RECORD";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionAirtableCreateRecordParams;
}

export interface FlowActionAirtableCreateRecordParams {
    connection_id: string;
    base_id: string;
    table_name: string;
    fields?: Management.FlowActionAirtableCreateRecordParamsFields;
}

export type FlowActionAirtableCreateRecordParamsFields = Record<string, unknown>;

export interface FlowActionAirtableListRecords {
    id: string;
    alias?: string;
    type: "AIRTABLE";
    action: "LIST_RECORDS";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionAirtableListRecordsParams;
}

export interface FlowActionAirtableListRecordsParams {
    connection_id: string;
    base_id: string;
    table_name: string;
    query?: string;
    view?: string;
}

export interface FlowActionAirtableUpdateRecord {
    id: string;
    alias?: string;
    type: "AIRTABLE";
    action: "UPDATE_RECORD";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionAirtableUpdateRecordParams;
}

export interface FlowActionAirtableUpdateRecordParams {
    connection_id: string;
    base_id: string;
    table_name: string;
    record_id: string;
    fields?: Management.FlowActionAirtableUpdateRecordParamsFields;
}

export type FlowActionAirtableUpdateRecordParamsFields = Record<string, unknown>;

export type FlowActionAuth0 =
    | Management.FlowActionAuth0CreateUser
    | Management.FlowActionAuth0GetUser
    | Management.FlowActionAuth0UpdateUser
    | Management.FlowActionAuth0SendRequest
    | Management.FlowActionAuth0SendEmail;

export interface FlowActionAuth0CreateUser {
    id: string;
    alias?: string;
    type: "AUTH0";
    action: "CREATE_USER";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionAuth0CreateUserParams;
}

export interface FlowActionAuth0CreateUserParams {
    connection_id: string;
    payload: Management.FlowActionAuth0CreateUserParamsPayload;
}

export type FlowActionAuth0CreateUserParamsPayload = Record<string, unknown>;

export interface FlowActionAuth0GetUser {
    id: string;
    alias?: string;
    type: "AUTH0";
    action: "GET_USER";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionAuth0GetUserParams;
}

export interface FlowActionAuth0GetUserParams {
    connection_id: string;
    user_id: string;
}

export interface FlowActionAuth0SendEmail {
    id: string;
    alias?: string;
    type: "AUTH0";
    action: "SEND_EMAIL";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionAuth0SendEmailParams;
}

export interface FlowActionAuth0SendEmailParams {
    from?: Management.FlowActionAuth0SendEmailParamsFrom;
    to: Management.FlowActionAuth0SendEmailParamsTo;
    subject: string;
    body: string;
    custom_vars?: Management.FlowActionAuth0SendRequestParamsCustomVars;
}

export interface FlowActionAuth0SendEmailParamsFrom {
    name?: string;
    email: Management.FlowActionAuth0SendEmailParamsFromEmail;
}

export type FlowActionAuth0SendEmailParamsFromEmail = string;

export type FlowActionAuth0SendEmailParamsTo = string;

export interface FlowActionAuth0SendRequest {
    id: string;
    alias?: string;
    type: "AUTH0";
    action: "SEND_REQUEST";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionAuth0SendRequestParams;
}

export interface FlowActionAuth0SendRequestParams {
    connection_id: string;
    pathname: string;
    method?: FlowActionAuth0SendRequestParams.Method;
    headers?: Management.FlowActionAuth0SendRequestParamsHeaders;
    params?: Management.FlowActionAuth0SendRequestParamsQueryParams;
    payload?: Management.FlowActionAuth0SendRequestParamsPayload;
}

export namespace FlowActionAuth0SendRequestParams {
    export const Method = {
        Get: "GET",
        Post: "POST",
        Put: "PUT",
        Patch: "PATCH",
        Delete: "DELETE",
    } as const;
    export type Method = (typeof Method)[keyof typeof Method];
}

export type FlowActionAuth0SendRequestParamsCustomVars = Record<string, unknown>;

export type FlowActionAuth0SendRequestParamsHeaders = Record<string, unknown>;

export type FlowActionAuth0SendRequestParamsPayload =
    | string
    | unknown[]
    | Management.FlowActionAuth0SendRequestParamsPayloadObject;

export type FlowActionAuth0SendRequestParamsPayloadObject = Record<string, unknown>;

export type FlowActionAuth0SendRequestParamsQueryParams = Record<
    string,
    (FlowActionAuth0SendRequestParamsQueryParams.Value | null) | undefined
>;

export namespace FlowActionAuth0SendRequestParamsQueryParams {
    export type Value = number | string;
}

export interface FlowActionAuth0UpdateUser {
    id: string;
    alias?: string;
    type: "AUTH0";
    action: "UPDATE_USER";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionAuth0UpdateUserParams;
}

export interface FlowActionAuth0UpdateUserParams {
    connection_id: string;
    user_id: string;
    changes: Management.FlowActionAuth0UpdateUserParamsChanges;
}

export type FlowActionAuth0UpdateUserParamsChanges = Record<string, unknown>;

export type FlowActionBigquery = Management.FlowActionBigqueryInsertRows;

export interface FlowActionBigqueryInsertRows {
    id: string;
    alias?: string;
    type: "BIGQUERY";
    action: "INSERT_ROWS";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionBigqueryInsertRowsParams;
}

export interface FlowActionBigqueryInsertRowsParams {
    connection_id: string;
    dataset_id: string;
    table_id: string;
    data?: Management.FlowActionBigqueryInsertRowsParamsData;
}

export type FlowActionBigqueryInsertRowsParamsData = Record<string, unknown>;

export type FlowActionClearbit = Management.FlowActionClearbitFindPerson | Management.FlowActionClearbitFindCompany;

export interface FlowActionClearbitFindCompany {
    id: string;
    alias?: string;
    type: "CLEARBIT";
    action: "FIND_COMPANY";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionClearbitFindCompanyParams;
}

export interface FlowActionClearbitFindCompanyParams {
    connection_id: string;
    domain: string;
}

export interface FlowActionClearbitFindPerson {
    id: string;
    alias?: string;
    type: "CLEARBIT";
    action: "FIND_PERSON";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionClearbitFindPersonParams;
}

export interface FlowActionClearbitFindPersonParams {
    connection_id: string;
    email: string;
}

export type FlowActionEmail = Management.FlowActionEmailVerifyEmail;

export interface FlowActionEmailVerifyEmail {
    id: string;
    alias?: string;
    type: "EMAIL";
    action: "VERIFY_EMAIL";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionEmailVerifyEmailParams;
}

export interface FlowActionEmailVerifyEmailParams {
    email: string;
    rules?: Management.FlowActionEmailVerifyEmailParamsRules;
}

export interface FlowActionEmailVerifyEmailParamsRules {
    require_mx_record?: boolean;
    block_aliases?: boolean;
    block_free_emails?: boolean;
    block_disposable_emails?: boolean;
    blocklist?: string[];
    allowlist?: string[];
}

export type FlowActionFlow =
    | Management.FlowActionFlowBooleanCondition
    | Management.FlowActionFlowDelayFlow
    | Management.FlowActionFlowDoNothing
    | Management.FlowActionFlowErrorMessage
    | Management.FlowActionFlowMapValue
    | Management.FlowActionFlowReturnJson
    | Management.FlowActionFlowStoreVars;

export interface FlowActionFlowBooleanCondition {
    id: string;
    alias?: string;
    type: "FLOW";
    action: "BOOLEAN_CONDITION";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionFlowBooleanConditionParams;
}

export interface FlowActionFlowBooleanConditionParams {
    then?: Management.FlowAction[];
    else?: Management.FlowAction[];
}

export interface FlowActionFlowDelayFlow {
    id: string;
    alias?: string;
    type: "FLOW";
    action: "DELAY_FLOW";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionFlowDelayFlowParams;
}

export interface FlowActionFlowDelayFlowParams {
    number: Management.FlowActionFlowDelayFlowParamsNumber;
    units?: FlowActionFlowDelayFlowParams.Units;
}

export namespace FlowActionFlowDelayFlowParams {
    export const Units = {
        Seconds: "SECONDS",
        Minutes: "MINUTES",
        Hours: "HOURS",
        Days: "DAYS",
    } as const;
    export type Units = (typeof Units)[keyof typeof Units];
}

export type FlowActionFlowDelayFlowParamsNumber = number | string;

export interface FlowActionFlowDoNothing {
    id: string;
    alias?: string;
    type: "FLOW";
    action: "DO_NOTHING";
    allow_failure?: boolean;
    mask_output?: boolean;
    params?: Management.FlowActionFlowDoNothingParams;
}

export interface FlowActionFlowDoNothingParams {}

export interface FlowActionFlowErrorMessage {
    id: string;
    alias?: string;
    type: "FLOW";
    action: "ERROR_MESSAGE";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionFlowErrorMessageParams;
}

export interface FlowActionFlowErrorMessageParams {
    message: string;
}

export interface FlowActionFlowMapValue {
    id: string;
    alias?: string;
    type: "FLOW";
    action: "MAP_VALUE";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionFlowMapValueParams;
}

export interface FlowActionFlowMapValueParams {
    input: Management.FlowActionFlowMapValueParamsInput;
    cases?: Management.FlowActionFlowMapValueParamsCases;
    fallback?: Management.FlowActionFlowMapValueParamsFallback;
}

export type FlowActionFlowMapValueParamsCases = Record<string, unknown>;

export type FlowActionFlowMapValueParamsFallback =
    | string
    | number
    | Management.FlowActionFlowMapValueParamsFallbackObject
    | unknown[];

export type FlowActionFlowMapValueParamsFallbackObject = Record<string, unknown>;

export type FlowActionFlowMapValueParamsInput = string | number;

export interface FlowActionFlowReturnJson {
    id: string;
    alias?: string;
    type: "FLOW";
    action: "RETURN_JSON";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionFlowReturnJsonParams;
}

export interface FlowActionFlowReturnJsonParams {
    payload: Management.FlowActionFlowReturnJsonParamsPayload;
}

export type FlowActionFlowReturnJsonParamsPayload = Management.FlowActionFlowReturnJsonParamsPayloadObject | string;

export type FlowActionFlowReturnJsonParamsPayloadObject = Record<string, unknown>;

export interface FlowActionFlowStoreVars {
    id: string;
    alias?: string;
    type: "FLOW";
    action: "STORE_VARS";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionFlowStoreVarsParams;
}

export interface FlowActionFlowStoreVarsParams {
    vars: Management.FlowActionFlowStoreVarsParamsVars;
}

export type FlowActionFlowStoreVarsParamsVars = Record<string, unknown>;

export type FlowActionGoogleSheets = Management.FlowActionGoogleSheetsAddRow;

export interface FlowActionGoogleSheetsAddRow {
    id: string;
    alias?: string;
    type: "GOOGLE_SHEETS";
    action: "ADD_ROW";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionGoogleSheetsAddRowParams;
}

export interface FlowActionGoogleSheetsAddRowParams {
    connection_id: string;
    spreadsheet_id: string;
    sheet_id?: Management.FlowActionGoogleSheetsAddRowParamsSheetId;
    values?: Management.FlowActionGoogleSheetsAddRowParamsValues;
}

export type FlowActionGoogleSheetsAddRowParamsSheetId = number | string;

export type FlowActionGoogleSheetsAddRowParamsValues = ((string | null) | undefined)[];

export type FlowActionHttp = Management.FlowActionHttpSendRequest;

export interface FlowActionHttpSendRequest {
    id: string;
    alias?: string;
    type: "HTTP";
    action: "SEND_REQUEST";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionHttpSendRequestParams;
}

export interface FlowActionHttpSendRequestParams {
    connection_id?: string;
    url: string;
    method?: FlowActionHttpSendRequestParams.Method;
    headers?: Management.FlowActionHttpSendRequestParamsHeaders;
    basic?: Management.FlowActionHttpSendRequestParamsBasicAuth;
    params?: Management.FlowActionHttpSendRequestParamsQueryParams;
    payload?: Management.FlowActionHttpSendRequestParamsPayload;
    content_type?: FlowActionHttpSendRequestParams.ContentType;
}

export namespace FlowActionHttpSendRequestParams {
    export const Method = {
        Get: "GET",
        Post: "POST",
        Put: "PUT",
        Patch: "PATCH",
        Delete: "DELETE",
    } as const;
    export type Method = (typeof Method)[keyof typeof Method];
    export const ContentType = {
        Json: "JSON",
        Form: "FORM",
        Xml: "XML",
    } as const;
    export type ContentType = (typeof ContentType)[keyof typeof ContentType];
}

export interface FlowActionHttpSendRequestParamsBasicAuth {
    username?: string;
    password?: string;
}

export type FlowActionHttpSendRequestParamsHeaders = Record<string, unknown>;

export type FlowActionHttpSendRequestParamsPayload =
    | string
    | unknown[]
    | Management.FlowActionHttpSendRequestParamsPayloadObject;

export type FlowActionHttpSendRequestParamsPayloadObject = Record<string, unknown>;

export type FlowActionHttpSendRequestParamsQueryParams = Record<
    string,
    (FlowActionHttpSendRequestParamsQueryParams.Value | null) | undefined
>;

export namespace FlowActionHttpSendRequestParamsQueryParams {
    export type Value = number | string;
}

export type FlowActionHubspot =
    | Management.FlowActionHubspotEnrollContact
    | Management.FlowActionHubspotGetContact
    | Management.FlowActionHubspotUpsertContact;

export interface FlowActionHubspotEnrollContact {
    id: string;
    alias?: string;
    type: "HUBSPOT";
    action: "ENROLL_CONTACT";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionHubspotEnrollContactParams;
}

export interface FlowActionHubspotEnrollContactParams {
    connection_id: string;
    email: string;
    workflow_id: Management.FlowActionHubspotEnrollContactParamsWorkflowId;
}

export type FlowActionHubspotEnrollContactParamsWorkflowId = string | number;

export interface FlowActionHubspotGetContact {
    id: string;
    alias?: string;
    type: "HUBSPOT";
    action: "GET_CONTACT";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionHubspotGetContactParams;
}

export interface FlowActionHubspotGetContactParams {
    connection_id: string;
    email: string;
}

export interface FlowActionHubspotUpsertContact {
    id: string;
    alias?: string;
    type: "HUBSPOT";
    action: "UPSERT_CONTACT";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionHubspotUpsertContactParams;
}

export interface FlowActionHubspotUpsertContactParams {
    connection_id: string;
    email: string;
    properties?: Management.FlowActionHubspotUpsertContactParamsProperty[];
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface FlowActionHubspotUpsertContactParamsProperty {
    property: string;
}

export type FlowActionJson =
    | Management.FlowActionJsonCreateJson
    | Management.FlowActionJsonParseJson
    | Management.FlowActionJsonSerializeJson;

export interface FlowActionJsonCreateJson {
    id: string;
    alias?: string;
    type: "JSON";
    action: "CREATE_JSON";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionJsonCreateJsonParams;
}

export interface FlowActionJsonCreateJsonParams {
    object: Management.FlowActionJsonCreateJsonParamsObject;
}

export type FlowActionJsonCreateJsonParamsObject = Record<string, unknown>;

export interface FlowActionJsonParseJson {
    id: string;
    alias?: string;
    type: "JSON";
    action: "PARSE_JSON";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionJsonParseJsonParams;
}

export interface FlowActionJsonParseJsonParams {
    json: string;
}

export interface FlowActionJsonSerializeJson {
    id: string;
    alias?: string;
    type: "JSON";
    action: "SERIALIZE_JSON";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionJsonSerializeJsonParams;
}

export interface FlowActionJsonSerializeJsonParams {
    object: Management.FlowActionJsonSerializeJsonParamsObject;
}

export type FlowActionJsonSerializeJsonParamsObject = string | Management.FlowActionJsonSerializeJsonParamsObjectObject;

export type FlowActionJsonSerializeJsonParamsObjectObject = Record<string, unknown>;

export type FlowActionJwt =
    | Management.FlowActionJwtDecodeJwt
    | Management.FlowActionJwtSignJwt
    | Management.FlowActionJwtVerifyJwt;

export interface FlowActionJwtDecodeJwt {
    id: string;
    alias?: string;
    type: "JWT";
    action: "DECODE_JWT";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionJwtDecodeJwtParams;
}

export interface FlowActionJwtDecodeJwtParams {
    token: string;
}

export interface FlowActionJwtSignJwt {
    id: string;
    alias?: string;
    type: "JWT";
    action: "SIGN_JWT";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionJwtSignJwtParams;
}

export interface FlowActionJwtSignJwtParams {
    connection_id: string;
    payload?: Management.FlowActionJwtSignJwtParamsPayload;
    subject?: string;
    issuer?: string;
    audience?: string;
    expires_in?: string;
}

export type FlowActionJwtSignJwtParamsPayload = Record<string, unknown>;

export interface FlowActionJwtVerifyJwt {
    id: string;
    alias?: string;
    type: "JWT";
    action: "VERIFY_JWT";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionJwtVerifyJwtParams;
}

export interface FlowActionJwtVerifyJwtParams {
    connection_id: string;
    token: string;
    audience?: string;
    issuer?: string;
}

export type FlowActionMailchimp = Management.FlowActionMailchimpUpsertMember;

export interface FlowActionMailchimpUpsertMember {
    id: string;
    alias?: string;
    type: "MAILCHIMP";
    action: "UPSERT_MEMBER";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionMailchimpUpsertMemberParams;
}

export interface FlowActionMailchimpUpsertMemberParams {
    connection_id: string;
    list_id: string;
    member: Management.FlowActionMailchimpUpsertMemberParamsMember;
}

export interface FlowActionMailchimpUpsertMemberParamsMember {
    email_address: string;
    status_if_new: string;
    merge_fields?: Management.FlowActionMailchimpUpsertMemberParamsMemberMergeFields;
}

export type FlowActionMailchimpUpsertMemberParamsMemberMergeFields = Record<string, unknown>;

export type FlowActionMailjet = Management.FlowActionMailjetSendEmail;

export interface FlowActionMailjetSendEmail {
    id: string;
    alias?: string;
    type: "MAILJET";
    action: "SEND_EMAIL";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionMailjetSendEmailParams;
}

export type FlowActionMailjetSendEmailParams =
    | {
          content: string;
          [key: string]: any;
      }
    | {
          template_id: number;
          variables?: Record<string, unknown> | undefined;
          [key: string]: any;
      };

export type FlowActionOtp = Management.FlowActionOtpGenerateCode | Management.FlowActionOtpVerifyCode;

export interface FlowActionOtpGenerateCode {
    id: string;
    alias?: string;
    type: "OTP";
    action: "GENERATE_CODE";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionOtpGenerateCodeParams;
}

export interface FlowActionOtpGenerateCodeParams {
    reference: string;
    length: number;
}

export interface FlowActionOtpVerifyCode {
    id: string;
    alias?: string;
    type: "OTP";
    action: "VERIFY_CODE";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionOtpVerifyCodeParams;
}

export interface FlowActionOtpVerifyCodeParams {
    reference: string;
    code: Management.FlowActionOtpVerifyCodeParamsCode;
}

export type FlowActionOtpVerifyCodeParamsCode = number | string;

export type FlowActionPipedrive =
    | Management.FlowActionPipedriveAddDeal
    | Management.FlowActionPipedriveAddOrganization
    | Management.FlowActionPipedriveAddPerson;

export interface FlowActionPipedriveAddDeal {
    id: string;
    alias?: string;
    type: "PIPEDRIVE";
    action: "ADD_DEAL";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionPipedriveAddDealParams;
}

export interface FlowActionPipedriveAddDealParams {
    connection_id: string;
    title: string;
    value?: string;
    user_id?: Management.FlowActionPipedriveAddDealParamsUserId;
    person_id?: Management.FlowActionPipedriveAddDealParamsPersonId;
    organization_id?: Management.FlowActionPipedriveAddDealParamsOrganizationId;
    stage_id?: Management.FlowActionPipedriveAddDealParamsStageId;
    fields?: Management.FlowActionPipedriveAddDealParamsFields;
}

export type FlowActionPipedriveAddDealParamsFields = Record<string, unknown>;

export type FlowActionPipedriveAddDealParamsOrganizationId = string | number;

export type FlowActionPipedriveAddDealParamsPersonId = string | number;

export type FlowActionPipedriveAddDealParamsStageId = string | number;

export type FlowActionPipedriveAddDealParamsUserId = string | number;

export interface FlowActionPipedriveAddOrganization {
    id: string;
    alias?: string;
    type: "PIPEDRIVE";
    action: "ADD_ORGANIZATION";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionPipedriveAddOrganizationParams;
}

export interface FlowActionPipedriveAddOrganizationParams {
    connection_id: string;
    name: string;
    owner_id?: Management.FlowActionPipedriveAddOrganizationParamsOwnerId;
    fields?: Management.FlowActionPipedriveAddOrganizationParamsFields;
}

export type FlowActionPipedriveAddOrganizationParamsFields = Record<string, unknown>;

export type FlowActionPipedriveAddOrganizationParamsOwnerId = string | number;

export interface FlowActionPipedriveAddPerson {
    id: string;
    alias?: string;
    type: "PIPEDRIVE";
    action: "ADD_PERSON";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionPipedriveAddPersonParams;
}

export interface FlowActionPipedriveAddPersonParams {
    connection_id: string;
    name: string;
    email?: string;
    phone?: string;
    owner_id?: Management.FlowActionPipedriveAddPersonParamsOwnerId;
    organization_id?: Management.FlowActionPipedriveAddPersonParamsOrganizationId;
    fields?: Management.FlowActionPipedriveAddPersonParamsFields;
}

export type FlowActionPipedriveAddPersonParamsFields = Record<string, unknown>;

export type FlowActionPipedriveAddPersonParamsOrganizationId = string | number;

export type FlowActionPipedriveAddPersonParamsOwnerId = string | number;

export type FlowActionSalesforce =
    | Management.FlowActionSalesforceCreateLead
    | Management.FlowActionSalesforceGetLead
    | Management.FlowActionSalesforceSearchLeads
    | Management.FlowActionSalesforceUpdateLead;

export interface FlowActionSalesforceCreateLead {
    id: string;
    alias?: string;
    type: "SALESFORCE";
    action: "CREATE_LEAD";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionSalesforceCreateLeadParams;
}

export interface FlowActionSalesforceCreateLeadParams {
    connection_id: string;
    first_name?: string;
    last_name: string;
    company: string;
    email?: string;
    phone?: string;
    payload?: Management.FlowActionSalesforceCreateLeadParamsPayload;
}

export type FlowActionSalesforceCreateLeadParamsPayload = Record<string, unknown>;

export interface FlowActionSalesforceGetLead {
    id: string;
    alias?: string;
    type: "SALESFORCE";
    action: "GET_LEAD";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionSalesforceGetLeadParams;
}

export interface FlowActionSalesforceGetLeadParams {
    connection_id: string;
    lead_id: string;
}

export interface FlowActionSalesforceSearchLeads {
    id: string;
    alias?: string;
    type: "SALESFORCE";
    action: "SEARCH_LEADS";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionSalesforceSearchLeadsParams;
}

export interface FlowActionSalesforceSearchLeadsParams {
    connection_id: string;
    search_field: FlowActionSalesforceSearchLeadsParams.SearchField;
    search_value: string;
    lead_fields: string[];
}

export namespace FlowActionSalesforceSearchLeadsParams {
    export const SearchField = {
        Email: "email",
        Name: "name",
        Phone: "phone",
        All: "all",
    } as const;
    export type SearchField = (typeof SearchField)[keyof typeof SearchField];
}

export interface FlowActionSalesforceUpdateLead {
    id: string;
    alias?: string;
    type: "SALESFORCE";
    action: "UPDATE_LEAD";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionSalesforceUpdateLeadParams;
}

export interface FlowActionSalesforceUpdateLeadParams {
    connection_id: string;
    lead_id: string;
    payload?: Management.FlowActionSalesforceUpdateLeadParamsPayload;
}

export type FlowActionSalesforceUpdateLeadParamsPayload = Record<string, unknown>;

export type FlowActionSendgrid = Management.FlowActionSendgridSendEmail;

export interface FlowActionSendgridSendEmail {
    id: string;
    alias?: string;
    type: "SENDGRID";
    action: "SEND_EMAIL";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionSendgridSendEmailParams;
}

export interface FlowActionSendgridSendEmailParams {
    connection_id: string;
    from: Management.FlowActionSendgridSendEmailParamsPerson;
    personalizations: unknown[];
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface FlowActionSendgridSendEmailParamsPerson {
    name?: string;
    email: string;
}

export type FlowActionSlack = Management.FlowActionSlackPostMessage;

export interface FlowActionSlackPostMessage {
    id: string;
    alias?: string;
    type: "SLACK";
    action: "POST_MESSAGE";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionSlackPostMessageParams;
}

export interface FlowActionSlackPostMessageParams {
    connection_id: string;
    text?: string;
    attachments?: Management.FlowActionSlackPostMessageParamsAttachment[];
}

export interface FlowActionSlackPostMessageParamsAttachment {
    color?: FlowActionSlackPostMessageParamsAttachment.Color;
    pretext?: string;
    text?: string;
    fields?: Management.FlowActionSlackPostMessageParamsAttachmentField[];
}

export namespace FlowActionSlackPostMessageParamsAttachment {
    export const Color = {
        Good: "GOOD",
        Warning: "WARNING",
        Danger: "DANGER",
    } as const;
    export type Color = (typeof Color)[keyof typeof Color];
}

export interface FlowActionSlackPostMessageParamsAttachmentField {
    title: string;
    value?: string;
    short?: boolean;
}

export type FlowActionStripe =
    | Management.FlowActionStripeAddTaxId
    | Management.FlowActionStripeCreateCustomer
    | Management.FlowActionStripeCreatePortalSession
    | Management.FlowActionStripeDeleteTaxId
    | Management.FlowActionStripeFindCustomers
    | Management.FlowActionStripeGetCustomer
    | Management.FlowActionStripeUpdateCustomer;

export interface FlowActionStripeAddTaxId {
    id: string;
    alias?: string;
    type: "STRIPE";
    action: "ADD_TAX_ID";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionStripeAddTaxIdParams;
}

export interface FlowActionStripeAddTaxIdParams {
    connection_id: string;
    customer_id: string;
    type: string;
    value: string;
}

export interface FlowActionStripeAddress {
    line1?: string;
    line2?: string;
    postalCode?: string;
    city?: string;
    state?: string;
    country?: string;
}

export interface FlowActionStripeCreateCustomer {
    id: string;
    alias?: string;
    type: "STRIPE";
    action: "CREATE_CUSTOMER";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionStripeCreateCustomerParams;
}

export interface FlowActionStripeCreateCustomerParams {
    connection_id: string;
    tax_id?: Management.FlowActionStripeTaxId;
    name?: string;
    description?: string;
    email?: string;
    phone?: string;
    tax_exempt?: string;
    address?: Management.FlowActionStripeAddress;
    metadata?: Management.FlowActionStripeMetadata;
}

export interface FlowActionStripeCreatePortalSession {
    id: string;
    alias?: string;
    type: "STRIPE";
    action: "CREATE_PORTAL_SESSION";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionStripeCreatePortalSessionParams;
}

export interface FlowActionStripeCreatePortalSessionParams {
    connection_id: string;
    customer_id: string;
    return_url?: string;
}

export interface FlowActionStripeDeleteTaxId {
    id: string;
    alias?: string;
    type: "STRIPE";
    action: "DELETE_TAX_ID";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionStripeDeleteTaxIdParams;
}

export interface FlowActionStripeDeleteTaxIdParams {
    connection_id: string;
    customer_id: string;
    id: string;
}

export interface FlowActionStripeFindCustomers {
    id: string;
    alias?: string;
    type: "STRIPE";
    action: "FIND_CUSTOMERS";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionStripeFindCustomersParams;
}

export interface FlowActionStripeFindCustomersParams {
    connection_id: string;
    email: string;
}

export interface FlowActionStripeGetCustomer {
    id: string;
    alias?: string;
    type: "STRIPE";
    action: "GET_CUSTOMER";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionStripeGetCustomerParams;
}

export interface FlowActionStripeGetCustomerParams {
    connection_id: string;
    id: string;
}

export type FlowActionStripeMetadata = Record<string, string>;

export interface FlowActionStripeTaxId {
    type: string;
    value: string;
}

export interface FlowActionStripeUpdateCustomer {
    id: string;
    alias?: string;
    type: "STRIPE";
    action: "UPDATE_CUSTOMER";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionStripeUpdateCustomerParams;
}

export interface FlowActionStripeUpdateCustomerParams {
    connection_id: string;
    id: string;
    name?: string;
    description?: string;
    email?: string;
    phone?: string;
    tax_exempt?: string;
    address?: Management.FlowActionStripeAddress;
    metadata?: Management.FlowActionStripeMetadata;
}

export type FlowActionTelegram = Management.FlowActionTelegramSendMessage;

export interface FlowActionTelegramSendMessage {
    id: string;
    alias?: string;
    type: "TELEGRAM";
    action: "SEND_MESSAGE";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionTelegramSendMessageParams;
}

export interface FlowActionTelegramSendMessageParams {
    connection_id: string;
    chat_id: string;
    text: string;
}

export type FlowActionTwilio = Management.FlowActionTwilioMakeCall | Management.FlowActionTwilioSendSms;

export interface FlowActionTwilioMakeCall {
    id: string;
    alias?: string;
    type: "TWILIO";
    action: "MAKE_CALL";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionTwilioMakeCallParams;
}

export interface FlowActionTwilioMakeCallParams {
    connection_id: string;
    from: string;
    to: string;
    payload: string;
}

export interface FlowActionTwilioSendSms {
    id: string;
    alias?: string;
    type: "TWILIO";
    action: "SEND_SMS";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionTwilioSendSmsParams;
}

export interface FlowActionTwilioSendSmsParams {
    connection_id: string;
    from: string;
    to: string;
    message: string;
}

export type FlowActionWhatsapp = Management.FlowActionWhatsappSendMessage;

export interface FlowActionWhatsappSendMessage {
    id: string;
    alias?: string;
    type: "WHATSAPP";
    action: "SEND_MESSAGE";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionWhatsappSendMessageParams;
}

export interface FlowActionWhatsappSendMessageParams {
    connection_id: string;
    sender_id: string;
    recipient_number: string;
    type: FlowActionWhatsappSendMessageParams.Type;
    payload: Management.FlowActionWhatsappSendMessageParamsPayload;
}

export namespace FlowActionWhatsappSendMessageParams {
    export const Type = {
        Audio: "AUDIO",
        Contacts: "CONTACTS",
        Document: "DOCUMENT",
        Image: "IMAGE",
        Interactive: "INTERACTIVE",
        Location: "LOCATION",
        Sticker: "STICKER",
        Template: "TEMPLATE",
        Text: "TEXT",
    } as const;
    export type Type = (typeof Type)[keyof typeof Type];
}

export type FlowActionWhatsappSendMessageParamsPayload =
    | Management.FlowActionWhatsappSendMessageParamsPayloadObject
    | string;

export type FlowActionWhatsappSendMessageParamsPayloadObject = Record<string, unknown>;

export type FlowActionXml = Management.FlowActionXmlParseXml | Management.FlowActionXmlSerializeXml;

export interface FlowActionXmlParseXml {
    id: string;
    alias?: string;
    type: "XML";
    action: "PARSE_XML";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionXmlParseXmlParams;
}

export interface FlowActionXmlParseXmlParams {
    xml: string;
}

export interface FlowActionXmlSerializeXml {
    id: string;
    alias?: string;
    type: "XML";
    action: "SERIALIZE_XML";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionXmlSerializeXmlParams;
}

export interface FlowActionXmlSerializeXmlParams {
    object: Management.FlowActionXmlSerializeXmlParamsObject;
}

export type FlowActionXmlSerializeXmlParamsObject = string | Management.FlowActionXmlSerializeXmlParamsObjectObject;

export type FlowActionXmlSerializeXmlParamsObjectObject = Record<string, unknown>;

export type FlowActionZapier = Management.FlowActionZapierTriggerWebhook;

export interface FlowActionZapierTriggerWebhook {
    id: string;
    alias?: string;
    type: "ZAPIER";
    action: "TRIGGER_WEBHOOK";
    allow_failure?: boolean;
    mask_output?: boolean;
    params: Management.FlowActionZapierTriggerWebhookParams;
}

export interface FlowActionZapierTriggerWebhookParams {
    connection_id: string;
    method?: FlowActionZapierTriggerWebhookParams.Method;
    /** Accepts any additional properties */
    [key: string]: any;
}

export namespace FlowActionZapierTriggerWebhookParams {
    export const Method = {
        Get: "GET",
        Post: "POST",
        Put: "PUT",
    } as const;
    export type Method = (typeof Method)[keyof typeof Method];
}

/**
 * Flow execution debug.
 */
export type FlowExecutionDebug = Record<string, unknown>;

export interface FlowExecutionSummary {
    /** Flow execution identifier */
    id: string;
    /** Trace id */
    trace_id: string;
    /** Journey id */
    journey_id?: string;
    /** Execution status */
    status: string;
    /** The ISO 8601 formatted date when this flow execution was created. */
    created_at: string;
    /** The ISO 8601 formatted date when this flow execution was updated. */
    updated_at: string;
    /** The ISO 8601 formatted date when this flow execution started. */
    started_at?: string;
    /** The ISO 8601 formatted date when this flow execution ended. */
    ended_at?: string;
}

export interface FlowSummary {
    id: string;
    name: string;
    created_at: string;
    updated_at: string;
    executed_at?: string;
}

export interface FlowsVaultConnectioSetupApiKey {
    type: Management.FlowsVaultConnectioSetupTypeApiKeyEnum;
    api_key: string;
}

export interface FlowsVaultConnectioSetupApiKeyWithBaseUrl {
    type: Management.FlowsVaultConnectioSetupTypeApiKeyEnum;
    api_key: string;
    base_url: string;
}

export interface FlowsVaultConnectioSetupBigqueryOauthJwt {
    type?: Management.FlowsVaultConnectioSetupTypeOauthJwtEnum;
    project_id?: string;
    private_key?: string;
    client_email?: string;
}

export interface FlowsVaultConnectioSetupHttpBearer {
    type: Management.FlowsVaultConnectioSetupTypeBearerEnum;
    token: string;
}

export interface FlowsVaultConnectioSetupJwt {
    type: Management.FlowsVaultConnectioSetupTypeJwtEnum;
    algorithm: Management.FlowsVaultConnectioSetupJwtAlgorithmEnum;
    /** Accepts any additional properties */
    [key: string]: any;
}

export const FlowsVaultConnectioSetupJwtAlgorithmEnum = {
    Hs256: "HS256",
    Hs384: "HS384",
    Hs512: "HS512",
    Rs256: "RS256",
    Rs384: "RS384",
    Rs512: "RS512",
    Es256: "ES256",
    Es384: "ES384",
    Es512: "ES512",
    Ps256: "PS256",
    Ps384: "PS384",
    Ps512: "PS512",
} as const;
export type FlowsVaultConnectioSetupJwtAlgorithmEnum =
    (typeof FlowsVaultConnectioSetupJwtAlgorithmEnum)[keyof typeof FlowsVaultConnectioSetupJwtAlgorithmEnum];

export interface FlowsVaultConnectioSetupMailjetApiKey {
    type: Management.FlowsVaultConnectioSetupTypeApiKeyEnum;
    api_key: string;
    secret_key: string;
}

export interface FlowsVaultConnectioSetupOauthApp {
    type: Management.FlowsVaultConnectioSetupTypeOauthAppEnum;
    client_id: string;
    client_secret: string;
    domain: string;
    audience?: string;
}

export interface FlowsVaultConnectioSetupOauthCode {
    type?: Management.FlowsVaultConnectioSetupTypeOauthCodeEnum;
    code?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface FlowsVaultConnectioSetupSecretApiKey {
    type: Management.FlowsVaultConnectioSetupTypeApiKeyEnum;
    secret_key: string;
}

export interface FlowsVaultConnectioSetupStripeKeyPair {
    type: Management.FlowsVaultConnectioSetupTypeKeyPairEnum;
    private_key: string;
    public_key: string;
}

export interface FlowsVaultConnectioSetupToken {
    type: Management.FlowsVaultConnectioSetupTypeTokenEnum;
    token: string;
}

export interface FlowsVaultConnectioSetupTwilioApiKey {
    type: Management.FlowsVaultConnectioSetupTypeApiKeyEnum;
    account_id: string;
    api_key: string;
}

export type FlowsVaultConnectioSetupTypeApiKeyEnum = "API_KEY";

export type FlowsVaultConnectioSetupTypeBearerEnum = "BEARER";

export type FlowsVaultConnectioSetupTypeJwtEnum = "JWT";

export type FlowsVaultConnectioSetupTypeKeyPairEnum = "KEY_PAIR";

export type FlowsVaultConnectioSetupTypeOauthAppEnum = "OAUTH_APP";

export type FlowsVaultConnectioSetupTypeOauthCodeEnum = "OAUTH_CODE";

export type FlowsVaultConnectioSetupTypeOauthJwtEnum = "OAUTH_JWT";

export type FlowsVaultConnectioSetupTypeTokenEnum = "TOKEN";

export type FlowsVaultConnectioSetupTypeWebhookEnum = "WEBHOOK";

export interface FlowsVaultConnectioSetupWebhook {
    type: Management.FlowsVaultConnectioSetupTypeWebhookEnum;
    url: string;
}

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdActivecampaignEnum = "ACTIVECAMPAIGN";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdAirtableEnum = "AIRTABLE";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdAuth0Enum = "AUTH0";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdBigqueryEnum = "BIGQUERY";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdClearbitEnum = "CLEARBIT";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdDocusignEnum = "DOCUSIGN";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdGoogleSheetsEnum = "GOOGLE_SHEETS";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdHttpEnum = "HTTP";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdHubspotEnum = "HUBSPOT";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdJwtEnum = "JWT";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdMailchimpEnum = "MAILCHIMP";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdMailjetEnum = "MAILJET";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdPipedriveEnum = "PIPEDRIVE";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdSalesforceEnum = "SALESFORCE";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdSendgridEnum = "SENDGRID";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdSlackEnum = "SLACK";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdStripeEnum = "STRIPE";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdTelegramEnum = "TELEGRAM";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdTwilioEnum = "TWILIO";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdWhatsappEnum = "WHATSAPP";

/**
 * Flows Vault Connection app identifier.
 */
export type FlowsVaultConnectionAppIdZapierEnum = "ZAPIER";

export interface FlowsVaultConnectionSummary {
    /** Flows Vault Connection identifier. */
    id: string;
    /** Flows Vault Connection app identifier. */
    app_id: string;
    /** Flows Vault Connection name. */
    name: string;
    /** Flows Vault Connection custom account name. */
    account_name?: string;
    /** Whether the Flows Vault Connection is configured. */
    ready: boolean;
    /** The ISO 8601 formatted date when this Flows Vault Connection was created. */
    created_at: string;
    /** The ISO 8601 formatted date when this Flows Vault Connection was updated. */
    updated_at: string;
    /** The ISO 8601 formatted date when this Flows Vault Connection was refreshed. */
    refreshed_at?: string;
    fingerprint: string;
}

export type FormBlock =
    | Management.FormBlockDivider
    | Management.FormBlockHtml
    | Management.FormBlockImage
    | Management.FormBlockJumpButton
    | Management.FormBlockResendButton
    | Management.FormBlockNextButton
    | Management.FormBlockPreviousButton
    | Management.FormBlockRichText;

export interface FormBlockDivider {
    id: string;
    category: Management.FormComponentCategoryBlockConst;
    type: Management.FormBlockTypeDividerConst;
    config?: Management.FormBlockDividerConfig;
}

export interface FormBlockDividerConfig {
    text?: string;
}

export interface FormBlockHtml {
    id: string;
    category: Management.FormComponentCategoryBlockConst;
    type: Management.FormBlockTypeHtmlConst;
    config?: Management.FormBlockHtmlConfig;
}

export interface FormBlockHtmlConfig {
    content?: string;
}

export interface FormBlockImage {
    id: string;
    category: Management.FormComponentCategoryBlockConst;
    type: Management.FormBlockTypeImageConst;
    config?: Management.FormBlockImageConfig;
}

export interface FormBlockImageConfig {
    src: string;
    position?: Management.FormBlockImageConfigPositionEnum;
    height?: number;
}

export const FormBlockImageConfigPositionEnum = {
    Left: "LEFT",
    Center: "CENTER",
    Right: "RIGHT",
} as const;
export type FormBlockImageConfigPositionEnum =
    (typeof FormBlockImageConfigPositionEnum)[keyof typeof FormBlockImageConfigPositionEnum];

export interface FormBlockJumpButton {
    id: string;
    category: Management.FormComponentCategoryBlockConst;
    type: Management.FormBlockTypeJumpButtonConst;
    config: Management.FormBlockJumpButtonConfig;
}

export interface FormBlockJumpButtonConfig {
    text: string;
    next_node: Management.FormNodePointer;
    style?: Management.FormBlockJumpButtonConfigStyle;
}

export interface FormBlockJumpButtonConfigStyle {
    background_color?: string;
}

export interface FormBlockNextButton {
    id: string;
    category: Management.FormComponentCategoryBlockConst;
    type: Management.FormBlockTypeNextButtonConst;
    config: Management.FormBlockNextButtonConfig;
}

export interface FormBlockNextButtonConfig {
    text: string;
}

export interface FormBlockPreviousButton {
    id: string;
    category: Management.FormComponentCategoryBlockConst;
    type: Management.FormBlockTypePreviousButtonConst;
    config: Management.FormBlockPreviousButtonConfig;
}

export interface FormBlockPreviousButtonConfig {
    text: string;
}

export interface FormBlockResendButton {
    id: string;
    category: Management.FormComponentCategoryBlockConst;
    type: Management.FormBlockTypeResendButtonConst;
    config: Management.FormBlockResendButtonConfig;
}

export interface FormBlockResendButtonConfig {
    active_text: string;
    button_text: string;
    waiting_text: string;
    text_alignment?: Management.FormBlockResendButtonConfigTextAlignmentEnum;
    flow_id: string;
    max_attempts?: number;
    waiting_time?: number;
}

export const FormBlockResendButtonConfigTextAlignmentEnum = {
    Left: "LEFT",
    Center: "CENTER",
    Right: "RIGHT",
} as const;
export type FormBlockResendButtonConfigTextAlignmentEnum =
    (typeof FormBlockResendButtonConfigTextAlignmentEnum)[keyof typeof FormBlockResendButtonConfigTextAlignmentEnum];

export interface FormBlockRichText {
    id: string;
    category: Management.FormComponentCategoryBlockConst;
    type: Management.FormBlockTypeRichTextConst;
    config?: Management.FormBlockRichTextConfig;
}

export interface FormBlockRichTextConfig {
    content?: string;
}

export type FormBlockTypeDividerConst = "DIVIDER";

export type FormBlockTypeHtmlConst = "HTML";

export type FormBlockTypeImageConst = "IMAGE";

export type FormBlockTypeJumpButtonConst = "JUMP_BUTTON";

export type FormBlockTypeNextButtonConst = "NEXT_BUTTON";

export type FormBlockTypePreviousButtonConst = "PREVIOUS_BUTTON";

export type FormBlockTypeResendButtonConst = "RESEND_BUTTON";

export type FormBlockTypeRichTextConst = "RICH_TEXT";

export type FormComponent = Management.FormBlock | Management.FormWidget | Management.FormField;

export type FormComponentCategoryBlockConst = "BLOCK";

export type FormComponentCategoryFieldConst = "FIELD";

export type FormComponentCategoryWidgetConst = "WIDGET";

export interface FormEndingNode {
    redirection?: Management.FormEndingNodeRedirection;
    after_submit?: Management.FormEndingNodeAfterSubmit;
    coordinates?: Management.FormNodeCoordinates;
    resume_flow?: Management.FormEndingNodeResumeFlowTrueConst;
}

export interface FormEndingNodeAfterSubmit {
    flow_id?: string;
}

export type FormEndingNodeId = "$ending";

export type FormEndingNodeNullable = (Management.FormEndingNode | null) | undefined;

export interface FormEndingNodeRedirection {
    delay?: number;
    target: string;
}

export type FormEndingNodeResumeFlowTrueConst = boolean;

export type FormField =
    | Management.FormFieldBoolean
    | Management.FormFieldCards
    | Management.FormFieldChoice
    | Management.FormFieldCustom
    | Management.FormFieldDate
    | Management.FormFieldDropdown
    | Management.FormFieldEmail
    | Management.FormFieldFile
    | Management.FormFieldLegal
    | Management.FormFieldNumber
    | Management.FormFieldPassword
    | Management.FormFieldPayment
    | Management.FormFieldSocial
    | Management.FormFieldTel
    | Management.FormFieldText
    | Management.FormFieldUrl;

export interface FormFieldBoolean {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeBooleanConst;
    config: Management.FormFieldBooleanConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldBooleanConfig {
    default_value?: boolean;
    options?: Management.FormFieldBooleanConfigOptions;
}

export interface FormFieldBooleanConfigOptions {
    true?: string;
    false?: string;
}

export interface FormFieldCards {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeCardsConst;
    config?: Management.FormFieldCardsConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldCardsConfig {
    hide_labels?: boolean;
    multiple?: boolean;
    options?: Management.FormFieldCardsConfigOption[];
}

export interface FormFieldCardsConfigOption {
    value: string;
    label: string;
    image_url: string;
}

export interface FormFieldChoice {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeChoiceConst;
    config?: Management.FormFieldChoiceConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldChoiceConfig {
    multiple?: boolean;
    options?: Management.FormFieldChoiceConfigOption[];
    allow_other?: Management.FormFieldChoiceConfigAllowOther;
}

export interface FormFieldChoiceConfigAllowOther {
    enabled?: Management.FormFieldChoiceConfigAllowOtherEnabledTrueEnum;
    label?: string;
    placeholder?: string;
}

export type FormFieldChoiceConfigAllowOtherEnabledTrueEnum = boolean;

export interface FormFieldChoiceConfigOption {
    value: string;
    label: string;
}

export interface FormFieldCustom {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeCustomConst;
    config: Management.FormFieldCustomConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldCustomConfig {
    schema: Management.FormFieldCustomConfigSchema;
    code: string;
    css?: string;
    params?: Management.FormFieldCustomConfigParams;
}

export type FormFieldCustomConfigParams = Record<string, string>;

export type FormFieldCustomConfigSchema = Record<string, unknown>;

export interface FormFieldDate {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeDateConst;
    config: Management.FormFieldDateConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldDateConfig {
    format?: Management.FormFieldDateConfigFormatEnum;
    default_value?: string;
}

export const FormFieldDateConfigFormatEnum = {
    Date: "DATE",
    Time: "TIME",
} as const;
export type FormFieldDateConfigFormatEnum =
    (typeof FormFieldDateConfigFormatEnum)[keyof typeof FormFieldDateConfigFormatEnum];

export interface FormFieldDropdown {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeDropdownConst;
    config?: Management.FormFieldDropdownConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldDropdownConfig {
    multiple?: boolean;
    options?: Management.FormFieldDropdownConfigOption[];
    placeholder?: string;
}

export interface FormFieldDropdownConfigOption {
    value: string;
    label: string;
}

export interface FormFieldEmail {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeEmailConst;
    config?: Management.FormFieldEmailConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldEmailConfig {
    default_value?: string;
    placeholder?: string;
}

export interface FormFieldFile {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeFileConst;
    config?: Management.FormFieldFileConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldFileConfig {
    multiple?: boolean;
    storage?: Management.FormFieldFileConfigStorage;
    categories?: Management.FormFieldFileConfigCategoryEnum[];
    extensions?: string[];
    maxSize?: number;
    maxFiles?: number;
}

export const FormFieldFileConfigCategoryEnum = {
    Audio: "AUDIO",
    Video: "VIDEO",
    Image: "IMAGE",
    Document: "DOCUMENT",
    Archive: "ARCHIVE",
} as const;
export type FormFieldFileConfigCategoryEnum =
    (typeof FormFieldFileConfigCategoryEnum)[keyof typeof FormFieldFileConfigCategoryEnum];

export interface FormFieldFileConfigStorage {
    type: Management.FormFieldFileConfigStorageTypeEnum;
    /** Accepts any additional properties */
    [key: string]: any;
}

export const FormFieldFileConfigStorageTypeEnum = {
    Managed: "MANAGED",
    Custom: "CUSTOM",
} as const;
export type FormFieldFileConfigStorageTypeEnum =
    (typeof FormFieldFileConfigStorageTypeEnum)[keyof typeof FormFieldFileConfigStorageTypeEnum];

export interface FormFieldLegal {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeLegalConst;
    config?: Management.FormFieldLegalConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldLegalConfig {
    text?: string;
}

export interface FormFieldNumber {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeNumberConst;
    config?: Management.FormFieldNumberConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldNumberConfig {
    default_value?: number;
    placeholder?: string;
    min_value?: number;
    max_value?: number;
}

export interface FormFieldPassword {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypePasswordConst;
    config: Management.FormFieldPasswordConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldPasswordConfig {
    hash?: Management.FormFieldPasswordConfigHashEnum;
    placeholder?: string;
    min_length?: number;
    max_length?: number;
    complexity?: boolean;
    nist?: boolean;
    strength_meter?: boolean;
}

export const FormFieldPasswordConfigHashEnum = {
    None: "NONE",
    Md5: "MD5",
    Sha1: "SHA1",
    Sha256: "SHA256",
    Sha512: "SHA512",
} as const;
export type FormFieldPasswordConfigHashEnum =
    (typeof FormFieldPasswordConfigHashEnum)[keyof typeof FormFieldPasswordConfigHashEnum];

export interface FormFieldPayment {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypePaymentConst;
    config: Management.FormFieldPaymentConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldPaymentConfig {
    provider?: Management.FormFieldPaymentConfigProviderEnum;
    charge: Management.FormFieldPaymentConfigCharge;
    credentials: Management.FormFieldPaymentConfigCredentials;
    customer?: Management.FormFieldPaymentConfigCustomer;
    fields?: Management.FormFieldPaymentConfigFields;
}

export type FormFieldPaymentConfigCharge =
    | Management.FormFieldPaymentConfigChargeOneOff
    | {
          type: Management.FormFieldPaymentConfigChargeTypeSubscriptionConst;
          subscription: Management.FormFieldPaymentConfigSubscription;
      };

export interface FormFieldPaymentConfigChargeOneOff {
    type: Management.FormFieldPaymentConfigChargeTypeOneOffConst;
    one_off: Management.FormFieldPaymentConfigChargeOneOffOneOff;
}

export const FormFieldPaymentConfigChargeOneOffCurrencyEnum = {
    Aud: "AUD",
    Cad: "CAD",
    Chf: "CHF",
    Eur: "EUR",
    Gbp: "GBP",
    Inr: "INR",
    Mxn: "MXN",
    Sek: "SEK",
    Usd: "USD",
} as const;
export type FormFieldPaymentConfigChargeOneOffCurrencyEnum =
    (typeof FormFieldPaymentConfigChargeOneOffCurrencyEnum)[keyof typeof FormFieldPaymentConfigChargeOneOffCurrencyEnum];

export interface FormFieldPaymentConfigChargeOneOffOneOff {
    amount: Management.FormFieldPaymentConfigChargeOneOffOneOffAmount;
    currency: Management.FormFieldPaymentConfigChargeOneOffCurrencyEnum;
    /** Accepts any additional properties */
    [key: string]: any;
}

export type FormFieldPaymentConfigChargeOneOffOneOffAmount = string | number;

export type FormFieldPaymentConfigChargeTypeOneOffConst = "ONE_OFF";

export type FormFieldPaymentConfigChargeTypeSubscriptionConst = "SUBSCRIPTION";

export interface FormFieldPaymentConfigCredentials {
    public_key: string;
    private_key: string;
}

export type FormFieldPaymentConfigCustomer = Record<string, unknown>;

export interface FormFieldPaymentConfigFieldProperties {
    label?: string;
    placeholder?: string;
}

export interface FormFieldPaymentConfigFields {
    card_number?: Management.FormFieldPaymentConfigFieldProperties;
    expiration_date?: Management.FormFieldPaymentConfigFieldProperties;
    security_code?: Management.FormFieldPaymentConfigFieldProperties;
    trustmarks?: boolean;
}

export type FormFieldPaymentConfigProviderEnum = "STRIPE";

export type FormFieldPaymentConfigSubscription = Record<string, unknown>;

export interface FormFieldSocial {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeSocialConst;
    config?: Management.FormFieldSocialConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldSocialConfig {}

export interface FormFieldTel {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeTelConst;
    config?: Management.FormFieldTelConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldTelConfig {
    default_value?: string;
    placeholder?: string;
    min_length?: number;
    max_length?: number;
    country_picker?: boolean;
    strings?: Management.FormFieldTelConfigStrings;
}

export interface FormFieldTelConfigStrings {
    filter_placeholder?: string;
}

export interface FormFieldText {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeTextConst;
    config?: Management.FormFieldTextConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldTextConfig {
    multiline?: boolean;
    default_value?: string;
    placeholder?: string;
    min_length?: number;
    max_length?: number;
}

export type FormFieldTypeBooleanConst = "BOOLEAN";

export type FormFieldTypeCardsConst = "CARDS";

export type FormFieldTypeChoiceConst = "CHOICE";

export type FormFieldTypeCustomConst = "CUSTOM";

export type FormFieldTypeDateConst = "DATE";

export type FormFieldTypeDropdownConst = "DROPDOWN";

export type FormFieldTypeEmailConst = "EMAIL";

export type FormFieldTypeFileConst = "FILE";

export type FormFieldTypeLegalConst = "LEGAL";

export type FormFieldTypeNumberConst = "NUMBER";

export type FormFieldTypePasswordConst = "PASSWORD";

export type FormFieldTypePaymentConst = "PAYMENT";

export type FormFieldTypeSocialConst = "SOCIAL";

export type FormFieldTypeTelConst = "TEL";

export type FormFieldTypeTextConst = "TEXT";

export type FormFieldTypeUrlConst = "URL";

export interface FormFieldUrl {
    id: string;
    category: Management.FormComponentCategoryFieldConst;
    type: Management.FormFieldTypeUrlConst;
    config?: Management.FormFieldUrlConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormFieldUrlConfig {
    default_value?: string;
    placeholder?: string;
}

export interface FormFlow {
    id: string;
    type: Management.FormNodeTypeFlowConst;
    coordinates?: Management.FormNodeCoordinates;
    alias?: string;
    config: Management.FormFlowConfig;
}

export interface FormFlowConfig {
    flow_id: string;
    next_node?: Management.FormNodePointer;
}

export interface FormHiddenField {
    key: string;
    value?: string;
}

export interface FormLanguages {
    primary?: string;
    default?: string;
}

export type FormLanguagesNullable = (Management.FormLanguages | null) | undefined;

export interface FormMessages {
    errors?: Management.FormMessagesError;
    custom?: Management.FormMessagesCustom;
}

export type FormMessagesCustom = Record<string, string>;

export type FormMessagesError = Record<string, string>;

export type FormMessagesNullable = (Management.FormMessages | null) | undefined;

export type FormNode = Management.FormFlow | Management.FormRouter | Management.FormStep;

export interface FormNodeCoordinates {
    x: number;
    y: number;
}

export type FormNodeList = Management.FormNode[];

export type FormNodeListNullable = (Management.FormNodeList | null) | undefined;

export type FormNodePointer = string | Management.FormEndingNodeId;

export type FormNodeTypeFlowConst = "FLOW";

export type FormNodeTypeRouterConst = "ROUTER";

export type FormNodeTypeStepConst = "STEP";

export interface FormRouter {
    id: string;
    type: Management.FormNodeTypeRouterConst;
    coordinates?: Management.FormNodeCoordinates;
    alias?: string;
    config?: Management.FormRouterConfig;
}

export interface FormRouterConfig {
    rules?: Management.FormRouterRule[];
    fallback?: Management.FormNodePointer;
}

export interface FormRouterRule {
    id: string;
    alias?: string;
    next_node?: Management.FormNodePointer;
}

export interface FormStartNode {
    hidden_fields?: Management.FormHiddenField[];
    next_node?: Management.FormNodePointer;
    coordinates?: Management.FormNodeCoordinates;
}

export type FormStartNodeNullable = (Management.FormStartNode | null) | undefined;

export interface FormStep {
    id: string;
    type: Management.FormNodeTypeStepConst;
    coordinates?: Management.FormNodeCoordinates;
    alias?: string;
    config?: Management.FormStepConfig;
}

export type FormStepComponentList = Management.FormComponent[];

export interface FormStepConfig {
    components?: Management.FormStepComponentList;
    next_node?: Management.FormNodePointer;
}

export interface FormStyle {
    css?: string;
}

export type FormStyleNullable = (Management.FormStyle | null) | undefined;

export interface FormSummary {
    id: string;
    name: string;
    created_at: string;
    updated_at: string;
    embedded_at?: string;
    submitted_at?: string;
}

export type FormTranslations = Record<string, Record<string, unknown>>;

export type FormTranslationsNullable = (Management.FormTranslations | null) | undefined;

export type FormWidget =
    | Management.FormWidgetAuth0VerifiableCredentials
    | Management.FormWidgetGMapsAddress
    | Management.FormWidgetRecaptcha;

export interface FormWidgetAuth0VerifiableCredentials {
    id: string;
    category: Management.FormComponentCategoryWidgetConst;
    type: Management.FormWidgetTypeAuth0VerifiableCredentialsConst;
    config: Management.FormWidgetAuth0VerifiableCredentialsConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormWidgetAuth0VerifiableCredentialsConfig {
    url: string;
    size?: number;
    alternate_text: string;
    access_token: string;
    verification_id: string;
    max_wait?: number;
}

export interface FormWidgetGMapsAddress {
    id: string;
    category: Management.FormComponentCategoryWidgetConst;
    type: Management.FormWidgetTypeGMapsAddressConst;
    config: Management.FormWidgetGMapsAddressConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormWidgetGMapsAddressConfig {
    api_key: string;
}

export interface FormWidgetRecaptcha {
    id: string;
    category: Management.FormComponentCategoryWidgetConst;
    type: Management.FormWidgetTypeRecaptchaConst;
    config: Management.FormWidgetRecaptchaConfig;
    label?: string;
    hint?: string;
    required?: boolean;
    sensitive?: boolean;
}

export interface FormWidgetRecaptchaConfig {
    site_key: string;
    secret_key: string;
}

export type FormWidgetTypeAuth0VerifiableCredentialsConst = "AUTH0_VERIFIABLE_CREDENTIALS";

export type FormWidgetTypeGMapsAddressConst = "GMAPS_ADDRESS";

export type FormWidgetTypeRecaptchaConst = "RECAPTCHA";

export const FormsRequestParametersHydrateEnum = {
    FlowCount: "flow_count",
    Links: "links",
} as const;
export type FormsRequestParametersHydrateEnum =
    (typeof FormsRequestParametersHydrateEnum)[keyof typeof FormsRequestParametersHydrateEnum];

/**
 * The result of a specific execution of a trigger.
 */
export interface GetActionExecutionResponseContent {
    /** ID identifies this specific execution simulation. These IDs would resemble real executions in production. */
    id?: string;
    trigger_id?: Management.ActionTriggerTypeEnum;
    status?: Management.ActionExecutionStatusEnum;
    results?: Management.ActionExecutionResult[];
    /** The time that the execution was started. */
    created_at?: string;
    /** The time that the exeution finished executing. */
    updated_at?: string;
}

export interface GetActionResponseContent {
    /** The unique ID of the action. */
    id?: string;
    /** The name of an action. */
    name?: string;
    /** The list of triggers that this action supports. At this time, an action can only target a single trigger at a time. */
    supported_triggers?: Management.ActionTrigger[];
    /** True if all of an Action's contents have been deployed. */
    all_changes_deployed?: boolean;
    /** The time when this action was created. */
    created_at?: string;
    /** The time when this action was updated. */
    updated_at?: string;
    /** The source code of the action. */
    code?: string;
    /** The list of third party npm modules, and their versions, that this action depends on. */
    dependencies?: Management.ActionVersionDependency[];
    /** The Node runtime. For example: `node22`, defaults to `node22` */
    runtime?: string;
    /** The list of secrets that are included in an action or a version of an action. */
    secrets?: Management.ActionSecretResponse[];
    deployed_version?: Management.ActionDeployedVersion;
    /** installed_integration_id is the fk reference to the InstalledIntegration entity. */
    installed_integration_id?: string;
    integration?: Management.Integration;
    status?: Management.ActionBuildStatusEnum;
    /** The time when this action was built successfully. */
    built_at?: string;
    /** True if the action should be deployed after creation. */
    deploy?: boolean;
}

export interface GetActionVersionResponseContent {
    /** The unique id of an action version. */
    id?: string;
    /** The id of the action to which this version belongs. */
    action_id?: string;
    /** The source code of this specific version of the action. */
    code?: string;
    /** The list of third party npm modules, and their versions, that this specific version depends on. */
    dependencies?: Management.ActionVersionDependency[];
    /** Indicates if this specific version is the currently one deployed. */
    deployed?: boolean;
    /** The Node runtime. For example: `node22` */
    runtime?: string;
    /** The list of secrets that are included in an action or a version of an action. */
    secrets?: Management.ActionSecretResponse[];
    status?: Management.ActionVersionBuildStatusEnum;
    /** The index of this version in list of versions for the action. */
    number?: number;
    /** Any errors that occurred while the version was being built. */
    errors?: Management.ActionError[];
    action?: Management.ActionBase;
    /** The time when this version was built successfully. */
    built_at?: string;
    /** The time when this version was created. */
    created_at?: string;
    /** The time when a version was updated. Versions are never updated externally. Only Auth0 will update an action version as it is being built. */
    updated_at?: string;
    /** The list of triggers that this version supports. At this time, a version can only target a single trigger at a time. */
    supported_triggers?: Management.ActionTrigger[];
}

/**
 * Number of active users in the last 30 days.
 */
export type GetActiveUsersCountStatsResponseContent = number;

export interface GetAculResponseContent {
    /** Tenant ID */
    tenant?: string;
    /** Name of the prompt */
    prompt?: string;
    /** Name of the screen */
    screen?: string;
    rendering_mode?: Management.AculRenderingModeEnum;
    /** Context values to make available */
    context_configuration?: string[];
    /** Override Universal Login default head tags */
    default_head_tags_disabled?: boolean;
    /** An array of head tags */
    head_tags?: Management.AculHeadTag[];
    filters?: Management.AculFilters | null;
    /** Use page template with ACUL */
    use_page_template?: boolean | null;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetAttackProtectionCaptchaResponseContent {
    active_provider_id?: string;
    arkose?: Management.AttackProtectionCaptchaArkoseResponseContent;
    auth_challenge?: Management.AttackProtectionCaptchaAuthChallengeResponseContent;
    hcaptcha?: Management.AttackProtectionCaptchaHcaptchaResponseContent;
    friendly_captcha?: Management.AttackProtectionCaptchaFriendlyCaptchaResponseContent;
    recaptcha_enterprise?: Management.AttackProtectionCaptchaRecaptchaEnterpriseResponseContent;
    recaptcha_v2?: Management.AttackProtectionCaptchaRecaptchaV2ResponseContent;
    simple_captcha?: Management.AttackProtectionCaptchaSimpleCaptchaResponseContent;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetBotDetectionSettingsResponseContent {
    bot_detection_level: Management.BotDetectionLevelEnum;
    challenge_password_policy: Management.BotDetectionChallengePolicyPasswordFlowEnum;
    challenge_passwordless_policy: Management.BotDetectionChallengePolicyPasswordlessFlowEnum;
    challenge_password_reset_policy: Management.BotDetectionChallengePolicyPasswordResetFlowEnum;
    allowlist: Management.BotDetectionAllowlist;
    monitoring_mode_enabled: Management.BotDetectionMonitoringModeEnabled;
}

export interface GetBrandingDefaultThemeResponseContent {
    borders: Management.BrandingThemeBorders;
    colors: Management.BrandingThemeColors;
    /** Display Name */
    displayName: string;
    fonts: Management.BrandingThemeFonts;
    page_background: Management.BrandingThemePageBackground;
    /** Theme Id */
    themeId: string;
    widget: Management.BrandingThemeWidget;
}

/**
 * Phone provider configuration schema
 */
export interface GetBrandingPhoneProviderResponseContent {
    id?: string;
    /** The name of the tenant */
    tenant?: string;
    name: Management.PhoneProviderNameEnum;
    channel?: Management.PhoneProviderChannelEnum;
    /** Whether the provider is enabled (false) or disabled (true). */
    disabled?: boolean;
    configuration?: Management.PhoneProviderConfiguration;
    /** The provider's creation date and time in ISO 8601 format */
    created_at?: string;
    /** The date and time of the last update to the provider in ISO 8601 format */
    updated_at?: string;
}

export interface GetBrandingResponseContent {
    colors?: Management.BrandingColors;
    /** URL for the favicon. Must use HTTPS. */
    favicon_url?: string;
    /** URL for the logo. Must use HTTPS. */
    logo_url?: string;
    font?: Management.BrandingFont;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetBrandingThemeResponseContent {
    borders: Management.BrandingThemeBorders;
    colors: Management.BrandingThemeColors;
    /** Display Name */
    displayName: string;
    fonts: Management.BrandingThemeFonts;
    page_background: Management.BrandingThemePageBackground;
    /** Theme Id */
    themeId: string;
    widget: Management.BrandingThemeWidget;
}

export interface GetBreachedPasswordDetectionSettingsResponseContent {
    /** Whether or not breached password detection is active. */
    enabled?: boolean;
    /**
     * Action to take when a breached password is detected during a login.
     *       Possible values: <code>block</code>, <code>user_notification</code>, <code>admin_notification</code>.
     */
    shields?: Management.BreachedPasswordDetectionShieldsEnum[];
    /**
     * When "admin_notification" is enabled, determines how often email notifications are sent.
     *         Possible values: <code>immediately</code>, <code>daily</code>, <code>weekly</code>, <code>monthly</code>.
     */
    admin_notification_frequency?: Management.BreachedPasswordDetectionAdminNotificationFrequencyEnum[];
    method?: Management.BreachedPasswordDetectionMethodEnum;
    stage?: Management.BreachedPasswordDetectionStage;
}

export interface GetBruteForceSettingsResponseContent {
    /** Whether or not brute force attack protections are active. */
    enabled?: boolean;
    /**
     * Action to take when a brute force protection threshold is violated.
     *         Possible values: <code>block</code>, <code>user_notification</code>.
     */
    shields?: GetBruteForceSettingsResponseContent.Shields.Item[];
    /** List of trusted IP addresses that will not have attack protection enforced against them. */
    allowlist?: string[];
    /**
     * Account Lockout: Determines whether or not IP address is used when counting failed attempts.
     *           Possible values: <code>count_per_identifier_and_ip</code>, <code>count_per_identifier</code>.
     */
    mode?: GetBruteForceSettingsResponseContent.Mode;
    /** Maximum number of unsuccessful attempts. */
    max_attempts?: number;
}

export namespace GetBruteForceSettingsResponseContent {
    export type Shields = Shields.Item[];

    export namespace Shields {
        export const Item = {
            Block: "block",
            UserNotification: "user_notification",
        } as const;
        export type Item = (typeof Item)[keyof typeof Item];
    }

    /**
     * Account Lockout: Determines whether or not IP address is used when counting failed attempts.
     *           Possible values: <code>count_per_identifier_and_ip</code>, <code>count_per_identifier</code>.
     */
    export const Mode = {
        CountPerIdentifierAndIp: "count_per_identifier_and_ip",
        CountPerIdentifier: "count_per_identifier",
    } as const;
    export type Mode = (typeof Mode)[keyof typeof Mode];
}

export interface GetClientCredentialResponseContent {
    /** ID of the credential. Generated on creation. */
    id?: string;
    /** The name given to the credential by the user. */
    name?: string;
    /** The key identifier of the credential, generated on creation. */
    kid?: string;
    alg?: Management.ClientCredentialAlgorithmEnum;
    credential_type?: Management.ClientCredentialTypeEnum;
    /** The X509 certificate's Subject Distinguished Name */
    subject_dn?: string;
    /** The X509 certificate's SHA256 thumbprint */
    thumbprint_sha256?: string;
    /** The ISO 8601 formatted date the credential was created. */
    created_at?: string;
    /** The ISO 8601 formatted date the credential was updated. */
    updated_at?: string;
    /** The ISO 8601 formatted date representing the expiration of the credential. */
    expires_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetClientResponseContent {
    /** ID of this client. */
    client_id?: string;
    /** Name of the tenant this client belongs to. */
    tenant?: string;
    /** Name of this client (min length: 1 character, does not allow `<` or `>`). */
    name?: string;
    /** Free text description of this client (max length: 140 characters). */
    description?: string;
    /** Whether this is your global 'All Applications' client representing legacy tenant settings (true) or a regular client (false). */
    global?: boolean;
    /** Client secret (which you must not make public). */
    client_secret?: string;
    app_type?: Management.ClientAppTypeEnum;
    /** URL of the logo to display for this client. Recommended size is 150x150 pixels. */
    logo_uri?: string;
    /** Whether this client a first party client (true) or not (false). */
    is_first_party?: boolean;
    /** Whether this client conforms to <a href='https://auth0.com/docs/api-auth/tutorials/adoption'>strict OIDC specifications</a> (true) or uses legacy features (false). */
    oidc_conformant?: boolean;
    /** Comma-separated list of URLs whitelisted for Auth0 to use as a callback to the client after authentication. */
    callbacks?: string[];
    /** Comma-separated list of URLs allowed to make requests from JavaScript to Auth0 API (typically used with CORS). By default, all your callback URLs will be allowed. This field allows you to enter other origins if necessary. You can also use wildcards at the subdomain level (e.g., https://*.contoso.com). Query strings and hash information are not taken into account when validating these URLs. */
    allowed_origins?: string[];
    /** Comma-separated list of allowed origins for use with <a href='https://auth0.com/docs/cross-origin-authentication'>Cross-Origin Authentication</a>, <a href='https://auth0.com/docs/flows/concepts/device-auth'>Device Flow</a>, and <a href='https://auth0.com/docs/protocols/oauth2#how-response-mode-works'>web message response mode</a>. */
    web_origins?: string[];
    /** List of audiences/realms for SAML protocol. Used by the wsfed addon. */
    client_aliases?: string[];
    /** List of allow clients and API ids that are allowed to make delegation requests. Empty means all all your clients are allowed. */
    allowed_clients?: string[];
    /** Comma-separated list of URLs that are valid to redirect to after logout from Auth0. Wildcards are allowed for subdomains. */
    allowed_logout_urls?: string[];
    session_transfer?: Management.ClientSessionTransferConfiguration | null;
    oidc_logout?: Management.ClientOidcBackchannelLogoutSettings;
    /** List of grant types supported for this application. Can include `authorization_code`, `implicit`, `refresh_token`, `client_credentials`, `password`, `http://auth0.com/oauth/grant-type/password-realm`, `http://auth0.com/oauth/grant-type/mfa-oob`, `http://auth0.com/oauth/grant-type/mfa-otp`, `http://auth0.com/oauth/grant-type/mfa-recovery-code`, `urn:openid:params:grant-type:ciba`, `urn:ietf:params:oauth:grant-type:device_code`, and `urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token`. */
    grant_types?: string[];
    jwt_configuration?: Management.ClientJwtConfiguration;
    signing_keys?: Management.ClientSigningKeys;
    encryption_key?: Management.ClientEncryptionKey | null;
    /** Applies only to SSO clients and determines whether Auth0 will handle Single Sign On (true) or whether the Identity Provider will (false). */
    sso?: boolean;
    /** Whether Single Sign On is disabled (true) or enabled (true). Defaults to true. */
    sso_disabled?: boolean;
    /** Whether this client can be used to make cross-origin authentication requests (true) or it is not allowed to make such requests (false). */
    cross_origin_authentication?: boolean;
    /** URL of the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page. */
    cross_origin_loc?: string;
    /** Whether a custom login page is to be used (true) or the default provided login page (false). */
    custom_login_page_on?: boolean;
    /** The content (HTML, CSS, JS) of the custom login page. */
    custom_login_page?: string;
    /** The content (HTML, CSS, JS) of the custom login page. (Used on Previews) */
    custom_login_page_preview?: string;
    /** HTML form template to be used for WS-Federation. */
    form_template?: string;
    addons?: Management.ClientAddons;
    token_endpoint_auth_method?: Management.ClientTokenEndpointAuthMethodEnum;
    /** If true, trust that the IP specified in the `auth0-forwarded-for` header is the end-user's IP for brute-force-protection on token endpoint. */
    is_token_endpoint_ip_header_trusted?: boolean;
    client_metadata?: Management.ClientMetadata;
    mobile?: Management.ClientMobile;
    /** Initiate login uri, must be https */
    initiate_login_uri?: string;
    refresh_token?: Management.ClientRefreshTokenConfiguration | null;
    default_organization?: Management.ClientDefaultOrganization | null;
    organization_usage?: Management.ClientOrganizationUsageEnum;
    organization_require_behavior?: Management.ClientOrganizationRequireBehaviorEnum;
    /** Defines the available methods for organization discovery during the `pre_login_prompt`. Users can discover their organization either by `email`, `organization_name` or both. */
    organization_discovery_methods?: Management.ClientOrganizationDiscoveryEnum[];
    client_authentication_methods?: Management.ClientAuthenticationMethod | null;
    /** Makes the use of Pushed Authorization Requests mandatory for this client */
    require_pushed_authorization_requests?: boolean;
    /** Makes the use of Proof-of-Possession mandatory for this client */
    require_proof_of_possession?: boolean;
    signed_request_object?: Management.ClientSignedRequestObjectWithCredentialId;
    compliance_level?: Management.ClientComplianceLevelEnum | null;
    /**
     * Controls whether a confirmation prompt is shown during login flows when the redirect URI uses non-verifiable callback URIs (for example, a custom URI schema such as `myapp://`, or `localhost`).
     * If set to true, a confirmation prompt will not be shown. We recommend that this is set to false for improved protection from malicious apps.
     * See https://auth0.com/docs/secure/security-guidance/measures-against-app-impersonation for more information.
     */
    skip_non_verifiable_callback_uri_confirmation_prompt?: boolean;
    /** Specifies how long, in seconds, a Pushed Authorization Request URI remains valid */
    par_request_expiry?: number | null;
    token_quota?: Management.TokenQuota;
    express_configuration?: Management.ExpressConfiguration;
    /** The identifier of the resource server that this client is linked to. */
    resource_server_identifier?: string;
    async_approval_notification_channels?: Management.ClientAsyncApprovalNotificationsChannelsApiPostConfiguration;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetConnectionEnabledClientsResponseContent {
    /** Clients for which the connection is enabled */
    clients: Management.ConnectionEnabledClient[];
    /** Encoded next token */
    next?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetConnectionProfileResponseContent {
    id?: Management.ConnectionProfileId;
    name?: Management.ConnectionProfileName;
    organization?: Management.ConnectionProfileOrganization;
    connection_name_prefix_template?: Management.ConnectionNamePrefixTemplate;
    enabled_features?: Management.ConnectionProfileEnabledFeatures;
    connection_config?: Management.ConnectionProfileConfig;
    strategy_overrides?: Management.ConnectionProfileStrategyOverrides;
}

export interface GetConnectionProfileTemplateResponseContent {
    /** The id of the template. */
    id?: string;
    /** The user-friendly name of the template displayed in the UI. */
    display_name?: string;
    template?: Management.ConnectionProfileTemplate;
}

export interface GetConnectionResponseContent {
    /** The name of the connection */
    name?: string;
    /** Connection name used in login screen */
    display_name?: string;
    options?: Management.ConnectionOptions;
    /** The connection's identifier */
    id?: string;
    /** The type of the connection, related to the identity provider */
    strategy?: string;
    /** Defines the realms for which the connection will be used (ie: email domains). If the array is empty or the property is not specified, the connection name will be added as realm. */
    realms?: string[];
    /** DEPRECATED property. Use the GET /connections/:id/clients endpoint to get the ids of the clients for which the connection is enabled */
    enabled_clients?: string[];
    /** True if the connection is domain level */
    is_domain_connection?: boolean;
    /** Enables showing a button for the connection in the login page (new experience only). If false, it will be usable only by HRD. */
    show_as_button?: boolean;
    metadata?: Management.ConnectionsMetadata;
    authentication?: Management.ConnectionAuthenticationPurpose;
    connected_accounts?: Management.ConnectionConnectedAccountsPurpose;
}

export interface GetCustomDomainResponseContent {
    /** ID of the custom domain. */
    custom_domain_id: string;
    /** Domain name. */
    domain: string;
    /** Whether this is a primary domain (true) or not (false). */
    primary: boolean;
    status: Management.CustomDomainStatusFilterEnum;
    type: Management.CustomDomainTypeEnum;
    /** Intermediate address. */
    origin_domain_name?: string;
    verification?: Management.DomainVerification;
    /** The HTTP header to fetch the client's IP address */
    custom_client_ip_header?: string | null;
    /** The TLS version policy */
    tls_policy?: string;
    certificate?: Management.DomainCertificate;
}

/**
 * JWKS representing an array of custom public signing keys.
 */
export interface GetCustomSigningKeysResponseContent {
    /** An array of custom public signing keys. */
    keys?: Management.CustomSigningKeyJwk[];
}

/**
 * An object containing custom dictionaries for a group of screens.
 */
export type GetCustomTextsByLanguageResponseContent = Record<string, unknown>;

export interface GetEmailProviderResponseContent {
    /** Name of the email provider. Can be `mailgun`, `mandrill`, `sendgrid`, `ses`, `sparkpost`, `smtp`, `azure_cs`, `ms365`, or `custom`. */
    name?: string;
    /** Whether the provider is enabled (true) or disabled (false). */
    enabled?: boolean;
    /** Email address to use as "from" when no other address specified. */
    default_from_address?: string;
    credentials?: Management.EmailProviderCredentials;
    settings?: Management.EmailProviderSettings;
}

export interface GetEmailTemplateResponseContent {
    template?: Management.EmailTemplateNameEnum;
    /** Body of the email template. */
    body?: string | null;
    /** Senders `from` email address. */
    from?: string | null;
    /** URL to redirect the user to after a successful action. */
    resultUrl?: string | null;
    /** Subject line of the email. */
    subject?: string | null;
    /** Syntax of the template body. */
    syntax?: string | null;
    /** Lifetime in seconds that the link within the email will be valid for. */
    urlLifetimeInSeconds?: number | null;
    /** Whether the `reset_email` and `verify_email` templates should include the user's email address as the `email` parameter in the returnUrl (true) or whether no email address should be included in the redirect (false). Defaults to true. */
    includeEmailInRedirect?: boolean;
    /** Whether the template is enabled (true) or disabled (false). */
    enabled?: boolean | null;
}

/**
 * Encryption key
 */
export interface GetEncryptionKeyResponseContent {
    /** Key ID */
    kid: string;
    type: Management.EncryptionKeyType;
    state: Management.EncryptionKeyState;
    /** Key creation timestamp */
    created_at: string;
    /** Key update timestamp */
    updated_at: string;
    /** ID of parent wrapping key */
    parent_kid: string;
    /** Public key in PEM format */
    public_key?: string;
}

/**
 * Metadata about a specific attempt to deliver an event
 */
export interface GetEventStreamDeliveryHistoryResponseContent {
    /** Unique identifier for the delivery */
    id: string;
    /** Unique identifier for the event stream. */
    event_stream_id: string;
    status: Management.EventStreamDeliveryStatusEnum;
    event_type: Management.EventStreamDeliveryEventTypeEnum;
    /** Results of delivery attempts */
    attempts: Management.EventStreamDeliveryAttempt[];
    event?: Management.EventStreamCloudEvent;
}

export type GetEventStreamResponseContent =
    | Management.EventStreamWebhookResponseContent
    | Management.EventStreamEventBridgeResponseContent
    | Management.EventStreamActionResponseContent;

export interface GetFlowExecutionResponseContent {
    /** Flow execution identifier */
    id: string;
    /** Trace id */
    trace_id: string;
    /** Journey id */
    journey_id?: string;
    /** Execution status */
    status: string;
    debug?: Management.FlowExecutionDebug;
    /** The ISO 8601 formatted date when this flow execution was created. */
    created_at: string;
    /** The ISO 8601 formatted date when this flow execution was updated. */
    updated_at: string;
    /** The ISO 8601 formatted date when this flow execution started. */
    started_at?: string;
    /** The ISO 8601 formatted date when this flow execution ended. */
    ended_at?: string;
}

export const GetFlowRequestParametersHydrateEnum = {
    FormCount: "form_count",
    Forms: "forms",
} as const;
export type GetFlowRequestParametersHydrateEnum =
    (typeof GetFlowRequestParametersHydrateEnum)[keyof typeof GetFlowRequestParametersHydrateEnum];

export interface GetFlowResponseContent {
    id: string;
    name: string;
    actions?: Management.FlowAction[];
    created_at: string;
    updated_at: string;
    executed_at?: string;
}

export interface GetFlowsVaultConnectionResponseContent {
    /** Flows Vault Connection identifier. */
    id: string;
    /** Flows Vault Connection app identifier. */
    app_id: string;
    /** Flows Vault Connection environment. */
    environment?: string;
    /** Flows Vault Connection name. */
    name: string;
    /** Flows Vault Connection custom account name. */
    account_name?: string;
    /** Whether the Flows Vault Connection is configured. */
    ready: boolean;
    /** The ISO 8601 formatted date when this Flows Vault Connection was created. */
    created_at: string;
    /** The ISO 8601 formatted date when this Flows Vault Connection was updated. */
    updated_at: string;
    /** The ISO 8601 formatted date when this Flows Vault Connection was refreshed. */
    refreshed_at?: string;
    fingerprint: string;
}

export interface GetFormResponseContent {
    id: string;
    name: string;
    messages?: Management.FormMessages;
    languages?: Management.FormLanguages;
    translations?: Management.FormTranslations;
    nodes?: Management.FormNodeList;
    start?: Management.FormStartNode;
    ending?: Management.FormEndingNode;
    style?: Management.FormStyle;
    created_at: string;
    updated_at: string;
    embedded_at?: string;
    submitted_at?: string;
}

export interface GetGuardianEnrollmentResponseContent {
    /** ID for this enrollment. */
    id: string;
    status?: Management.GuardianEnrollmentStatus;
    /** Device name (only for push notification). */
    name?: string;
    /** Device identifier. This is usually the phone identifier. */
    identifier?: string;
    /** Phone number. */
    phone_number?: string;
    enrolled_at?: Management.GuardianEnrollmentDate;
    last_auth?: Management.GuardianEnrollmentDate;
}

export interface GetGuardianFactorDuoSettingsResponseContent {
    ikey?: string;
    skey?: string;
    host?: string;
}

export interface GetGuardianFactorPhoneMessageTypesResponseContent {
    /** The list of phone factors to enable on the tenant. Can include `sms` and `voice`. */
    message_types?: Management.GuardianFactorPhoneFactorMessageTypeEnum[];
}

export interface GetGuardianFactorPhoneTemplatesResponseContent {
    /** Message sent to the user when they are invited to enroll with a phone number. */
    enrollment_message: string;
    /** Message sent to the user when they are prompted to verify their account. */
    verification_message: string;
}

export interface GetGuardianFactorSmsTemplatesResponseContent {
    /** Message sent to the user when they are invited to enroll with a phone number. */
    enrollment_message: string;
    /** Message sent to the user when they are prompted to verify their account. */
    verification_message: string;
}

export interface GetGuardianFactorsProviderApnsResponseContent {
    bundle_id?: string | null;
    sandbox?: boolean;
    enabled?: boolean;
}

export interface GetGuardianFactorsProviderPhoneResponseContent {
    provider?: Management.GuardianFactorsProviderSmsProviderEnum;
}

export interface GetGuardianFactorsProviderPhoneTwilioResponseContent {
    /** From number */
    from?: string | null;
    /** Copilot SID */
    messaging_service_sid?: string | null;
    /** Twilio Authentication token */
    auth_token?: string | null;
    /** Twilio SID */
    sid?: string | null;
}

export interface GetGuardianFactorsProviderPushNotificationResponseContent {
    provider?: Management.GuardianFactorsProviderPushNotificationProviderDataEnum;
}

export interface GetGuardianFactorsProviderSmsResponseContent {
    provider?: Management.GuardianFactorsProviderSmsProviderEnum;
}

export interface GetGuardianFactorsProviderSmsTwilioResponseContent {
    /** From number */
    from?: string | null;
    /** Copilot SID */
    messaging_service_sid?: string | null;
    /** Twilio Authentication token */
    auth_token?: string | null;
    /** Twilio SID */
    sid?: string | null;
}

export interface GetGuardianFactorsProviderSnsResponseContent {
    aws_access_key_id?: string | null;
    aws_secret_access_key?: string | null;
    aws_region?: string | null;
    sns_apns_platform_application_arn?: string | null;
    sns_gcm_platform_application_arn?: string | null;
}

export interface GetHookResponseContent {
    /** Trigger ID */
    triggerId?: string;
    /** ID of this hook. */
    id?: string;
    /** Name of this hook. */
    name?: string;
    /** Whether this hook will be executed (true) or ignored (false). */
    enabled?: boolean;
    /** Code to be executed when this hook runs. */
    script?: string;
    dependencies?: Management.HookDependencies;
}

/**
 * Hashmap of key-value pairs where the value must be a string.
 */
export type GetHookSecretResponseContent = Record<string, string>;

export interface GetJobErrorResponseContent {
    user?: Management.GetJobUserError;
    /** Errors importing the user. */
    errors?: Management.GetJobImportUserError[];
}

export interface GetJobGenericErrorResponseContent {
    /** Status of this job. */
    status: string;
    /** Type of job this is. */
    type: string;
    /** When this job was created. */
    created_at?: string;
    /** ID of this job. */
    id: string;
    /** connection_id of the connection this job uses. */
    connection_id?: string;
    /** Status details. */
    status_details?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetJobImportUserError {
    /** Error code. */
    code?: string;
    /** Error message. */
    message?: string;
    /** Error field. */
    path?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetJobResponseContent {
    /** Status of this job. */
    status: string;
    /** Type of job this is. */
    type: string;
    /** When this job was created. */
    created_at?: string;
    /** ID of this job. */
    id: string;
    /** connection_id of the connection this job uses. */
    connection_id?: string;
    /** URL to download the result of this job. */
    location?: string;
    /** Completion percentage of this job. */
    percentage_done?: number;
    /** Estimated time remaining before job completes. */
    time_left_seconds?: number;
    format?: Management.JobFileFormatEnum;
    /** Status details. */
    status_details?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * User, as provided in the import file
 */
export type GetJobUserError = Record<string, unknown>;

export interface GetLogResponseContent {
    date?: Management.LogDate;
    /** Type of event. */
    type?: string;
    /** Description of this event. */
    description?: string | null;
    /** Name of the connection the event relates to. */
    connection?: string;
    /** ID of the connection the event relates to. */
    connection_id?: string;
    /** ID of the client (application). */
    client_id?: string;
    /** Name of the client (application). */
    client_name?: string;
    /** IP address of the log event source. */
    ip?: string;
    /** Hostname the event applies to. */
    hostname?: string;
    /** ID of the user involved in the event. */
    user_id?: string;
    /** Name of the user involved in the event. */
    user_name?: string;
    /** API audience the event applies to. */
    audience?: string;
    /** Scope permissions applied to the event. */
    scope?: string;
    /** Name of the strategy involved in the event. */
    strategy?: string;
    /** Type of strategy involved in the event. */
    strategy_type?: string;
    /** Unique ID of the event. */
    log_id?: string;
    /** Whether the client was a mobile device (true) or desktop/laptop/server (false). */
    isMobile?: boolean;
    details?: Management.LogDetails;
    /** User agent string from the client device that caused the event. */
    user_agent?: string;
    security_context?: Management.LogSecurityContext;
    location_info?: Management.LogLocationInfo;
    /** Accepts any additional properties */
    [key: string]: any;
}

export type GetLogStreamResponseContent =
    | Management.LogStreamHttpResponseSchema
    | Management.LogStreamEventBridgeResponseSchema
    | Management.LogStreamEventGridResponseSchema
    | Management.LogStreamDatadogResponseSchema
    | Management.LogStreamSplunkResponseSchema
    | Management.LogStreamSumoResponseSchema
    | Management.LogStreamSegmentResponseSchema
    | Management.LogStreamMixpanelResponseSchema;

export interface GetNetworkAclsResponseContent {
    id?: string;
    description?: string;
    active?: boolean;
    priority?: number;
    rule?: Management.NetworkAclRule;
    /** The timestamp when the Network ACL Configuration was created */
    created_at?: string;
    /** The timestamp when the Network ACL Configuration was last updated */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetOrganizationByNameResponseContent {
    /** Organization identifier. */
    id?: string;
    /** The name of this organization. */
    name?: string;
    /** Friendly name of this organization. */
    display_name?: string;
    branding?: Management.OrganizationBranding;
    metadata?: Management.OrganizationMetadata;
    token_quota?: Management.TokenQuota;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetOrganizationConnectionResponseContent {
    /** ID of the connection. */
    connection_id?: string;
    /** When true, all users that log in with this connection will be automatically granted membership in the organization. When false, users must be granted membership in the organization before logging in with this connection. */
    assign_membership_on_login?: boolean;
    /** Determines whether a connection should be displayed on this organizationâ€™s login prompt. Only applicable for enterprise connections. Default: true. */
    show_as_button?: boolean;
    /** Determines whether organization signup should be enabled for this organization connection. Only applicable for database connections. Default: false. */
    is_signup_enabled?: boolean;
    connection?: Management.OrganizationConnectionInformation;
}

export interface GetOrganizationDiscoveryDomainResponseContent {
    /** Organization discovery domain identifier. */
    id: string;
    /** The domain name to associate with the organization e.g. acme.com. */
    domain: string;
    status: Management.OrganizationDiscoveryDomainStatus;
    /** A unique token generated for the discovery domain. This must be placed in a DNS TXT record at the location specified by the verification_host field to prove domain ownership. */
    verification_txt: string;
    /** The full domain where the TXT record should be added. */
    verification_host: string;
}

export interface GetOrganizationInvitationResponseContent {
    /** The id of the user invitation. */
    id?: string;
    /** Organization identifier. */
    organization_id?: string;
    inviter?: Management.OrganizationInvitationInviter;
    invitee?: Management.OrganizationInvitationInvitee;
    /** The invitation url to be send to the invitee. */
    invitation_url?: string;
    /** The ISO 8601 formatted timestamp representing the creation time of the invitation. */
    created_at?: string;
    /** The ISO 8601 formatted timestamp representing the expiration time of the invitation. */
    expires_at?: string;
    /** Auth0 client ID. Used to resolve the application's login initiation endpoint. */
    client_id?: string;
    /** The id of the connection to force invitee to authenticate with. */
    connection_id?: string;
    app_metadata?: Management.AppMetadata;
    user_metadata?: Management.UserMetadata;
    /** List of roles IDs to associated with the user. */
    roles?: string[];
    /** The id of the invitation ticket */
    ticket_id?: string;
}

export interface GetOrganizationResponseContent {
    /** Organization identifier. */
    id?: string;
    /** The name of this organization. */
    name?: string;
    /** Friendly name of this organization. */
    display_name?: string;
    branding?: Management.OrganizationBranding;
    metadata?: Management.OrganizationMetadata;
    token_quota?: Management.TokenQuota;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * An object containing template partials for a group of screens.
 */
export type GetPartialsResponseContent = Record<string, unknown>;

export interface GetPhoneTemplateResponseContent {
    id: string;
    channel?: string;
    customizable?: boolean;
    tenant?: string;
    content: Management.PhoneTemplateContent;
    type: Management.PhoneTemplateNotificationTypeEnum;
    /** Whether the template is enabled (false) or disabled (true). */
    disabled: boolean;
}

export interface GetRefreshTokenResponseContent {
    /** The ID of the refresh token */
    id?: string;
    /** ID of the user which can be used when interacting with other APIs. */
    user_id?: string;
    created_at?: Management.RefreshTokenDate;
    idle_expires_at?: Management.RefreshTokenDate;
    expires_at?: Management.RefreshTokenDate;
    device?: Management.RefreshTokenDevice;
    /** ID of the client application granted with this refresh token */
    client_id?: string;
    session_id?: (Management.RefreshTokenSessionId | undefined) | null;
    /** True if the token is a rotating refresh token */
    rotating?: boolean;
    /** A list of the resource server IDs associated to this refresh-token and their granted scopes */
    resource_servers?: Management.RefreshTokenResourceServer[];
    last_exchanged_at?: Management.RefreshTokenDate;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetResourceServerResponseContent {
    /** ID of the API (resource server). */
    id?: string;
    /** Friendly name for this resource server. Can not contain `<` or `>` characters. */
    name?: string;
    /** Whether this is an Auth0 system API (true) or a custom API (false). */
    is_system?: boolean;
    /** Unique identifier for the API used as the audience parameter on authorization calls. Can not be changed once set. */
    identifier?: string;
    /** List of permissions (scopes) that this API uses. */
    scopes?: Management.ResourceServerScope[];
    signing_alg?: Management.SigningAlgorithmEnum;
    /** Secret used to sign tokens when using symmetric algorithms (HS256). */
    signing_secret?: string;
    /** Whether refresh tokens can be issued for this API (true) or not (false). */
    allow_offline_access?: boolean;
    /** Whether to skip user consent for applications flagged as first party (true) or not (false). */
    skip_consent_for_verifiable_first_party_clients?: boolean;
    /** Expiration value (in seconds) for access tokens issued for this API from the token endpoint. */
    token_lifetime?: number;
    /** Expiration value (in seconds) for access tokens issued for this API via Implicit or Hybrid Flows. Cannot be greater than the `token_lifetime` value. */
    token_lifetime_for_web?: number;
    /** Whether authorization polices are enforced (true) or unenforced (false). */
    enforce_policies?: boolean;
    token_dialect?: Management.ResourceServerTokenDialectResponseEnum;
    token_encryption?: Management.ResourceServerTokenEncryption | null;
    consent_policy?: (Management.ResourceServerConsentPolicyEnum | undefined) | null;
    authorization_details?: unknown[];
    proof_of_possession?: Management.ResourceServerProofOfPossession | null;
    subject_type_authorization?: Management.ResourceServerSubjectTypeAuthorization;
    /** The client ID of the client that this resource server is linked to */
    client_id?: string;
}

export interface GetRiskAssessmentsSettingsNewDeviceResponseContent {
    /** Length of time to remember devices for, in days. */
    remember_for: number;
}

export interface GetRiskAssessmentsSettingsResponseContent {
    /** Whether or not risk assessment is enabled. */
    enabled: boolean;
}

export interface GetRoleResponseContent {
    /** ID for this role. */
    id?: string;
    /** Name of this role. */
    name?: string;
    /** Description of this role. */
    description?: string;
}

export interface GetRuleResponseContent {
    /** Name of this rule. */
    name?: string;
    /** ID of this rule. */
    id?: string;
    /** Whether the rule is enabled (true), or disabled (false). */
    enabled?: boolean;
    /** Code to be executed when this rule runs. */
    script?: string;
    /** Order that this rule should execute in relative to other rules. Lower-valued rules execute first. */
    order?: number;
    /** Execution stage of this rule. Can be `login_success`, `login_failure`, or `pre_authorize`. */
    stage?: string;
}

export interface GetScimConfigurationDefaultMappingResponseContent {
    /** The mapping between auth0 and SCIM */
    mapping?: Management.ScimMappingItem[];
}

export interface GetScimConfigurationResponseContent {
    /** The connection's identifier */
    connection_id?: string;
    /** The connection's identifier */
    connection_name?: string;
    /** The connection's strategy */
    strategy?: string;
    /** The tenant's name */
    tenant_name?: string;
    /** User ID attribute for generating unique user ids */
    user_id_attribute?: string;
    /** The mapping between auth0 and SCIM */
    mapping?: Management.ScimMappingItem[];
    /** The Date Time Scim Configuration was created */
    created_at?: string;
    /** The Date Time Scim Configuration was last updated */
    updated_on?: string;
}

/**
 * The list of scim tokens for scim clients
 */
export type GetScimTokensResponseContent = Management.ScimTokenItem[];

export interface GetSelfServiceProfileResponseContent {
    /** The unique ID of the self-service Profile. */
    id?: string;
    /** The name of the self-service Profile. */
    name?: string;
    /** The description of the self-service Profile. */
    description?: string;
    /** List of attributes to be mapped that will be shown to the user during the SS-SSO flow. */
    user_attributes?: Management.SelfServiceProfileUserAttribute[];
    /** The time when this self-service Profile was created. */
    created_at?: string;
    /** The time when this self-service Profile was updated. */
    updated_at?: string;
    branding?: Management.SelfServiceProfileBrandingProperties;
    /** List of IdP strategies that will be shown to users during the Self-Service SSO flow. Possible values: [`oidc`, `samlp`, `waad`, `google-apps`, `adfs`, `okta`, `keycloak-samlp`, `pingfederate`] */
    allowed_strategies?: Management.SelfServiceProfileAllowedStrategyEnum[];
    /** ID of the user-attribute-profile to associate with this self-service profile. */
    user_attribute_profile_id?: string;
}

export interface GetSessionResponseContent {
    /** The ID of the session */
    id?: string;
    /** ID of the user which can be used when interacting with other APIs. */
    user_id?: string;
    created_at?: Management.SessionDate;
    updated_at?: Management.SessionDate;
    authenticated_at?: Management.SessionDate;
    idle_expires_at?: Management.SessionDate;
    expires_at?: Management.SessionDate;
    last_interacted_at?: Management.SessionDate;
    device?: Management.SessionDeviceMetadata;
    /** List of client details for the session */
    clients?: Management.SessionClientMetadata[];
    authentication?: Management.SessionAuthenticationSignals;
    cookie?: Management.SessionCookieMetadata;
    session_metadata?: (Management.SessionMetadata | undefined) | null;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetSettingsResponseContent {
    universal_login_experience?: Management.UniversalLoginExperienceEnum;
    /** Whether identifier first is enabled or not */
    identifier_first?: boolean;
    /** Use WebAuthn with Device Biometrics as the first authentication factor */
    webauthn_platform_first_factor?: boolean;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetSigningKeysResponseContent {
    /** The key id of the signing key */
    kid: string;
    /** The public certificate of the signing key */
    cert: string;
    /** The public certificate of the signing key in pkcs7 format */
    pkcs7?: string;
    /** True if the key is the the current key */
    current?: boolean;
    /** True if the key is the the next key */
    next?: boolean;
    /** True if the key is the the previous key */
    previous?: boolean;
    current_since?: Management.SigningKeysDate;
    current_until?: Management.SigningKeysDate;
    /** The cert fingerprint */
    fingerprint: string;
    /** The cert thumbprint */
    thumbprint: string;
    /** True if the key is revoked */
    revoked?: boolean;
    revoked_at?: Management.SigningKeysDate;
}

export interface GetSupplementalSignalsResponseContent {
    /** Indicates if incoming Akamai Headers should be processed */
    akamai_enabled?: boolean;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetSuspiciousIpThrottlingSettingsResponseContent {
    /** Whether or not suspicious IP throttling attack protections are active. */
    enabled?: boolean;
    /**
     * Action to take when a suspicious IP throttling threshold is violated.
     *           Possible values: <code>block</code>, <code>admin_notification</code>.
     */
    shields?: Management.SuspiciousIpThrottlingShieldsEnum[];
    allowlist?: Management.SuspiciousIpThrottlingAllowlist;
    stage?: Management.SuspiciousIpThrottlingStage;
}

export interface GetTenantSettingsResponseContent {
    change_password?: Management.TenantSettingsPasswordPage | null;
    guardian_mfa_page?: Management.TenantSettingsGuardianPage | null;
    /** Default audience for API authorization. */
    default_audience?: string;
    /** Name of connection used for password grants at the `/token`endpoint. The following connection types are supported: LDAP, AD, Database Connections, Passwordless, Windows Azure Active Directory, ADFS. */
    default_directory?: string;
    error_page?: Management.TenantSettingsErrorPage | null;
    device_flow?: Management.TenantSettingsDeviceFlow | null;
    default_token_quota?: Management.DefaultTokenQuota | null;
    flags?: Management.TenantSettingsFlags;
    /** Friendly name for this tenant. */
    friendly_name?: string;
    /** URL of logo to be shown for this tenant (recommended size: 150x150) */
    picture_url?: string;
    /** End-user support email address. */
    support_email?: string;
    /** End-user support URL. */
    support_url?: string;
    /** URLs that are valid to redirect to after logout from Auth0. */
    allowed_logout_urls?: string[];
    /** Number of hours a session will stay valid. */
    session_lifetime?: number;
    /** Number of hours for which a session can be inactive before the user must log in again. */
    idle_session_lifetime?: number;
    /** Number of hours an ephemeral (non-persistent) session will stay valid. */
    ephemeral_session_lifetime?: number;
    /** Number of hours for which an ephemeral (non-persistent) session can be inactive before the user must log in again. */
    idle_ephemeral_session_lifetime?: number;
    /** Selected sandbox version for the extensibility environment. */
    sandbox_version?: string;
    /** Selected sandbox version for rules and hooks extensibility. */
    legacy_sandbox_version?: string;
    /** Available sandbox versions for the extensibility environment. */
    sandbox_versions_available?: string[];
    /** The default absolute redirection uri, must be https */
    default_redirection_uri?: string;
    /** Supported locales for the user interface. */
    enabled_locales?: Management.SupportedLocales[];
    session_cookie?: Management.SessionCookieSchema | null;
    sessions?: Management.TenantSettingsSessions | null;
    oidc_logout?: Management.TenantOidcLogoutSettings;
    /** Whether to accept an organization name instead of an ID on auth endpoints */
    allow_organization_name_in_authentication_api?: boolean;
    /** Whether to enable flexible factors for MFA in the PostLogin action */
    customize_mfa_in_postlogin_action?: boolean;
    /** Supported ACR values */
    acr_values_supported?: string[];
    mtls?: Management.TenantSettingsMtls | null;
    /** Enables the use of Pushed Authorization Requests */
    pushed_authorization_requests_supported?: boolean;
    /** Supports iss parameter in authorization responses */
    authorization_response_iss_parameter_supported?: boolean | null;
    /**
     * Controls whether a confirmation prompt is shown during login flows when the redirect URI uses non-verifiable callback URIs (for example, a custom URI schema such as `myapp://`, or `localhost`).
     * If set to true, a confirmation prompt will not be shown. We recommend that this is set to false for improved protection from malicious apps.
     * See https://auth0.com/docs/secure/security-guidance/measures-against-app-impersonation for more information.
     */
    skip_non_verifiable_callback_uri_confirmation_prompt?: boolean | null;
    resource_parameter_profile?: Management.TenantSettingsResourceParameterProfile;
}

export interface GetTokenExchangeProfileResponseContent {
    /** The unique ID of the token exchange profile. */
    id?: string;
    /** Friendly name of this profile. */
    name?: string;
    /** Subject token type for this profile. When receiving a token exchange request on the Authentication API, the corresponding token exchange profile with a matching subject_token_type will be executed. This must be a URI. */
    subject_token_type?: string;
    /** The ID of the Custom Token Exchange action to execute for this profile, in order to validate the subject_token. The action must use the custom-token-exchange trigger. */
    action_id?: string;
    type?: Management.TokenExchangeProfileTypeEnum;
    /** The time when this profile was created. */
    created_at?: string;
    /** The time when this profile was updated. */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetUniversalLoginTemplate {
    /** The custom page template for the New Universal Login Experience */
    body?: string;
}

export type GetUniversalLoginTemplateResponseContent =
    | Management.GetUniversalLoginTemplate
    /**
     * The custom page template for the New Universal Login Experience */
    | string;

export interface GetUserAttributeProfileResponseContent {
    id?: Management.UserAttributeProfileId;
    name?: Management.UserAttributeProfileName;
    user_id?: Management.UserAttributeProfileUserId;
    user_attributes?: Management.UserAttributeProfileUserAttributes;
}

export interface GetUserAttributeProfileTemplateResponseContent {
    /** The id of the template. */
    id?: string;
    /** The user-friendly name of the template displayed in the UI. */
    display_name?: string;
    template?: Management.UserAttributeProfileTemplate;
}

export interface GetUserAuthenticationMethodResponseContent {
    /** The ID of the authentication method (auto generated) */
    id: string;
    type: Management.AuthenticationMethodTypeEnum;
    /** The authentication method status */
    confirmed?: boolean;
    /** A human-readable label to identify the authentication method */
    name?: string;
    authentication_methods?: Management.UserAuthenticationMethodProperties[];
    preferred_authentication_method?: Management.PreferredAuthenticationMethodEnum;
    /** The ID of a linked authentication method. Linked authentication methods will be deleted together. */
    link_id?: string;
    /** Applies to phone authentication methods only. The destination phone number used to send verification codes via text and voice. */
    phone_number?: string;
    /** Applies to email and email-verification authentication methods only. The email address used to send verification messages. */
    email?: string;
    /** Applies to webauthn authentication methods only. The ID of the generated credential. */
    key_id?: string;
    /** Applies to webauthn authentication methods only. The public key. */
    public_key?: string;
    /** Authenticator creation date */
    created_at: string;
    /** Enrollment date */
    enrolled_at?: string;
    /** Last authentication */
    last_auth_at?: string;
    /** Applies to passkeys only. The kind of device the credential is stored on as defined by backup eligibility. "single_device" credentials cannot be backed up and synced to another device, "multi_device" credentials can be backed up if enabled by the end-user. */
    credential_device_type?: string;
    /** Applies to passkeys only. Whether the credential was backed up. */
    credential_backed_up?: boolean;
    /** Applies to passkeys only. The ID of the user identity linked with the authentication method. */
    identity_user_id?: string;
    /** Applies to passkeys only. The user-agent of the browser used to create the passkey. */
    user_agent?: string;
    /** Applies to passkey authentication methods only. Authenticator Attestation Globally Unique Identifier. */
    aaguid?: string;
    /** Applies to webauthn/passkey authentication methods only. The credential's relying party identifier. */
    relying_party_identifier?: string;
}

export interface GetUserResponseContent {
    /** ID of the user which can be used when interacting with other APIs. */
    user_id?: string;
    /** Email address of this user. */
    email?: string;
    /** Whether this email address is verified (true) or unverified (false). */
    email_verified?: boolean;
    /** Username of this user. */
    username?: string;
    /** Phone number for this user. Follows the <a href="https://en.wikipedia.org/wiki/E.164">E.164 recommendation</a>. */
    phone_number?: string;
    /** Whether this phone number has been verified (true) or not (false). */
    phone_verified?: boolean;
    created_at?: Management.UserDateSchema;
    updated_at?: Management.UserDateSchema;
    /** Array of user identity objects when accounts are linked. */
    identities?: Management.UserIdentitySchema[];
    app_metadata?: Management.UserAppMetadataSchema;
    user_metadata?: Management.UserMetadataSchema;
    /** URL to picture, photo, or avatar of this user. */
    picture?: string;
    /** Name of this user. */
    name?: string;
    /** Preferred nickname or alias of this user. */
    nickname?: string;
    /** List of multi-factor authentication providers with which this user has enrolled. */
    multifactor?: string[];
    /** Last IP address from which this user logged in. */
    last_ip?: string;
    last_login?: Management.UserDateSchema;
    /** Total number of logins this user has performed. */
    logins_count?: number;
    /** Whether this user was blocked by an administrator (true) or is not (false). */
    blocked?: boolean;
    /** Given name/first name/forename of this user. */
    given_name?: string;
    /** Family name/last name/surname of this user. */
    family_name?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface GetVerifiableCredentialTemplateResponseContent {
    /** The id of the template. */
    id?: string;
    /** The name of the template. */
    name?: string;
    /** The type of the template. */
    type?: string;
    /** The dialect of the template. */
    dialect?: string;
    presentation?: Management.MdlPresentationRequest;
    /** The custom certificate authority. */
    custom_certificate_authority?: string;
    /** The well-known trusted issuers, comma separated. */
    well_known_trusted_issuers?: string;
    /** The date and time the template was created. */
    created_at?: string;
    /** The date and time the template was created. */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Represents the metadata of a group. Member lists are retrieved via a separate endpoint.
 */
export interface Group {
    /** Unique identifier for the group (service-generated). */
    id?: string;
    /** Name of the group. Must be unique within its scope (connection, organization, or tenant). Must contain between 1 and 128 printable ASCII characters. */
    name?: string;
    /** External identifier for the group, often used for SCIM synchronization. Max length of 256 characters. */
    external_id?: string;
    /** Identifier for the connection this group belongs to (if a connection group). */
    connection_id?: string;
    /** Identifier for the organization this group belongs to (if an organization group). */
    organization_id?: string | null;
    /** Identifier for the tenant this group belongs to. */
    tenant_name?: string;
    description?: string | null;
    /** Timestamp of when the group was created. */
    created_at?: string;
    /** Timestamp of when the group was last updated. */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Enrollment date and time.
 */
export type GuardianEnrollmentDate = string;

/** Optional. Specifies which factor the user must enroll with.<br />Note: Parameter can only be used with Universal Login; it cannot be used with Classic Login or custom MFA pages. */
export const GuardianEnrollmentFactorEnum = {
    PushNotification: "push-notification",
    Phone: "phone",
    Email: "email",
    Otp: "otp",
    WebauthnRoaming: "webauthn-roaming",
    WebauthnPlatform: "webauthn-platform",
} as const;
export type GuardianEnrollmentFactorEnum =
    (typeof GuardianEnrollmentFactorEnum)[keyof typeof GuardianEnrollmentFactorEnum];

/** Status of this enrollment. Can be `pending` or `confirmed`. */
export const GuardianEnrollmentStatus = {
    Pending: "pending",
    Confirmed: "confirmed",
} as const;
export type GuardianEnrollmentStatus = (typeof GuardianEnrollmentStatus)[keyof typeof GuardianEnrollmentStatus];

export interface GuardianFactor {
    /** Whether this factor is enabled (true) or disabled (false). */
    enabled: boolean;
    /** Whether trial limits have been exceeded. */
    trial_expired?: boolean;
    name?: Management.GuardianFactorNameEnum;
}

/** Factor name. Can be `sms`, `push-notification`, `email`, `duo` `otp` `webauthn-roaming`, `webauthn-platform`, or `recovery-code`. */
export const GuardianFactorNameEnum = {
    PushNotification: "push-notification",
    Sms: "sms",
    Email: "email",
    Duo: "duo",
    Otp: "otp",
    WebauthnRoaming: "webauthn-roaming",
    WebauthnPlatform: "webauthn-platform",
    RecoveryCode: "recovery-code",
} as const;
export type GuardianFactorNameEnum = (typeof GuardianFactorNameEnum)[keyof typeof GuardianFactorNameEnum];

export const GuardianFactorPhoneFactorMessageTypeEnum = {
    Sms: "sms",
    Voice: "voice",
} as const;
export type GuardianFactorPhoneFactorMessageTypeEnum =
    (typeof GuardianFactorPhoneFactorMessageTypeEnum)[keyof typeof GuardianFactorPhoneFactorMessageTypeEnum];

export const GuardianFactorsProviderPushNotificationProviderDataEnum = {
    Guardian: "guardian",
    Sns: "sns",
    Direct: "direct",
} as const;
export type GuardianFactorsProviderPushNotificationProviderDataEnum =
    (typeof GuardianFactorsProviderPushNotificationProviderDataEnum)[keyof typeof GuardianFactorsProviderPushNotificationProviderDataEnum];

export const GuardianFactorsProviderSmsProviderEnum = {
    Auth0: "auth0",
    Twilio: "twilio",
    PhoneMessageHook: "phone-message-hook",
} as const;
export type GuardianFactorsProviderSmsProviderEnum =
    (typeof GuardianFactorsProviderSmsProviderEnum)[keyof typeof GuardianFactorsProviderSmsProviderEnum];

export interface Hook {
    /** Trigger ID */
    triggerId?: string;
    /** ID of this hook. */
    id?: string;
    /** Name of this hook. */
    name?: string;
    /** Whether this hook will be executed (true) or ignored (false). */
    enabled?: boolean;
    /** Code to be executed when this hook runs. */
    script?: string;
    dependencies?: Management.HookDependencies;
}

/**
 * Dependencies of this hook used by webtask server.
 */
export type HookDependencies = Record<string, string>;

/** Retrieves hooks that match the trigger */
export const HookTriggerIdEnum = {
    CredentialsExchange: "credentials-exchange",
    PreUserRegistration: "pre-user-registration",
    PostUserRegistration: "post-user-registration",
    PostChangePassword: "post-change-password",
    SendPhoneMessage: "send-phone-message",
} as const;
export type HookTriggerIdEnum = (typeof HookTriggerIdEnum)[keyof typeof HookTriggerIdEnum];

export interface HttpCustomHeader {
    /** HTTP header name */
    header?: string;
    /** HTTP header value */
    value?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * This must be provided to verify primary social, enterprise and passwordless email identities. Also, is needed to verify secondary identities.
 */
export interface Identity {
    /** user_id of the identity to be verified. */
    user_id: string;
    provider: Management.IdentityProviderEnum;
    /** connection_id of the identity. */
    connection_id?: string;
}

/** Identity provider name of the identity (e.g. `google-oauth2`). */
export const IdentityProviderEnum = {
    Ad: "ad",
    Adfs: "adfs",
    Amazon: "amazon",
    Apple: "apple",
    Dropbox: "dropbox",
    Bitbucket: "bitbucket",
    Aol: "aol",
    Auth0Oidc: "auth0-oidc",
    Auth0: "auth0",
    Baidu: "baidu",
    Bitly: "bitly",
    Box: "box",
    Custom: "custom",
    Daccount: "daccount",
    Dwolla: "dwolla",
    Email: "email",
    EvernoteSandbox: "evernote-sandbox",
    Evernote: "evernote",
    Exact: "exact",
    Facebook: "facebook",
    Fitbit: "fitbit",
    Flickr: "flickr",
    Github: "github",
    GoogleApps: "google-apps",
    GoogleOauth2: "google-oauth2",
    Instagram: "instagram",
    Ip: "ip",
    Line: "line",
    Linkedin: "linkedin",
    Miicard: "miicard",
    Oauth1: "oauth1",
    Oauth2: "oauth2",
    Office365: "office365",
    Oidc: "oidc",
    Okta: "okta",
    Paypal: "paypal",
    PaypalSandbox: "paypal-sandbox",
    Pingfederate: "pingfederate",
    Planningcenter: "planningcenter",
    Renren: "renren",
    SalesforceCommunity: "salesforce-community",
    SalesforceSandbox: "salesforce-sandbox",
    Salesforce: "salesforce",
    Samlp: "samlp",
    Sharepoint: "sharepoint",
    Shopify: "shopify",
    Shop: "shop",
    Sms: "sms",
    Soundcloud: "soundcloud",
    ThecitySandbox: "thecity-sandbox",
    Thecity: "thecity",
    Thirtysevensignals: "thirtysevensignals",
    Twitter: "twitter",
    Untappd: "untappd",
    Vkontakte: "vkontakte",
    Waad: "waad",
    Weibo: "weibo",
    Windowslive: "windowslive",
    Wordpress: "wordpress",
    Yahoo: "yahoo",
    Yammer: "yammer",
    Yandex: "yandex",
} as const;
export type IdentityProviderEnum = (typeof IdentityProviderEnum)[keyof typeof IdentityProviderEnum];

/**
 * Encryption key
 */
export interface ImportEncryptionKeyResponseContent {
    /** Key ID */
    kid: string;
    type: Management.EncryptionKeyType;
    state: Management.EncryptionKeyState;
    /** Key creation timestamp */
    created_at: string;
    /** Key update timestamp */
    updated_at: string;
    /** ID of parent wrapping key */
    parent_kid: string;
    /** Public key in PEM format */
    public_key?: string;
}

/**
 * Integration defines a self contained functioning unit which partners
 * publish. A partner may create one or many of these integrations.
 */
export interface Integration {
    /**
     * id is a system generated GUID. This same ID is designed to be federated in
     * all the applicable localities.
     */
    id?: string;
    /** catalog_id refers to the ID in the marketplace catalog */
    catalog_id?: string;
    /** url_slug refers to the url_slug in the marketplace catalog */
    url_slug?: string;
    /**
     * partner_id is the foreign key reference to the partner account this
     * integration belongs to.
     */
    partner_id?: string;
    /**
     * name is the integration name, which will be used for display purposes in
     * the marketplace.
     *
     * To start we're going to make sure the display name is at least 3
     * characters. Can adjust this easily later.
     */
    name?: string;
    /**
     * description adds more text for the integration name -- also relevant for
     * the marketplace listing.
     */
    description?: string;
    /** short_description is the brief description of the integration, which is used for display purposes in cards */
    short_description?: string;
    logo?: string;
    feature_type?: Management.IntegrationFeatureTypeEnum;
    terms_of_use_url?: string;
    privacy_policy_url?: string;
    public_support_link?: string;
    current_release?: Management.IntegrationRelease;
    created_at?: string;
    updated_at?: string;
}

/** feature_type is the type of the integration. */
export const IntegrationFeatureTypeEnum = {
    Unspecified: "unspecified",
    Action: "action",
    SocialConnection: "social_connection",
    LogStream: "log_stream",
    SsoIntegration: "sso_integration",
    SmsProvider: "sms_provider",
} as const;
export type IntegrationFeatureTypeEnum = (typeof IntegrationFeatureTypeEnum)[keyof typeof IntegrationFeatureTypeEnum];

export interface IntegrationRelease {
    /** The id of the associated IntegrationRelease */
    id?: string;
    trigger?: Management.ActionTrigger;
    semver?: Management.IntegrationSemVer;
    /**
     * required_secrets declares all the necessary secrets for an integration to
     * work.
     */
    required_secrets?: Management.IntegrationRequiredParam[];
    /** required_configuration declares all the necessary configuration fields for an integration to work. */
    required_configuration?: Management.IntegrationRequiredParam[];
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Param are form input values, primarily utilized when specifying secrets and
 * configuration values for actions.
 *
 * These are especially important for partner integrations -- but can be
 * exposed to tenant admins as well if they want to parameterize their custom
 * actions.
 */
export interface IntegrationRequiredParam {
    type?: Management.IntegrationRequiredParamTypeEnum;
    /** The name of the parameter. */
    name?: string;
    /** The flag for if this parameter is required. */
    required?: boolean;
    /** The temp flag for if this parameter is required (experimental; for Labs use only). */
    optional?: boolean;
    /** The short label for this parameter. */
    label?: string;
    /** The lengthier description for this parameter. */
    description?: string;
    /** The default value for this parameter. */
    default_value?: string;
    /** Placeholder text for this parameter. */
    placeholder?: string;
    /** The allowable options for this param. */
    options?: Management.IntegrationRequiredParamOption[];
}

export interface IntegrationRequiredParamOption {
    /** The value of an option that will be used within the application. */
    value?: string;
    /** The display value of an option suitable for displaying in a UI. */
    label?: string;
}

export const IntegrationRequiredParamTypeEnum = {
    Unspecified: "UNSPECIFIED",
    String: "STRING",
} as const;
export type IntegrationRequiredParamTypeEnum =
    (typeof IntegrationRequiredParamTypeEnum)[keyof typeof IntegrationRequiredParamTypeEnum];

/**
 * Semver denotes the major.minor version of an integration release
 */
export interface IntegrationSemVer {
    /** Major is the major number of a semver */
    major?: number;
    /** Minior is the minior number of a semver */
    minor?: number;
}

/** Format of the file. Must be `json` or `csv`. */
export const JobFileFormatEnum = {
    Json: "json",
    Csv: "csv",
} as const;
export type JobFileFormatEnum = (typeof JobFileFormatEnum)[keyof typeof JobFileFormatEnum];

/**
 * Configuration for linked clients in the OIN Express Configuration feature.
 */
export interface LinkedClientConfiguration {
    /** The ID of the linked client. */
    client_id: string;
}

export interface ListActionBindingsPaginatedResponseContent {
    /** The total result count. */
    total?: number;
    /** Page index of the results being returned. First page is 0. */
    page?: number;
    /** Number of results per page. */
    per_page?: number;
    /** The list of actions that are bound to this trigger in the order in which they will be executed. */
    bindings?: Management.ActionBinding[];
}

export interface ListActionTriggersResponseContent {
    triggers?: Management.ActionTrigger[];
}

export interface ListActionVersionsPaginatedResponseContent {
    /** The total result count. */
    total?: number;
    /** Page index of the results being returned. First page is 0. */
    page?: number;
    /** Number of results per page. */
    per_page?: number;
    versions?: Management.ActionVersion[];
}

export interface ListActionsPaginatedResponseContent {
    /** The total result count. */
    total?: number;
    /** Page index of the results being returned. First page is 0. */
    page?: number;
    /** Number of results per page. */
    per_page?: number;
    /** The list of actions. */
    actions?: Management.Action[];
}

export interface ListAculsOffsetPaginatedResponseContent {
    configs?: Management.AculResponseContent[];
    /** the index of the first configuration in the response (before filtering) */
    start?: number;
    /** the maximum number of configurations shown per page (before filtering) */
    limit?: number;
    /** the total number of configurations on this tenant */
    total?: number;
}

export interface ListBrandingPhoneProvidersResponseContent {
    providers?: Management.PhoneProviderSchemaMasked[];
}

export interface ListClientConnectionsResponseContent {
    connections: Management.ConnectionForList[];
    /** Encoded next token */
    next?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface ListClientGrantOrganizationsPaginatedResponseContent {
    /** Opaque identifier for use with the <i>from</i> query parameter for the next page of results.<br/>This identifier is valid for 24 hours. */
    next?: string;
    organizations?: Management.Organization[];
}

export interface ListClientGrantPaginatedResponseContent {
    /** Opaque identifier for use with the <i>from</i> query parameter for the next page of results.<br/>This identifier is valid for 24 hours. */
    next?: string;
    client_grants?: Management.ClientGrantResponseContent[];
}

export interface ListClientsOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    clients?: Management.Client[];
}

export interface ListConnectionProfileTemplateResponseContent {
    connection_profile_templates?: Management.ConnectionProfileTemplateItem[];
}

export interface ListConnectionProfilesPaginatedResponseContent {
    /** A cursor to be used as the "from" query parameter for the next page of results. */
    next?: string;
    connection_profiles?: Management.ConnectionProfile[];
}

export interface ListConnectionsCheckpointPaginatedResponseContent {
    /** Opaque identifier for use with the <i>from</i> query parameter for the next page of results. */
    next?: string;
    connections?: Management.ConnectionForList[];
}

export type ListCustomDomainsResponseContent = Management.CustomDomain[];

export interface ListDeviceCredentialsOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    device_credentials?: Management.DeviceCredential[];
}

export interface ListEncryptionKeyOffsetPaginatedResponseContent {
    /** Page index of the results to return. First page is 0. */
    start?: number;
    /** Number of results per page. */
    limit?: number;
    /** Total amount of encryption keys. */
    total?: number;
    /** Encryption keys. */
    keys?: Management.EncryptionKey[];
}

export interface ListFlowExecutionsPaginatedResponseContent {
    /** Opaque identifier for use with the <i>from</i> query parameter for the next page of results.<br/>This identifier is valid for 24 hours. */
    next?: string;
    executions?: Management.FlowExecutionSummary[];
}

export interface ListFlowsOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    flows?: Management.FlowSummary[];
}

export interface ListFlowsVaultConnectionsOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    connections?: Management.FlowsVaultConnectionSummary[];
}

export interface ListFormsOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    forms?: Management.FormSummary[];
}

export type ListGuardianPoliciesResponseContent = Management.MfaPolicyEnum[];

export interface ListHooksOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    hooks?: Management.Hook[];
}

export interface ListLogOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    length?: number;
    total?: number;
    logs?: Management.Log[];
}

export interface ListNetworkAclsOffsetPaginatedResponseContent {
    network_acls?: Management.NetworkAclsResponseContent[];
    start?: number;
    limit?: number;
    total?: number;
}

export interface ListOrganizationClientGrantsOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    client_grants?: Management.OrganizationClientGrant[];
}

export interface ListOrganizationConnectionsOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    enabled_connections?: Management.OrganizationConnection[];
}

export interface ListOrganizationDiscoveryDomainsResponseContent {
    next?: string;
    domains: Management.OrganizationDiscoveryDomain[];
}

export interface ListOrganizationInvitationsOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    invitations?: Management.OrganizationInvitation[];
}

export interface ListOrganizationMemberRolesOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    roles?: Management.Role[];
}

export interface ListOrganizationMembersPaginatedResponseContent {
    next?: string;
    members?: Management.OrganizationMember[];
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface ListOrganizationsPaginatedResponseContent {
    next?: string;
    organizations?: Management.Organization[];
}

export interface ListPhoneTemplatesResponseContent {
    templates?: Management.PhoneTemplate[];
}

export interface ListRefreshTokensPaginatedResponseContent {
    tokens?: Management.RefreshTokenResponseContent[];
    /** A cursor to be used as the "from" query parameter for the next page of results. */
    next?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface ListResourceServerOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    resource_servers?: Management.ResourceServer[];
}

export interface ListRolePermissionsOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    permissions?: Management.PermissionsResponsePayload[];
}

export interface ListRoleUsersPaginatedResponseContent {
    next?: string;
    users?: Management.RoleUser[];
}

export interface ListRolesOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    roles?: Management.Role[];
}

export interface ListRulesOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    rules?: Management.Rule[];
}

/**
 * The list of custom text keys and values.
 */
export type ListSelfServiceProfileCustomTextResponseContent = Record<string, string>;

export interface ListSelfServiceProfilesPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    self_service_profiles?: Management.SelfServiceProfile[];
}

export interface ListTokenExchangeProfileResponseContent {
    /** Opaque identifier for use with the <i>from</i> query parameter for the next page of results.<br/>This identifier is valid for 24 hours. */
    next?: string;
    token_exchange_profiles?: Management.TokenExchangeProfileResponseContent[];
}

export interface ListUserAttributeProfileTemplateResponseContent {
    user_attribute_profile_templates?: Management.UserAttributeProfileTemplateItem[];
}

export interface ListUserAttributeProfilesPaginatedResponseContent {
    /** A cursor to be used as the "from" query parameter for the next page of results. */
    next?: string;
    user_attribute_profiles?: Management.UserAttributeProfile[];
}

export interface ListUserAuthenticationMethodsOffsetPaginatedResponseContent {
    /** Index of the starting record. Derived from the page and per_page parameters. */
    start?: number;
    /** Maximum amount of records to return. */
    limit?: number;
    /** Total number of pageable records. */
    total?: number;
    /** The paginated authentication methods. Returned in this structure when include_totals is true. */
    authenticators?: Management.UserAuthenticationMethod[];
}

export interface ListUserBlocksByIdentifierResponseContent {
    /** Array of identifier + IP address pairs.  IP address is optional, and may be omitted in certain circumstances (such as Account Lockout mode). */
    blocked_for?: Management.UserBlockIdentifier[];
}

export interface ListUserBlocksResponseContent {
    /** Array of identifier + IP address pairs.  IP address is optional, and may be omitted in certain circumstances (such as Account Lockout mode). */
    blocked_for?: Management.UserBlockIdentifier[];
}

export interface ListUserConnectedAccountsResponseContent {
    connected_accounts: Management.ConnectedAccount[];
    /** The token to retrieve the next page of connected accounts (if there is one) */
    next?: string;
}

export interface ListUserGrantsOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    grants?: Management.UserGrant[];
}

export interface ListUserOrganizationsOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    organizations?: Management.Organization[];
}

export interface ListUserPermissionsOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    permissions?: Management.UserPermissionSchema[];
}

export interface ListUserRolesOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    total?: number;
    roles?: Management.Role[];
}

export interface ListUserSessionsPaginatedResponseContent {
    sessions?: Management.SessionResponseContent[];
    /** A cursor to be used as the "from" query parameter for the next page of results. */
    next?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface ListUsersOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    length?: number;
    total?: number;
    users?: Management.UserResponseSchema[];
}

export interface ListVerifiableCredentialTemplatesPaginatedResponseContent {
    /** Opaque identifier for use with the <i>from</i> query parameter for the next page of results.<br/>This identifier is valid for 24 hours. */
    next?: string;
    templates?: Management.VerifiableCredentialTemplateResponse[];
}

export interface Log {
    date?: Management.LogDate;
    /** Type of event. */
    type?: string;
    /** Description of this event. */
    description?: string | null;
    /** Name of the connection the event relates to. */
    connection?: string;
    /** ID of the connection the event relates to. */
    connection_id?: string;
    /** ID of the client (application). */
    client_id?: string;
    /** Name of the client (application). */
    client_name?: string;
    /** IP address of the log event source. */
    ip?: string;
    /** Hostname the event applies to. */
    hostname?: string;
    /** ID of the user involved in the event. */
    user_id?: string;
    /** Name of the user involved in the event. */
    user_name?: string;
    /** API audience the event applies to. */
    audience?: string;
    /** Scope permissions applied to the event. */
    scope?: string;
    /** Name of the strategy involved in the event. */
    strategy?: string;
    /** Type of strategy involved in the event. */
    strategy_type?: string;
    /** Unique ID of the event. */
    log_id?: string;
    /** Whether the client was a mobile device (true) or desktop/laptop/server (false). */
    isMobile?: boolean;
    details?: Management.LogDetails;
    /** User agent string from the client device that caused the event. */
    user_agent?: string;
    security_context?: Management.LogSecurityContext;
    location_info?: Management.LogLocationInfo;
    /** Accepts any additional properties */
    [key: string]: any;
}

export type LogDate =
    /**
     * Date when the event occurred in ISO 8601 format. */
    string | Management.LogDateObject;

/**
 * Date when the event occurred in ISO 8601 format.
 */
export type LogDateObject = Record<string, unknown>;

/**
 * Additional useful details about this event (structure is dependent upon event type).
 */
export type LogDetails = Record<string, unknown>;

/**
 * Information about the location that triggered this event based on the `ip`.
 */
export interface LogLocationInfo {
    /** Two-letter <a href="https://www.iso.org/iso-3166-country-codes.html">Alpha-2 ISO 3166-1</a> country code. */
    country_code?: string;
    /** Three-letter <a href="https://www.iso.org/iso-3166-country-codes.html">Alpha-3 ISO 3166-1</a> country code. */
    country_code3?: string;
    /** Full country name in English. */
    country_name?: string;
    /** Full city name in English. */
    city_name?: string;
    /** Global latitude (horizontal) position. */
    latitude?: string;
    /** Global longitude (vertical) position. */
    longitude?: string;
    /** Time zone name as found in the <a href="https://www.iana.org/time-zones">tz database</a>. */
    time_zone?: string;
    /** Continent the country is located within. Can be `AF` (Africa), `AN` (Antarctica), `AS` (Asia), `EU` (Europe), `NA` (North America), `OC` (Oceania) or `SA` (South America). */
    continent_code?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Information about security-related signals.
 */
export interface LogSecurityContext {
    /** JA3 fingerprint value. */
    ja3?: string;
    /** JA4 fingerprint value. */
    ja4?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export type LogStreamDatadogEnum = "datadog";

/** Datadog region */
export const LogStreamDatadogRegionEnum = {
    Us: "us",
    Eu: "eu",
    Us3: "us3",
    Us5: "us5",
} as const;
export type LogStreamDatadogRegionEnum = (typeof LogStreamDatadogRegionEnum)[keyof typeof LogStreamDatadogRegionEnum];

export interface LogStreamDatadogResponseSchema {
    /** The id of the log stream */
    id?: string;
    /** log stream name */
    name?: string;
    status?: Management.LogStreamStatusEnum;
    type?: Management.LogStreamDatadogEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink?: Management.LogStreamDatadogSink;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface LogStreamDatadogSink {
    /** Datadog API Key */
    datadogApiKey: string;
    datadogRegion: Management.LogStreamDatadogRegionEnum;
}

export type LogStreamEventBridgeEnum = "eventbridge";

export interface LogStreamEventBridgeResponseSchema {
    /** The id of the log stream */
    id?: string;
    /** log stream name */
    name?: string;
    status?: Management.LogStreamStatusEnum;
    type?: Management.LogStreamEventBridgeEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink?: Management.LogStreamEventBridgeSink;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface LogStreamEventBridgeSink {
    /** AWS account ID */
    awsAccountId: string;
    awsRegion: Management.LogStreamEventBridgeSinkRegionEnum;
    /** AWS EventBridge partner event source */
    awsPartnerEventSource?: string;
}

/** The region in which the EventBridge event source will be created */
export const LogStreamEventBridgeSinkRegionEnum = {
    AfSouth1: "af-south-1",
    ApEast1: "ap-east-1",
    ApEast2: "ap-east-2",
    ApNortheast1: "ap-northeast-1",
    ApNortheast2: "ap-northeast-2",
    ApNortheast3: "ap-northeast-3",
    ApSouth1: "ap-south-1",
    ApSouth2: "ap-south-2",
    ApSoutheast1: "ap-southeast-1",
    ApSoutheast2: "ap-southeast-2",
    ApSoutheast3: "ap-southeast-3",
    ApSoutheast4: "ap-southeast-4",
    ApSoutheast5: "ap-southeast-5",
    ApSoutheast6: "ap-southeast-6",
    ApSoutheast7: "ap-southeast-7",
    CaCentral1: "ca-central-1",
    CaWest1: "ca-west-1",
    EuCentral1: "eu-central-1",
    EuCentral2: "eu-central-2",
    EuNorth1: "eu-north-1",
    EuSouth1: "eu-south-1",
    EuSouth2: "eu-south-2",
    EuWest1: "eu-west-1",
    EuWest2: "eu-west-2",
    EuWest3: "eu-west-3",
    IlCentral1: "il-central-1",
    MeCentral1: "me-central-1",
    MeSouth1: "me-south-1",
    MxCentral1: "mx-central-1",
    SaEast1: "sa-east-1",
    UsGovEast1: "us-gov-east-1",
    UsGovWest1: "us-gov-west-1",
    UsEast1: "us-east-1",
    UsEast2: "us-east-2",
    UsWest1: "us-west-1",
    UsWest2: "us-west-2",
} as const;
export type LogStreamEventBridgeSinkRegionEnum =
    (typeof LogStreamEventBridgeSinkRegionEnum)[keyof typeof LogStreamEventBridgeSinkRegionEnum];

export type LogStreamEventGridEnum = "eventgrid";

/** Azure Region Name */
export const LogStreamEventGridRegionEnum = {
    Australiacentral: "australiacentral",
    Australiaeast: "australiaeast",
    Australiasoutheast: "australiasoutheast",
    Brazilsouth: "brazilsouth",
    Canadacentral: "canadacentral",
    Canadaeast: "canadaeast",
    Centralindia: "centralindia",
    Centralus: "centralus",
    Eastasia: "eastasia",
    Eastus: "eastus",
    Eastus2: "eastus2",
    Francecentral: "francecentral",
    Germanywestcentral: "germanywestcentral",
    Japaneast: "japaneast",
    Japanwest: "japanwest",
    Koreacentral: "koreacentral",
    Koreasouth: "koreasouth",
    Northcentralus: "northcentralus",
    Northeurope: "northeurope",
    Norwayeast: "norwayeast",
    Southafricanorth: "southafricanorth",
    Southcentralus: "southcentralus",
    Southeastasia: "southeastasia",
    Southindia: "southindia",
    Swedencentral: "swedencentral",
    Switzerlandnorth: "switzerlandnorth",
    Uaenorth: "uaenorth",
    Uksouth: "uksouth",
    Ukwest: "ukwest",
    Westcentralus: "westcentralus",
    Westeurope: "westeurope",
    Westindia: "westindia",
    Westus: "westus",
    Westus2: "westus2",
} as const;
export type LogStreamEventGridRegionEnum =
    (typeof LogStreamEventGridRegionEnum)[keyof typeof LogStreamEventGridRegionEnum];

export interface LogStreamEventGridResponseSchema {
    /** The id of the log stream */
    id?: string;
    /** log stream name */
    name?: string;
    status?: Management.LogStreamStatusEnum;
    type?: Management.LogStreamEventGridEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink?: Management.LogStreamEventGridSink;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface LogStreamEventGridSink {
    /** Subscription ID */
    azureSubscriptionId: string;
    azureRegion: Management.LogStreamEventGridRegionEnum;
    /** Resource Group */
    azureResourceGroup: string;
    /** Partner Topic */
    azurePartnerTopic?: string;
}

export interface LogStreamFilter {
    type?: Management.LogStreamFilterTypeEnum;
    name?: Management.LogStreamFilterGroupNameEnum;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** Category group name */
export const LogStreamFilterGroupNameEnum = {
    AuthLoginFail: "auth.login.fail",
    AuthLoginNotification: "auth.login.notification",
    AuthLoginSuccess: "auth.login.success",
    AuthLogoutFail: "auth.logout.fail",
    AuthLogoutSuccess: "auth.logout.success",
    AuthSignupFail: "auth.signup.fail",
    AuthSignupSuccess: "auth.signup.success",
    AuthSilentAuthFail: "auth.silent_auth.fail",
    AuthSilentAuthSuccess: "auth.silent_auth.success",
    AuthTokenExchangeFail: "auth.token_exchange.fail",
    AuthTokenExchangeSuccess: "auth.token_exchange.success",
    ManagementFail: "management.fail",
    ManagementSuccess: "management.success",
    ScimEvent: "scim.event",
    SystemNotification: "system.notification",
    UserFail: "user.fail",
    UserNotification: "user.notification",
    UserSuccess: "user.success",
    Actions: "actions",
    Other: "other",
} as const;
export type LogStreamFilterGroupNameEnum =
    (typeof LogStreamFilterGroupNameEnum)[keyof typeof LogStreamFilterGroupNameEnum];

/**
 * Filter type. Currently `category` is the only valid type.
 */
export type LogStreamFilterTypeEnum = "category";

/** HTTP JSON format */
export const LogStreamHttpContentFormatEnum = {
    Jsonarray: "JSONARRAY",
    Jsonlines: "JSONLINES",
    Jsonobject: "JSONOBJECT",
} as const;
export type LogStreamHttpContentFormatEnum =
    (typeof LogStreamHttpContentFormatEnum)[keyof typeof LogStreamHttpContentFormatEnum];

export type LogStreamHttpEnum = "http";

export interface LogStreamHttpResponseSchema {
    /** The id of the log stream */
    id?: string;
    /** log stream name */
    name?: string;
    status?: Management.LogStreamStatusEnum;
    type?: Management.LogStreamHttpEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink?: Management.LogStreamHttpSink;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface LogStreamHttpSink {
    /** HTTP Authorization header */
    httpAuthorization?: string;
    httpContentFormat?: Management.LogStreamHttpContentFormatEnum;
    /** HTTP Content-Type header */
    httpContentType?: string;
    /** HTTP endpoint */
    httpEndpoint: string;
    /** custom HTTP headers */
    httpCustomHeaders?: Management.HttpCustomHeader[];
}

export type LogStreamMixpanelEnum = "mixpanel";

/** Mixpanel Region */
export const LogStreamMixpanelRegionEnum = {
    Us: "us",
    Eu: "eu",
} as const;
export type LogStreamMixpanelRegionEnum =
    (typeof LogStreamMixpanelRegionEnum)[keyof typeof LogStreamMixpanelRegionEnum];

export interface LogStreamMixpanelResponseSchema {
    /** The id of the log stream */
    id?: string;
    /** log stream name */
    name?: string;
    status?: Management.LogStreamStatusEnum;
    type?: Management.LogStreamMixpanelEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink?: Management.LogStreamMixpanelSink;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface LogStreamMixpanelSink {
    mixpanelRegion: Management.LogStreamMixpanelRegionEnum;
    /** Mixpanel Project Id */
    mixpanelProjectId: string;
    /** Mixpanel Service Account Username */
    mixpanelServiceAccountUsername: string;
    /** Mixpanel Service Account Password */
    mixpanelServiceAccountPassword: string;
}

export interface LogStreamMixpanelSinkPatch {
    mixpanelRegion: Management.LogStreamMixpanelRegionEnum;
    /** Mixpanel Project Id */
    mixpanelProjectId: string;
    /** Mixpanel Service Account Username */
    mixpanelServiceAccountUsername: string;
    /** Mixpanel Service Account Password */
    mixpanelServiceAccountPassword?: string;
}

export type LogStreamPiiAlgorithmEnum = "xxhash";

export interface LogStreamPiiConfig {
    log_fields: Management.LogStreamPiiLogFieldsEnum[];
    method?: Management.LogStreamPiiMethodEnum;
    algorithm?: Management.LogStreamPiiAlgorithmEnum;
}

export const LogStreamPiiLogFieldsEnum = {
    FirstName: "first_name",
    LastName: "last_name",
    Username: "username",
    Email: "email",
    Phone: "phone",
    Address: "address",
} as const;
export type LogStreamPiiLogFieldsEnum = (typeof LogStreamPiiLogFieldsEnum)[keyof typeof LogStreamPiiLogFieldsEnum];

export const LogStreamPiiMethodEnum = {
    Mask: "mask",
    Hash: "hash",
} as const;
export type LogStreamPiiMethodEnum = (typeof LogStreamPiiMethodEnum)[keyof typeof LogStreamPiiMethodEnum];

export type LogStreamResponseSchema =
    | Management.LogStreamHttpResponseSchema
    | Management.LogStreamEventBridgeResponseSchema
    | Management.LogStreamEventGridResponseSchema
    | Management.LogStreamDatadogResponseSchema
    | Management.LogStreamSplunkResponseSchema
    | Management.LogStreamSumoResponseSchema
    | Management.LogStreamSegmentResponseSchema
    | Management.LogStreamMixpanelResponseSchema;

export type LogStreamSegmentEnum = "segment";

export interface LogStreamSegmentResponseSchema {
    /** The id of the log stream */
    id?: string;
    /** log stream name */
    name?: string;
    status?: Management.LogStreamStatusEnum;
    type?: Management.LogStreamSegmentEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink?: Management.LogStreamSegmentSinkWriteKey;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface LogStreamSegmentSink {
    /** Segment write key */
    segmentWriteKey?: string;
}

export interface LogStreamSegmentSinkWriteKey {
    /** Segment write key */
    segmentWriteKey: string;
}

export type LogStreamSinkPatch =
    | Management.LogStreamHttpSink
    | Management.LogStreamDatadogSink
    | Management.LogStreamSplunkSink
    | Management.LogStreamSumoSink
    | Management.LogStreamSegmentSink
    | Management.LogStreamMixpanelSinkPatch;

export type LogStreamSplunkEnum = "splunk";

export interface LogStreamSplunkResponseSchema {
    /** The id of the log stream */
    id?: string;
    /** log stream name */
    name?: string;
    status?: Management.LogStreamStatusEnum;
    type?: Management.LogStreamSplunkEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink?: Management.LogStreamSplunkSink;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface LogStreamSplunkSink {
    /** Splunk URL Endpoint */
    splunkDomain: string;
    /** Port */
    splunkPort: string;
    /** Splunk token */
    splunkToken: string;
    /** Verify TLS certificate */
    splunkSecure: boolean;
}

/** The status of the log stream. Possible values: `active`, `paused`, `suspended` */
export const LogStreamStatusEnum = {
    Active: "active",
    Paused: "paused",
    Suspended: "suspended",
} as const;
export type LogStreamStatusEnum = (typeof LogStreamStatusEnum)[keyof typeof LogStreamStatusEnum];

export type LogStreamSumoEnum = "sumo";

export interface LogStreamSumoResponseSchema {
    /** The id of the log stream */
    id?: string;
    /** log stream name */
    name?: string;
    status?: Management.LogStreamStatusEnum;
    type?: Management.LogStreamSumoEnum;
    /** True for priority log streams, false for non-priority */
    isPriority?: boolean;
    /** Only logs events matching these filters will be delivered by the stream. If omitted or empty, all events will be delivered. */
    filters?: Management.LogStreamFilter[];
    pii_config?: Management.LogStreamPiiConfig;
    sink?: Management.LogStreamSumoSink;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface LogStreamSumoSink {
    /** HTTP Source Address */
    sumoSourceAddress: string;
}

/** The MFA policy */
export const MfaPolicyEnum = {
    AllApplications: "all-applications",
    ConfidenceScore: "confidence-score",
} as const;
export type MfaPolicyEnum = (typeof MfaPolicyEnum)[keyof typeof MfaPolicyEnum];

export interface MdlPresentationProperties {
    /** Family Name */
    family_name?: boolean;
    /** Given Name */
    given_name?: boolean;
    /** Birth Date */
    birth_date?: boolean;
    /** Issue Date */
    issue_date?: boolean;
    /** Expiry Date */
    expiry_date?: boolean;
    /** Issuing Country */
    issuing_country?: boolean;
    /** Issuing Authority */
    issuing_authority?: boolean;
    /** Portrait */
    portrait?: boolean;
    /** Driving Privileges */
    driving_privileges?: boolean;
    /** Resident Address */
    resident_address?: boolean;
    /** Portrait Capture Date */
    portrait_capture_date?: boolean;
    /** Age in Years */
    age_in_years?: boolean;
    /** Age Birth Year */
    age_birth_year?: boolean;
    /** Issuing Jurisdiction */
    issuing_jurisdiction?: boolean;
    /** Nationality */
    nationality?: boolean;
    /** Resident City */
    resident_city?: boolean;
    /** Resident State */
    resident_state?: boolean;
    /** Resident Postal Code */
    resident_postal_code?: boolean;
    /** Resident Country */
    resident_country?: boolean;
    /** Family Name National Character */
    family_name_national_character?: boolean;
    /** Given Name National Character */
    given_name_national_character?: boolean;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * A simplified presentation request
 */
export interface MdlPresentationRequest {
    "org.iso.18013.5.1.mDL": Management.MdlPresentationRequestProperties;
}

export interface MdlPresentationRequestProperties {
    "org.iso.18013.5.1": Management.MdlPresentationProperties;
}

/**
 * Configure native social settings
 */
export interface NativeSocialLogin {
    apple?: Management.NativeSocialLoginApple;
    facebook?: Management.NativeSocialLoginFacebook;
    google?: Management.NativeSocialLoginGoogle;
}

/**
 * Native Social Login support for the Apple connection
 */
export interface NativeSocialLoginApple {
    /** Determine whether or not to allow signing in natively using an Apple authorization code */
    enabled?: boolean;
}

/**
 * Native Social Login support for the Facebook connection
 */
export interface NativeSocialLoginFacebook {
    /** Determine whether or not to allow signing in natively using Facebook */
    enabled?: boolean;
}

/**
 * Native Social Login support for the google-oauth2 connection
 */
export interface NativeSocialLoginGoogle {
    /** Determine whether or not to allow signing in natively using a Google ID token */
    enabled?: boolean;
}

export type NetworkAclMatchIpv4Cidr = string;

export type NetworkAclMatchIpv6Cidr = string;

export interface NetworkAclAction {
    block?: Management.NetworkAclActionBlockEnum;
    allow?: Management.NetworkAclActionAllowEnum;
    log?: Management.NetworkAclActionLogEnum;
    redirect?: Management.NetworkAclActionRedirectEnum;
    /** The URI to which the match or not_match requests will be routed */
    redirect_uri?: string;
}

/**
 * Indicates the rule will allow requests that either match or not_match specific criteria
 */
export type NetworkAclActionAllowEnum = boolean;

/**
 * Indicates the rule will block requests that either match or not_match specific criteria
 */
export type NetworkAclActionBlockEnum = boolean;

/**
 * Indicates the rule will log requests that either match or not_match specific criteria
 */
export type NetworkAclActionLogEnum = boolean;

/**
 * Indicates the rule will redirect requests that either match or not_match specific criteria
 */
export type NetworkAclActionRedirectEnum = boolean;

export interface NetworkAclMatch {
    asns?: number[];
    geo_country_codes?: string[];
    geo_subdivision_codes?: string[];
    ipv4_cidrs?: Management.NetworkAclMatchIpv4Cidr[];
    ipv6_cidrs?: Management.NetworkAclMatchIpv6Cidr[];
    ja3_fingerprints?: string[];
    ja4_fingerprints?: string[];
    user_agents?: string[];
}

export interface NetworkAclRule {
    action: Management.NetworkAclAction;
    match?: Management.NetworkAclMatch;
    not_match?: Management.NetworkAclMatch;
    scope: Management.NetworkAclRuleScopeEnum;
}

/** Identifies the origin of the request as the Management API (management), Authentication API (authentication), Dynamic Client Registration API (dynamic_client_registration), or any (tenant) */
export const NetworkAclRuleScopeEnum = {
    Management: "management",
    Authentication: "authentication",
    Tenant: "tenant",
    DynamicClientRegistration: "dynamic_client_registration",
} as const;
export type NetworkAclRuleScopeEnum = (typeof NetworkAclRuleScopeEnum)[keyof typeof NetworkAclRuleScopeEnum];

export interface NetworkAclsResponseContent {
    id?: string;
    description?: string;
    active?: boolean;
    priority?: number;
    rule?: Management.NetworkAclRule;
    /** The timestamp when the Network ACL Configuration was created */
    created_at?: string;
    /** The timestamp when the Network ACL Configuration was last updated */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface Organization {
    /** Organization identifier. */
    id?: string;
    /** The name of this organization. */
    name?: string;
    /** Friendly name of this organization. */
    display_name?: string;
    branding?: Management.OrganizationBranding;
    metadata?: Management.OrganizationMetadata;
    token_quota?: Management.TokenQuota;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Theme defines how to style the login pages.
 */
export interface OrganizationBranding {
    /** URL of logo to display on login page. */
    logo_url?: string;
    colors?: Management.OrganizationBrandingColors;
}

/**
 * Color scheme used to customize the login pages.
 */
export interface OrganizationBrandingColors {
    /** HEX Color for primary elements. */
    primary: string;
    /** HEX Color for background. */
    page_background: string;
}

export interface OrganizationClientGrant {
    /** ID of the client grant. */
    id?: string;
    /** ID of the client. */
    client_id?: string;
    /** The audience (API identifier) of this client grant */
    audience?: string;
    /** Scopes allowed for this client grant. */
    scope?: string[];
    organization_usage?: Management.OrganizationUsageEnum;
    /** If enabled, any organization can be used with this grant. If disabled (default), the grant must be explicitly assigned to the desired organizations. */
    allow_any_organization?: boolean;
}

export interface OrganizationConnection {
    /** ID of the connection. */
    connection_id?: string;
    /** When true, all users that log in with this connection will be automatically granted membership in the organization. When false, users must be granted membership in the organization before logging in with this connection. */
    assign_membership_on_login?: boolean;
    /** Determines whether a connection should be displayed on this organizationâ€™s login prompt. Only applicable for enterprise connections. Default: true. */
    show_as_button?: boolean;
    /** Determines whether organization signup should be enabled for this organization connection. Only applicable for database connections. Default: false. */
    is_signup_enabled?: boolean;
    connection?: Management.OrganizationConnectionInformation;
}

export interface OrganizationConnectionInformation {
    /** The name of the enabled connection. */
    name?: string;
    /** The strategy of the enabled connection. */
    strategy?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface OrganizationDiscoveryDomain {
    /** Organization discovery domain identifier. */
    id: string;
    /** The domain name to associate with the organization e.g. acme.com. */
    domain: string;
    status: Management.OrganizationDiscoveryDomainStatus;
    /** A unique token generated for the discovery domain. This must be placed in a DNS TXT record at the location specified by the verification_host field to prove domain ownership. */
    verification_txt: string;
    /** The full domain where the TXT record should be added. */
    verification_host: string;
}

/** The verification status of the discovery domain. */
export const OrganizationDiscoveryDomainStatus = {
    Pending: "pending",
    Verified: "verified",
} as const;
export type OrganizationDiscoveryDomainStatus =
    (typeof OrganizationDiscoveryDomainStatus)[keyof typeof OrganizationDiscoveryDomainStatus];

export interface OrganizationEnabledConnection {
    /** ID of the connection. */
    connection_id?: string;
    /** When true, all users that log in with this connection will be automatically granted membership in the organization. When false, users must be granted membership in the organization before logging in with this connection. */
    assign_membership_on_login?: boolean;
    /** Determines whether a connection should be displayed on this organizationâ€™s login prompt. Only applicable for enterprise connections. Default: true. */
    show_as_button?: boolean;
    /** Determines whether organization signup should be enabled for this organization connection. Only applicable for database connections. Default: false. */
    is_signup_enabled?: boolean;
    connection?: Management.OrganizationConnectionInformation;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface OrganizationInvitation {
    /** The id of the user invitation. */
    id?: string;
    /** Organization identifier. */
    organization_id?: string;
    inviter?: Management.OrganizationInvitationInviter;
    invitee?: Management.OrganizationInvitationInvitee;
    /** The invitation url to be send to the invitee. */
    invitation_url?: string;
    /** The ISO 8601 formatted timestamp representing the creation time of the invitation. */
    created_at?: string;
    /** The ISO 8601 formatted timestamp representing the expiration time of the invitation. */
    expires_at?: string;
    /** Auth0 client ID. Used to resolve the application's login initiation endpoint. */
    client_id?: string;
    /** The id of the connection to force invitee to authenticate with. */
    connection_id?: string;
    app_metadata?: Management.AppMetadata;
    user_metadata?: Management.UserMetadata;
    /** List of roles IDs to associated with the user. */
    roles?: string[];
    /** The id of the invitation ticket */
    ticket_id?: string;
}

export interface OrganizationInvitationInvitee {
    /** The invitee's email. */
    email: string;
}

export interface OrganizationInvitationInviter {
    /** The inviter's name. */
    name: string;
}

export interface OrganizationMember {
    /** ID of this user. */
    user_id?: string;
    /** URL to a picture for this user. */
    picture?: string;
    /** Name of this user. */
    name?: string;
    /** Email address of this user. */
    email?: string;
    roles?: Management.OrganizationMemberRole[];
}

export interface OrganizationMemberRole {
    /** ID for this role. */
    id?: string;
    /** Name of this role. */
    name?: string;
}

/**
 * Metadata associated with the organization, in the form of an object with string values (max 255 chars). Maximum of 25 metadata properties allowed.
 */
export type OrganizationMetadata = Record<string, (string | null) | undefined>;

/** Defines whether organizations can be used with client credentials exchanges for this grant. */
export const OrganizationUsageEnum = {
    Deny: "deny",
    Allow: "allow",
    Require: "require",
} as const;
export type OrganizationUsageEnum = (typeof OrganizationUsageEnum)[keyof typeof OrganizationUsageEnum];

/** Name of the prompt. */
export const PartialGroupsEnum = {
    Login: "login",
    LoginId: "login-id",
    LoginPassword: "login-password",
    LoginPasswordless: "login-passwordless",
    Signup: "signup",
    SignupId: "signup-id",
    SignupPassword: "signup-password",
    CustomizedConsent: "customized-consent",
} as const;
export type PartialGroupsEnum = (typeof PartialGroupsEnum)[keyof typeof PartialGroupsEnum];

export interface PartialPhoneTemplateContent {
    /** Default phone number to be used as 'from' when sending a phone notification */
    from?: string;
    body?: Management.PhoneTemplateBody;
}

export interface PatchClientCredentialResponseContent {
    /** ID of the credential. Generated on creation. */
    id?: string;
    /** The name given to the credential by the user. */
    name?: string;
    /** The key identifier of the credential, generated on creation. */
    kid?: string;
    alg?: Management.ClientCredentialAlgorithmEnum;
    credential_type?: Management.ClientCredentialTypeEnum;
    /** The X509 certificate's Subject Distinguished Name */
    subject_dn?: string;
    /** The X509 certificate's SHA256 thumbprint */
    thumbprint_sha256?: string;
    /** The ISO 8601 formatted date the credential was created. */
    created_at?: string;
    /** The ISO 8601 formatted date the credential was updated. */
    updated_at?: string;
    /** The ISO 8601 formatted date representing the expiration of the credential. */
    expires_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface PatchSupplementalSignalsResponseContent {
    /** Indicates if incoming Akamai Headers should be processed */
    akamai_enabled?: boolean;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface PermissionRequestPayload {
    /** Resource server (API) identifier that this permission is for. */
    resource_server_identifier: string;
    /** Name of this permission. */
    permission_name: string;
}

export interface PermissionsResponsePayload {
    /** Resource server (API) identifier that this permission is for. */
    resource_server_identifier?: string;
    /** Name of this permission. */
    permission_name?: string;
    /** Resource server (API) name this permission is for. */
    resource_server_name?: string;
    /** Description of this permission. */
    description?: string;
}

/**
 * Configuration for the phone number attribute for users.
 */
export interface PhoneAttribute {
    identifier?: Management.ConnectionAttributeIdentifier;
    /** Determines if property should be required for users */
    profile_required?: boolean;
    signup?: Management.SignupVerified;
}

/**
 * This depicts the type of notifications this provider can receive.
 */
export type PhoneProviderChannelEnum = "phone";

export type PhoneProviderConfiguration =
    | Management.TwilioProviderConfiguration
    | Management.CustomProviderConfiguration;

/**
 * Provider credentials required to use authenticate to the provider.
 */
export type PhoneProviderCredentials = Management.TwilioProviderCredentials | Management.CustomProviderCredentials;

/** The delivery method for the notification */
export const PhoneProviderDeliveryMethodEnum = {
    Text: "text",
    Voice: "voice",
} as const;
export type PhoneProviderDeliveryMethodEnum =
    (typeof PhoneProviderDeliveryMethodEnum)[keyof typeof PhoneProviderDeliveryMethodEnum];

/** Name of the phone notification provider */
export const PhoneProviderNameEnum = {
    Twilio: "twilio",
    Custom: "custom",
} as const;
export type PhoneProviderNameEnum = (typeof PhoneProviderNameEnum)[keyof typeof PhoneProviderNameEnum];

/**
 * Phone provider configuration schema
 */
export interface PhoneProviderSchemaMasked {
    id?: string;
    /** The name of the tenant */
    tenant?: string;
    name: Management.PhoneProviderNameEnum;
    channel?: Management.PhoneProviderChannelEnum;
    /** Whether the provider is enabled (false) or disabled (true). */
    disabled?: boolean;
    configuration?: Management.PhoneProviderConfiguration;
    /** The provider's creation date and time in ISO 8601 format */
    created_at?: string;
    /** The date and time of the last update to the provider in ISO 8601 format */
    updated_at?: string;
}

export interface PhoneTemplate {
    id: string;
    channel?: string;
    customizable?: boolean;
    tenant?: string;
    content: Management.PhoneTemplateContent;
    type: Management.PhoneTemplateNotificationTypeEnum;
    /** Whether the template is enabled (false) or disabled (true). */
    disabled: boolean;
}

export interface PhoneTemplateBody {
    /** Content of the phone template for text notifications */
    text?: string;
    /** Content of the phone template for voice notifications */
    voice?: string;
}

export interface PhoneTemplateContent {
    syntax?: string;
    /** Default phone number to be used as 'from' when sending a phone notification */
    from?: string;
    body?: Management.PhoneTemplateBody;
}

export const PhoneTemplateNotificationTypeEnum = {
    OtpVerify: "otp_verify",
    OtpEnroll: "otp_enroll",
    ChangePassword: "change_password",
    BlockedAccount: "blocked_account",
    PasswordBreach: "password_breach",
} as const;
export type PhoneTemplateNotificationTypeEnum =
    (typeof PhoneTemplateNotificationTypeEnum)[keyof typeof PhoneTemplateNotificationTypeEnum];

export interface PostClientCredentialResponseContent {
    /** ID of the credential. Generated on creation. */
    id?: string;
    /** The name given to the credential by the user. */
    name?: string;
    /** The key identifier of the credential, generated on creation. */
    kid?: string;
    alg?: Management.ClientCredentialAlgorithmEnum;
    credential_type?: Management.ClientCredentialTypeEnum;
    /** The X509 certificate's Subject Distinguished Name */
    subject_dn?: string;
    /** The X509 certificate's SHA256 thumbprint */
    thumbprint_sha256?: string;
    /** The ISO 8601 formatted date the credential was created. */
    created_at?: string;
    /** The ISO 8601 formatted date the credential was updated. */
    updated_at?: string;
    /** The ISO 8601 formatted date representing the expiration of the credential. */
    expires_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** Applies to phone authentication methods only. The preferred communication method. */
export const PreferredAuthenticationMethodEnum = {
    Voice: "voice",
    Sms: "sms",
} as const;
export type PreferredAuthenticationMethodEnum =
    (typeof PreferredAuthenticationMethodEnum)[keyof typeof PreferredAuthenticationMethodEnum];

/**
 * Defines `private_key_jwt` client authentication method. If this property is defined, the client is enabled to use the Private Key JWT authentication method.
 */
export interface PrivateKeyJwt {
    credentials: Management.PrivateKeyJwtCredentials;
}

/**
 * A list of unique and previously created credential IDs enabled on the client for Private Key JWT authentication.
 */
export type PrivateKeyJwtCredentials = Management.CredentialId[];

/** Name of the prompt */
export const PromptGroupNameEnum = {
    Login: "login",
    LoginId: "login-id",
    LoginPassword: "login-password",
    LoginPasswordless: "login-passwordless",
    LoginEmailVerification: "login-email-verification",
    Signup: "signup",
    SignupId: "signup-id",
    SignupPassword: "signup-password",
    PhoneIdentifierEnrollment: "phone-identifier-enrollment",
    PhoneIdentifierChallenge: "phone-identifier-challenge",
    EmailIdentifierChallenge: "email-identifier-challenge",
    ResetPassword: "reset-password",
    CustomForm: "custom-form",
    Consent: "consent",
    CustomizedConsent: "customized-consent",
    Logout: "logout",
    MfaPush: "mfa-push",
    MfaOtp: "mfa-otp",
    MfaVoice: "mfa-voice",
    MfaPhone: "mfa-phone",
    MfaWebauthn: "mfa-webauthn",
    MfaSms: "mfa-sms",
    MfaEmail: "mfa-email",
    MfaRecoveryCode: "mfa-recovery-code",
    Mfa: "mfa",
    Status: "status",
    DeviceFlow: "device-flow",
    EmailVerification: "email-verification",
    EmailOtpChallenge: "email-otp-challenge",
    Organizations: "organizations",
    Invitation: "invitation",
    Common: "common",
    Passkeys: "passkeys",
    Captcha: "captcha",
    BruteForceProtection: "brute-force-protection",
    AsyncApprovalFlow: "async-approval-flow",
} as const;
export type PromptGroupNameEnum = (typeof PromptGroupNameEnum)[keyof typeof PromptGroupNameEnum];

/** Language to update. */
export const PromptLanguageEnum = {
    Am: "am",
    Ar: "ar",
    ArEg: "ar-EG",
    ArSa: "ar-SA",
    Az: "az",
    Bg: "bg",
    Bn: "bn",
    Bs: "bs",
    CaEs: "ca-ES",
    Cnr: "cnr",
    Cs: "cs",
    Cy: "cy",
    Da: "da",
    De: "de",
    El: "el",
    En: "en",
    EnCa: "en-CA",
    Es: "es",
    Es419: "es-419",
    EsAr: "es-AR",
    EsMx: "es-MX",
    Et: "et",
    EuEs: "eu-ES",
    Fa: "fa",
    Fi: "fi",
    Fr: "fr",
    FrCa: "fr-CA",
    FrFr: "fr-FR",
    GlEs: "gl-ES",
    Gu: "gu",
    He: "he",
    Hi: "hi",
    Hr: "hr",
    Hu: "hu",
    Hy: "hy",
    Id: "id",
    Is: "is",
    It: "it",
    Ja: "ja",
    Ka: "ka",
    Kk: "kk",
    Kn: "kn",
    Ko: "ko",
    Lt: "lt",
    Lv: "lv",
    Mk: "mk",
    Ml: "ml",
    Mn: "mn",
    Mr: "mr",
    Ms: "ms",
    My: "my",
    Nb: "nb",
    Nl: "nl",
    Nn: "nn",
    No: "no",
    Pa: "pa",
    Pl: "pl",
    Pt: "pt",
    PtBr: "pt-BR",
    PtPt: "pt-PT",
    Ro: "ro",
    Ru: "ru",
    Sk: "sk",
    Sl: "sl",
    So: "so",
    Sq: "sq",
    Sr: "sr",
    Sv: "sv",
    Sw: "sw",
    Ta: "ta",
    Te: "te",
    Th: "th",
    Tl: "tl",
    Tr: "tr",
    Uk: "uk",
    Ur: "ur",
    Vi: "vi",
    Zgh: "zgh",
    ZhCn: "zh-CN",
    ZhHk: "zh-HK",
    ZhTw: "zh-TW",
} as const;
export type PromptLanguageEnum = (typeof PromptLanguageEnum)[keyof typeof PromptLanguageEnum];

export interface PublicKeyCredential {
    credential_type: Management.PublicKeyCredentialTypeEnum;
    /** Friendly name for a credential. */
    name?: string;
    /** PEM-formatted public key (SPKI and PKCS1) or X509 certificate. Must be JSON escaped. */
    pem: string;
    alg?: Management.PublicKeyCredentialAlgorithmEnum;
    /** Parse expiry from x509 certificate. If true, attempts to parse the expiry date from the provided PEM. Applies to `public_key` credential type. */
    parse_expiry_from_cert?: boolean;
    /** The ISO 8601 formatted date representing the expiration of the credential. If not specified (not recommended), the credential never expires. Applies to `public_key` credential type. */
    expires_at?: string;
}

/** Algorithm which will be used with the credential. Can be one of RS256, RS384, PS256. If not specified, RS256 will be used. Applies to `public_key` credential type. */
export const PublicKeyCredentialAlgorithmEnum = {
    Rs256: "RS256",
    Rs384: "RS384",
    Ps256: "PS256",
} as const;
export type PublicKeyCredentialAlgorithmEnum =
    (typeof PublicKeyCredentialAlgorithmEnum)[keyof typeof PublicKeyCredentialAlgorithmEnum];

/**
 * Credential type. Supported types: public_key.
 */
export type PublicKeyCredentialTypeEnum = "public_key";

export type RefreshTokenDate =
    /**
     * The date and time when the refresh token was created */
    string | Management.RefreshTokenDateObject;

/**
 * The date and time when the refresh token was created
 */
export type RefreshTokenDateObject = Record<string, unknown>;

/**
 * Device used while issuing/exchanging the refresh token
 */
export interface RefreshTokenDevice {
    /** First IP address associated with the refresh token */
    initial_ip?: string;
    /** First autonomous system number associated with the refresh token */
    initial_asn?: string;
    /** First user agent associated with the refresh token */
    initial_user_agent?: string;
    /** Last IP address associated with the refresh token */
    last_ip?: string;
    /** Last autonomous system number associated with the refresh token */
    last_asn?: string;
    /** Last user agent associated with the refresh token */
    last_user_agent?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** Refresh token expiration types, one of: expiring, non-expiring */
export const RefreshTokenExpirationTypeEnum = {
    Expiring: "expiring",
    NonExpiring: "non-expiring",
} as const;
export type RefreshTokenExpirationTypeEnum =
    (typeof RefreshTokenExpirationTypeEnum)[keyof typeof RefreshTokenExpirationTypeEnum];

export interface RefreshTokenResourceServer {
    /** Resource server ID */
    audience?: string;
    /** List of scopes for the refresh token */
    scopes?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface RefreshTokenResponseContent {
    /** The ID of the refresh token */
    id?: string;
    /** ID of the user which can be used when interacting with other APIs. */
    user_id?: string;
    created_at?: Management.RefreshTokenDate;
    idle_expires_at?: Management.RefreshTokenDate;
    expires_at?: Management.RefreshTokenDate;
    device?: Management.RefreshTokenDevice;
    /** ID of the client application granted with this refresh token */
    client_id?: string;
    session_id?: (Management.RefreshTokenSessionId | undefined) | null;
    /** True if the token is a rotating refresh token */
    rotating?: boolean;
    /** A list of the resource server IDs associated to this refresh-token and their granted scopes */
    resource_servers?: Management.RefreshTokenResourceServer[];
    last_exchanged_at?: Management.RefreshTokenDate;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** Refresh token rotation types, one of: rotating, non-rotating */
export const RefreshTokenRotationTypeEnum = {
    Rotating: "rotating",
    NonRotating: "non-rotating",
} as const;
export type RefreshTokenRotationTypeEnum =
    (typeof RefreshTokenRotationTypeEnum)[keyof typeof RefreshTokenRotationTypeEnum];

/**
 * ID of the authenticated session used to obtain this refresh-token
 */
export type RefreshTokenSessionId = (string | null) | undefined;

export interface RegenerateUsersRecoveryCodeResponseContent {
    /** New account recovery code. */
    recovery_code?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export type ResetPhoneTemplateRequestContent = unknown;

export interface ResetPhoneTemplateResponseContent {
    id: string;
    channel?: string;
    customizable?: boolean;
    tenant?: string;
    content: Management.PhoneTemplateContent;
    type: Management.PhoneTemplateNotificationTypeEnum;
    /** Whether the template is enabled (false) or disabled (true). */
    disabled: boolean;
}

export interface ResourceServer {
    /** ID of the API (resource server). */
    id?: string;
    /** Friendly name for this resource server. Can not contain `<` or `>` characters. */
    name?: string;
    /** Whether this is an Auth0 system API (true) or a custom API (false). */
    is_system?: boolean;
    /** Unique identifier for the API used as the audience parameter on authorization calls. Can not be changed once set. */
    identifier?: string;
    /** List of permissions (scopes) that this API uses. */
    scopes?: Management.ResourceServerScope[];
    signing_alg?: Management.SigningAlgorithmEnum;
    /** Secret used to sign tokens when using symmetric algorithms (HS256). */
    signing_secret?: string;
    /** Whether refresh tokens can be issued for this API (true) or not (false). */
    allow_offline_access?: boolean;
    /** Whether to skip user consent for applications flagged as first party (true) or not (false). */
    skip_consent_for_verifiable_first_party_clients?: boolean;
    /** Expiration value (in seconds) for access tokens issued for this API from the token endpoint. */
    token_lifetime?: number;
    /** Expiration value (in seconds) for access tokens issued for this API via Implicit or Hybrid Flows. Cannot be greater than the `token_lifetime` value. */
    token_lifetime_for_web?: number;
    /** Whether authorization polices are enforced (true) or unenforced (false). */
    enforce_policies?: boolean;
    token_dialect?: Management.ResourceServerTokenDialectResponseEnum;
    token_encryption?: Management.ResourceServerTokenEncryption | null;
    consent_policy?: (Management.ResourceServerConsentPolicyEnum | undefined) | null;
    authorization_details?: unknown[];
    proof_of_possession?: Management.ResourceServerProofOfPossession | null;
    subject_type_authorization?: Management.ResourceServerSubjectTypeAuthorization;
    /** The client ID of the client that this resource server is linked to */
    client_id?: string;
}

export type ResourceServerConsentPolicyEnum = ("transactional-authorization-with-mfa" | null) | undefined;

/**
 * Proof-of-Possession configuration for access tokens
 */
export interface ResourceServerProofOfPossession {
    mechanism: Management.ResourceServerProofOfPossessionMechanismEnum;
    /** Whether the use of Proof-of-Possession is required for the resource server */
    required: boolean;
}

/** Intended mechanism for Proof-of-Possession */
export const ResourceServerProofOfPossessionMechanismEnum = {
    Mtls: "mtls",
    Dpop: "dpop",
} as const;
export type ResourceServerProofOfPossessionMechanismEnum =
    (typeof ResourceServerProofOfPossessionMechanismEnum)[keyof typeof ResourceServerProofOfPossessionMechanismEnum];

export interface ResourceServerScope {
    /** Value of this scope. */
    value: string;
    /** User-friendly description of this scope. */
    description?: string;
}

/**
 * Defines application access permission for a resource server. Use of this field is subject to the applicable Free Trial terms in Oktaâ€™s <a href="https://www.okta.com/legal/"> Master Subscription Agreement.</a>
 */
export interface ResourceServerSubjectTypeAuthorization {
    user?: Management.ResourceServerSubjectTypeAuthorizationUser;
    client?: Management.ResourceServerSubjectTypeAuthorizationClient;
}

/**
 * Access Permissions for client flows
 */
export interface ResourceServerSubjectTypeAuthorizationClient {
    policy?: Management.ResourceServerSubjectTypeAuthorizationClientPolicyEnum;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** Defines the client flows policy for the resource server */
export const ResourceServerSubjectTypeAuthorizationClientPolicyEnum = {
    DenyAll: "deny_all",
    RequireClientGrant: "require_client_grant",
} as const;
export type ResourceServerSubjectTypeAuthorizationClientPolicyEnum =
    (typeof ResourceServerSubjectTypeAuthorizationClientPolicyEnum)[keyof typeof ResourceServerSubjectTypeAuthorizationClientPolicyEnum];

/**
 * Access Permissions for user flows
 */
export interface ResourceServerSubjectTypeAuthorizationUser {
    policy?: Management.ResourceServerSubjectTypeAuthorizationUserPolicyEnum;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** Defines the user flows policy for the resource server */
export const ResourceServerSubjectTypeAuthorizationUserPolicyEnum = {
    AllowAll: "allow_all",
    DenyAll: "deny_all",
    RequireClientGrant: "require_client_grant",
} as const;
export type ResourceServerSubjectTypeAuthorizationUserPolicyEnum =
    (typeof ResourceServerSubjectTypeAuthorizationUserPolicyEnum)[keyof typeof ResourceServerSubjectTypeAuthorizationUserPolicyEnum];

/** Dialect of access tokens that should be issued. `access_token` is a JWT containing standard Auth0 claims; `rfc9068_profile` is a JWT conforming to the IETF JWT Access Token Profile. `access_token_authz` and `rfc9068_profile_authz` additionally include RBAC permissions claims. */
export const ResourceServerTokenDialectResponseEnum = {
    AccessToken: "access_token",
    AccessTokenAuthz: "access_token_authz",
    Rfc9068Profile: "rfc9068_profile",
    Rfc9068ProfileAuthz: "rfc9068_profile_authz",
} as const;
export type ResourceServerTokenDialectResponseEnum =
    (typeof ResourceServerTokenDialectResponseEnum)[keyof typeof ResourceServerTokenDialectResponseEnum];

/** Dialect of issued access token. `access_token` is a JWT containing standard Auth0 claims; `rfc9068_profile` is a JWT conforming to the IETF JWT Access Token Profile. `access_token_authz` and `rfc9068_profile_authz` additionally include RBAC permissions claims. */
export const ResourceServerTokenDialectSchemaEnum = {
    AccessToken: "access_token",
    AccessTokenAuthz: "access_token_authz",
    Rfc9068Profile: "rfc9068_profile",
    Rfc9068ProfileAuthz: "rfc9068_profile_authz",
} as const;
export type ResourceServerTokenDialectSchemaEnum =
    (typeof ResourceServerTokenDialectSchemaEnum)[keyof typeof ResourceServerTokenDialectSchemaEnum];

export interface ResourceServerTokenEncryption {
    format: Management.ResourceServerTokenEncryptionFormatEnum;
    encryption_key: Management.ResourceServerTokenEncryptionKey;
}

/** Algorithm used to encrypt the token. */
export const ResourceServerTokenEncryptionAlgorithmEnum = {
    RsaOaep256: "RSA-OAEP-256",
    RsaOaep384: "RSA-OAEP-384",
    RsaOaep512: "RSA-OAEP-512",
} as const;
export type ResourceServerTokenEncryptionAlgorithmEnum =
    (typeof ResourceServerTokenEncryptionAlgorithmEnum)[keyof typeof ResourceServerTokenEncryptionAlgorithmEnum];

/**
 * Format of the encrypted JWT payload.
 */
export type ResourceServerTokenEncryptionFormatEnum = "compact-nested-jwe";

export interface ResourceServerTokenEncryptionKey {
    /** Name of the encryption key. */
    name?: string;
    alg: Management.ResourceServerTokenEncryptionAlgorithmEnum;
    /** Key ID. */
    kid?: string;
    /** PEM-formatted public key. Must be JSON escaped. */
    pem: string;
}

/**
 * PEM-encoded certificate
 */
export type ResourceServerVerificationKeyPemCertificate = string;

export interface RevokedSigningKeysResponseContent {
    /** Revoked key certificate */
    cert: string;
    /** Revoked key id */
    kid: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface Role {
    /** ID for this role. */
    id?: string;
    /** Name of this role. */
    name?: string;
    /** Description of this role. */
    description?: string;
}

export interface RoleUser {
    /** ID of this user. */
    user_id?: string;
    /** URL to a picture for this user. */
    picture?: string;
    /** Name of this user. */
    name?: string;
    /** Email address of this user. */
    email?: string;
}

export interface RotateClientSecretResponseContent {
    /** ID of this client. */
    client_id?: string;
    /** Name of the tenant this client belongs to. */
    tenant?: string;
    /** Name of this client (min length: 1 character, does not allow `<` or `>`). */
    name?: string;
    /** Free text description of this client (max length: 140 characters). */
    description?: string;
    /** Whether this is your global 'All Applications' client representing legacy tenant settings (true) or a regular client (false). */
    global?: boolean;
    /** Client secret (which you must not make public). */
    client_secret?: string;
    app_type?: Management.ClientAppTypeEnum;
    /** URL of the logo to display for this client. Recommended size is 150x150 pixels. */
    logo_uri?: string;
    /** Whether this client a first party client (true) or not (false). */
    is_first_party?: boolean;
    /** Whether this client conforms to <a href='https://auth0.com/docs/api-auth/tutorials/adoption'>strict OIDC specifications</a> (true) or uses legacy features (false). */
    oidc_conformant?: boolean;
    /** Comma-separated list of URLs whitelisted for Auth0 to use as a callback to the client after authentication. */
    callbacks?: string[];
    /** Comma-separated list of URLs allowed to make requests from JavaScript to Auth0 API (typically used with CORS). By default, all your callback URLs will be allowed. This field allows you to enter other origins if necessary. You can also use wildcards at the subdomain level (e.g., https://*.contoso.com). Query strings and hash information are not taken into account when validating these URLs. */
    allowed_origins?: string[];
    /** Comma-separated list of allowed origins for use with <a href='https://auth0.com/docs/cross-origin-authentication'>Cross-Origin Authentication</a>, <a href='https://auth0.com/docs/flows/concepts/device-auth'>Device Flow</a>, and <a href='https://auth0.com/docs/protocols/oauth2#how-response-mode-works'>web message response mode</a>. */
    web_origins?: string[];
    /** List of audiences/realms for SAML protocol. Used by the wsfed addon. */
    client_aliases?: string[];
    /** List of allow clients and API ids that are allowed to make delegation requests. Empty means all all your clients are allowed. */
    allowed_clients?: string[];
    /** Comma-separated list of URLs that are valid to redirect to after logout from Auth0. Wildcards are allowed for subdomains. */
    allowed_logout_urls?: string[];
    session_transfer?: Management.ClientSessionTransferConfiguration | null;
    oidc_logout?: Management.ClientOidcBackchannelLogoutSettings;
    /** List of grant types supported for this application. Can include `authorization_code`, `implicit`, `refresh_token`, `client_credentials`, `password`, `http://auth0.com/oauth/grant-type/password-realm`, `http://auth0.com/oauth/grant-type/mfa-oob`, `http://auth0.com/oauth/grant-type/mfa-otp`, `http://auth0.com/oauth/grant-type/mfa-recovery-code`, `urn:openid:params:grant-type:ciba`, `urn:ietf:params:oauth:grant-type:device_code`, and `urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token`. */
    grant_types?: string[];
    jwt_configuration?: Management.ClientJwtConfiguration;
    signing_keys?: Management.ClientSigningKeys;
    encryption_key?: Management.ClientEncryptionKey | null;
    /** Applies only to SSO clients and determines whether Auth0 will handle Single Sign On (true) or whether the Identity Provider will (false). */
    sso?: boolean;
    /** Whether Single Sign On is disabled (true) or enabled (true). Defaults to true. */
    sso_disabled?: boolean;
    /** Whether this client can be used to make cross-origin authentication requests (true) or it is not allowed to make such requests (false). */
    cross_origin_authentication?: boolean;
    /** URL of the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page. */
    cross_origin_loc?: string;
    /** Whether a custom login page is to be used (true) or the default provided login page (false). */
    custom_login_page_on?: boolean;
    /** The content (HTML, CSS, JS) of the custom login page. */
    custom_login_page?: string;
    /** The content (HTML, CSS, JS) of the custom login page. (Used on Previews) */
    custom_login_page_preview?: string;
    /** HTML form template to be used for WS-Federation. */
    form_template?: string;
    addons?: Management.ClientAddons;
    token_endpoint_auth_method?: Management.ClientTokenEndpointAuthMethodEnum;
    /** If true, trust that the IP specified in the `auth0-forwarded-for` header is the end-user's IP for brute-force-protection on token endpoint. */
    is_token_endpoint_ip_header_trusted?: boolean;
    client_metadata?: Management.ClientMetadata;
    mobile?: Management.ClientMobile;
    /** Initiate login uri, must be https */
    initiate_login_uri?: string;
    refresh_token?: Management.ClientRefreshTokenConfiguration | null;
    default_organization?: Management.ClientDefaultOrganization | null;
    organization_usage?: Management.ClientOrganizationUsageEnum;
    organization_require_behavior?: Management.ClientOrganizationRequireBehaviorEnum;
    /** Defines the available methods for organization discovery during the `pre_login_prompt`. Users can discover their organization either by `email`, `organization_name` or both. */
    organization_discovery_methods?: Management.ClientOrganizationDiscoveryEnum[];
    client_authentication_methods?: Management.ClientAuthenticationMethod | null;
    /** Makes the use of Pushed Authorization Requests mandatory for this client */
    require_pushed_authorization_requests?: boolean;
    /** Makes the use of Proof-of-Possession mandatory for this client */
    require_proof_of_possession?: boolean;
    signed_request_object?: Management.ClientSignedRequestObjectWithCredentialId;
    compliance_level?: Management.ClientComplianceLevelEnum | null;
    /**
     * Controls whether a confirmation prompt is shown during login flows when the redirect URI uses non-verifiable callback URIs (for example, a custom URI schema such as `myapp://`, or `localhost`).
     * If set to true, a confirmation prompt will not be shown. We recommend that this is set to false for improved protection from malicious apps.
     * See https://auth0.com/docs/secure/security-guidance/measures-against-app-impersonation for more information.
     */
    skip_non_verifiable_callback_uri_confirmation_prompt?: boolean;
    /** Specifies how long, in seconds, a Pushed Authorization Request URI remains valid */
    par_request_expiry?: number | null;
    token_quota?: Management.TokenQuota;
    express_configuration?: Management.ExpressConfiguration;
    /** The identifier of the resource server that this client is linked to. */
    resource_server_identifier?: string;
    async_approval_notification_channels?: Management.ClientAsyncApprovalNotificationsChannelsApiPostConfiguration;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface RotateConnectionKeysRequestContent {
    signing_alg?: Management.RotateConnectionKeysSigningAlgEnum;
}

/** Selected Signing Algorithm */
export const RotateConnectionKeysSigningAlgEnum = {
    Rs256: "RS256",
    Rs512: "RS512",
    Ps256: "PS256",
    Es256: "ES256",
} as const;
export type RotateConnectionKeysSigningAlgEnum =
    (typeof RotateConnectionKeysSigningAlgEnum)[keyof typeof RotateConnectionKeysSigningAlgEnum];

export interface RotateConnectionsKeysResponseContent {
    /** The key id of the signing key */
    kid: string;
    /** The public certificate of the signing key */
    cert: string;
    /** The public certificate of the signing key in pkcs7 format */
    pkcs?: string;
    /** True if the key is the the next key */
    next?: boolean;
    /** The cert fingerprint */
    fingerprint: string;
    /** The cert thumbprint */
    thumbprint: string;
    /** Signing key algorithm */
    algorithm?: string;
    key_use?: Management.ConnectionKeyUseEnum;
    subject_dn?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface RotateSigningKeysResponseContent {
    /** Next key certificate */
    cert: string;
    /** Next key id */
    kid: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface Rule {
    /** Name of this rule. */
    name?: string;
    /** ID of this rule. */
    id?: string;
    /** Whether the rule is enabled (true), or disabled (false). */
    enabled?: boolean;
    /** Code to be executed when this rule runs. */
    script?: string;
    /** Order that this rule should execute in relative to other rules. Lower-valued rules execute first. */
    order?: number;
    /** Execution stage of this rule. Can be `login_success`, `login_failure`, or `pre_authorize`. */
    stage?: string;
}

export interface RulesConfig {
    /** Key for a rules config variable. */
    key?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface ScimMappingItem {
    /** The field location in the auth0 schema */
    auth0?: string;
    /** The field location in the SCIM schema */
    scim?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface ScimTokenItem {
    /** The token's identifier */
    token_id?: string;
    /** The scopes of the scim token */
    scopes?: string[];
    /** The token's created at timestamp */
    created_at?: string;
    /** The token's valid until timestamp */
    valid_until?: string;
    /** The token's last used at timestamp */
    last_used_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** Name of the screen */
export const ScreenGroupNameEnum = {
    Login: "login",
    LoginId: "login-id",
    LoginPassword: "login-password",
    LoginPasswordlessEmailCode: "login-passwordless-email-code",
    LoginPasswordlessEmailLink: "login-passwordless-email-link",
    LoginPasswordlessSmsOtp: "login-passwordless-sms-otp",
    LoginEmailVerification: "login-email-verification",
    Signup: "signup",
    SignupId: "signup-id",
    SignupPassword: "signup-password",
    PhoneIdentifierEnrollment: "phone-identifier-enrollment",
    PhoneIdentifierChallenge: "phone-identifier-challenge",
    EmailIdentifierChallenge: "email-identifier-challenge",
    ResetPasswordRequest: "reset-password-request",
    ResetPasswordEmail: "reset-password-email",
    ResetPassword: "reset-password",
    ResetPasswordSuccess: "reset-password-success",
    ResetPasswordError: "reset-password-error",
    ResetPasswordMfaEmailChallenge: "reset-password-mfa-email-challenge",
    ResetPasswordMfaOtpChallenge: "reset-password-mfa-otp-challenge",
    ResetPasswordMfaPhoneChallenge: "reset-password-mfa-phone-challenge",
    ResetPasswordMfaPushChallengePush: "reset-password-mfa-push-challenge-push",
    ResetPasswordMfaRecoveryCodeChallenge: "reset-password-mfa-recovery-code-challenge",
    ResetPasswordMfaSmsChallenge: "reset-password-mfa-sms-challenge",
    ResetPasswordMfaVoiceChallenge: "reset-password-mfa-voice-challenge",
    ResetPasswordMfaWebauthnPlatformChallenge: "reset-password-mfa-webauthn-platform-challenge",
    ResetPasswordMfaWebauthnRoamingChallenge: "reset-password-mfa-webauthn-roaming-challenge",
    CustomForm: "custom-form",
    Consent: "consent",
    CustomizedConsent: "customized-consent",
    Logout: "logout",
    LogoutComplete: "logout-complete",
    LogoutAborted: "logout-aborted",
    MfaPushWelcome: "mfa-push-welcome",
    MfaPushEnrollmentQr: "mfa-push-enrollment-qr",
    MfaPushEnrollmentCode: "mfa-push-enrollment-code",
    MfaPushSuccess: "mfa-push-success",
    MfaPushChallengePush: "mfa-push-challenge-push",
    MfaPushList: "mfa-push-list",
    MfaOtpEnrollmentQr: "mfa-otp-enrollment-qr",
    MfaOtpEnrollmentCode: "mfa-otp-enrollment-code",
    MfaOtpChallenge: "mfa-otp-challenge",
    MfaVoiceEnrollment: "mfa-voice-enrollment",
    MfaVoiceChallenge: "mfa-voice-challenge",
    MfaPhoneChallenge: "mfa-phone-challenge",
    MfaPhoneEnrollment: "mfa-phone-enrollment",
    MfaWebauthnPlatformEnrollment: "mfa-webauthn-platform-enrollment",
    MfaWebauthnRoamingEnrollment: "mfa-webauthn-roaming-enrollment",
    MfaWebauthnPlatformChallenge: "mfa-webauthn-platform-challenge",
    MfaWebauthnRoamingChallenge: "mfa-webauthn-roaming-challenge",
    MfaWebauthnChangeKeyNickname: "mfa-webauthn-change-key-nickname",
    MfaWebauthnEnrollmentSuccess: "mfa-webauthn-enrollment-success",
    MfaWebauthnError: "mfa-webauthn-error",
    MfaWebauthnNotAvailableError: "mfa-webauthn-not-available-error",
    MfaCountryCodes: "mfa-country-codes",
    MfaSmsEnrollment: "mfa-sms-enrollment",
    MfaSmsChallenge: "mfa-sms-challenge",
    MfaSmsList: "mfa-sms-list",
    MfaEmailChallenge: "mfa-email-challenge",
    MfaEmailList: "mfa-email-list",
    MfaRecoveryCodeEnrollment: "mfa-recovery-code-enrollment",
    MfaRecoveryCodeChallengeNewCode: "mfa-recovery-code-challenge-new-code",
    MfaRecoveryCodeChallenge: "mfa-recovery-code-challenge",
    MfaDetectBrowserCapabilities: "mfa-detect-browser-capabilities",
    MfaEnrollResult: "mfa-enroll-result",
    MfaLoginOptions: "mfa-login-options",
    MfaBeginEnrollOptions: "mfa-begin-enroll-options",
    Status: "status",
    DeviceCodeActivation: "device-code-activation",
    DeviceCodeActivationAllowed: "device-code-activation-allowed",
    DeviceCodeActivationDenied: "device-code-activation-denied",
    DeviceCodeConfirmation: "device-code-confirmation",
    EmailVerificationResult: "email-verification-result",
    EmailOtpChallenge: "email-otp-challenge",
    OrganizationSelection: "organization-selection",
    OrganizationPicker: "organization-picker",
    PreLoginOrganizationPicker: "pre-login-organization-picker",
    AcceptInvitation: "accept-invitation",
    RedeemTicket: "redeem-ticket",
    PasskeyEnrollment: "passkey-enrollment",
    PasskeyEnrollmentLocal: "passkey-enrollment-local",
    InterstitialCaptcha: "interstitial-captcha",
    BruteForceProtectionUnblock: "brute-force-protection-unblock",
    BruteForceProtectionUnblockSuccess: "brute-force-protection-unblock-success",
    BruteForceProtectionUnblockFailure: "brute-force-protection-unblock-failure",
    AsyncApprovalError: "async-approval-error",
    AsyncApprovalWrongUser: "async-approval-wrong-user",
    AsyncApprovalAccepted: "async-approval-accepted",
    AsyncApprovalDenied: "async-approval-denied",
} as const;
export type ScreenGroupNameEnum = (typeof ScreenGroupNameEnum)[keyof typeof ScreenGroupNameEnum];

/** The version of the search engine */
export const SearchEngineVersionsEnum = {
    V1: "v1",
    V2: "v2",
    V3: "v3",
} as const;
export type SearchEngineVersionsEnum = (typeof SearchEngineVersionsEnum)[keyof typeof SearchEngineVersionsEnum];

export interface SelfServiceProfile {
    /** The unique ID of the self-service Profile. */
    id?: string;
    /** The name of the self-service Profile. */
    name?: string;
    /** The description of the self-service Profile. */
    description?: string;
    /** List of attributes to be mapped that will be shown to the user during the SS-SSO flow. */
    user_attributes?: Management.SelfServiceProfileUserAttribute[];
    /** The time when this self-service Profile was created. */
    created_at?: string;
    /** The time when this self-service Profile was updated. */
    updated_at?: string;
    branding?: Management.SelfServiceProfileBrandingProperties;
    /** List of IdP strategies that will be shown to users during the Self-Service SSO flow. Possible values: [`oidc`, `samlp`, `waad`, `google-apps`, `adfs`, `okta`, `keycloak-samlp`, `pingfederate`] */
    allowed_strategies?: Management.SelfServiceProfileAllowedStrategyEnum[];
    /** ID of the user-attribute-profile to associate with this self-service profile. */
    user_attribute_profile_id?: string;
}

export const SelfServiceProfileAllowedStrategyEnum = {
    Oidc: "oidc",
    Samlp: "samlp",
    Waad: "waad",
    GoogleApps: "google-apps",
    Adfs: "adfs",
    Okta: "okta",
    KeycloakSamlp: "keycloak-samlp",
    Pingfederate: "pingfederate",
} as const;
export type SelfServiceProfileAllowedStrategyEnum =
    (typeof SelfServiceProfileAllowedStrategyEnum)[keyof typeof SelfServiceProfileAllowedStrategyEnum];

export type SelfServiceProfileBranding = (Management.SelfServiceProfileBrandingProperties | null) | undefined;

export interface SelfServiceProfileBrandingColors {
    primary: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface SelfServiceProfileBrandingProperties {
    logo_url?: string;
    colors?: Management.SelfServiceProfileBrandingColors;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * The language of the custom text.
 */
export type SelfServiceProfileCustomTextLanguageEnum = "en";

/**
 * The page where the custom text is shown.
 */
export type SelfServiceProfileCustomTextPageEnum = "get-started";

/**
 * The description of the self-service Profile.
 */
export type SelfServiceProfileDescription = (string | null) | undefined;

/**
 * If provided, this will create a new connection for the SSO flow with the given configuration
 */
export interface SelfServiceProfileSsoTicketConnectionConfig {
    /** The name of the connection that will be created as a part of the SSO flow. */
    name: string;
    /** Connection name used in the new universal login experience */
    display_name?: string;
    /** <code>true</code> promotes to a domain-level connection so that third-party applications can use it. <code>false</code> does not promote the connection, so only first-party applications with the connection enabled can use it. (Defaults to <code>false</code>.) */
    is_domain_connection?: boolean;
    /** Enables showing a button for the connection in the login page (new experience only). If false, it will be usable only by HRD. (Defaults to <code>false</code>.) */
    show_as_button?: boolean;
    metadata?: Management.ConnectionsMetadata;
    options?: Management.SelfServiceProfileSsoTicketConnectionOptions | null;
}

/**
 * The connection's options (depend on the connection strategy)
 */
export interface SelfServiceProfileSsoTicketConnectionOptions {
    /** URL for the icon. Must use HTTPS. */
    icon_url?: string | null;
    /** List of domain_aliases that can be authenticated in the Identity Provider */
    domain_aliases?: string[];
    idpinitiated?: Management.SelfServiceProfileSsoTicketIdpInitiatedOptions | null;
}

/**
 * Configuration for the setup of the connectionâ€™s domain_aliases in the self-service SSO flow.
 */
export interface SelfServiceProfileSsoTicketDomainAliasesConfig {
    domain_verification: Management.SelfServiceProfileSsoTicketDomainVerificationEnum;
}

/** Whether the end user should complete the domain verification step. Possible values are 'none' (the step is not shown to the user), 'optional' (the user may add a domain alias in the domain verification step) or 'required' (the user must add a domain alias in order to enable the connection). Defaults to 'none'. */
export const SelfServiceProfileSsoTicketDomainVerificationEnum = {
    None: "none",
    Optional: "optional",
    Required: "required",
} as const;
export type SelfServiceProfileSsoTicketDomainVerificationEnum =
    (typeof SelfServiceProfileSsoTicketDomainVerificationEnum)[keyof typeof SelfServiceProfileSsoTicketDomainVerificationEnum];

export interface SelfServiceProfileSsoTicketEnabledOrganization {
    /** Organization identifier. */
    organization_id: string;
    /** When true, all users that log in with this connection will be automatically granted membership in the organization. When false, users must be granted membership in the organization before logging in with this connection. */
    assign_membership_on_login?: boolean;
    /** Determines whether a connection should be displayed on this organizationâ€™s login prompt. Only applicable for enterprise connections. Default: true. */
    show_as_button?: boolean;
}

/** The protocol used to connect to the the default application */
export const SelfServiceProfileSsoTicketIdpInitiatedClientProtocolEnum = {
    Samlp: "samlp",
    Wsfed: "wsfed",
    Oauth2: "oauth2",
} as const;
export type SelfServiceProfileSsoTicketIdpInitiatedClientProtocolEnum =
    (typeof SelfServiceProfileSsoTicketIdpInitiatedClientProtocolEnum)[keyof typeof SelfServiceProfileSsoTicketIdpInitiatedClientProtocolEnum];

/**
 * Allows IdP-initiated login
 */
export interface SelfServiceProfileSsoTicketIdpInitiatedOptions {
    /** Enables IdP-initiated login for this connection */
    enabled?: boolean;
    /** Default application <code>client_id</code> user is redirected to after validated SAML response */
    client_id?: string;
    client_protocol?: Management.SelfServiceProfileSsoTicketIdpInitiatedClientProtocolEnum;
    /** Query string options to customize the behaviour for OpenID Connect when <code>idpinitiated.client_protocol</code> is <code>oauth2</code>. Allowed parameters: <code>redirect_uri</code>, <code>scope</code>, <code>response_type</code>. For example, <code>redirect_uri=https://jwt.io&scope=openid email&response_type=token</code> */
    client_authorizequery?: string;
}

/**
 * Configuration for the setup of Provisioning in the self-service flow.
 */
export interface SelfServiceProfileSsoTicketProvisioningConfig {
    /** The scopes of the SCIM tokens generated during the self-service flow. */
    scopes?: Management.SelfServiceProfileSsoTicketProvisioningScopeEnum[];
    /** Lifetime of the tokens in seconds. Must be greater than 900. If not provided, the tokens don't expire. */
    token_lifetime?: number | null;
}

export const SelfServiceProfileSsoTicketProvisioningScopeEnum = {
    GetUsers: "get:users",
    PostUsers: "post:users",
    PutUsers: "put:users",
    PatchUsers: "patch:users",
    DeleteUsers: "delete:users",
} as const;
export type SelfServiceProfileSsoTicketProvisioningScopeEnum =
    (typeof SelfServiceProfileSsoTicketProvisioningScopeEnum)[keyof typeof SelfServiceProfileSsoTicketProvisioningScopeEnum];

export interface SelfServiceProfileUserAttribute {
    /** Identifier of this attribute. */
    name: string;
    /** Description of this attribute. */
    description: string;
    /** Determines if this attribute is required */
    is_optional: boolean;
}

/**
 * List of attributes to be mapped that will be shown to the user during the SS-SSO flow.
 */
export type SelfServiceProfileUserAttributes = (Management.SelfServiceProfileUserAttribute[] | null) | undefined;

/**
 * Authentication signal details
 */
export interface SessionAuthenticationSignal {
    /** One of: "federated", "passkey", "pwd", "sms", "email", "mfa", "mock" or a custom method denoted by a URL */
    name?: string;
    timestamp?: Management.SessionDate;
    /** A specific MFA factor. Only present when "name" is set to "mfa" */
    "^type$"?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Details about authentication signals obtained during the login flow
 */
export interface SessionAuthenticationSignals {
    /** Contains the authentication methods a user has completed during their session */
    methods?: Management.SessionAuthenticationSignal[];
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * Client details
 */
export interface SessionClientMetadata {
    /** ID of client for the session */
    client_id?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * [Private Early Access] Session cookie configuration.
 */
export interface SessionCookieMetadata {
    mode?: Management.SessionCookieMetadataModeEnum;
    /** Accepts any additional properties */
    [key: string]: any;
}

/** [Private Early Access] The persistence mode of the session cookie. When set to "non-persistent" (ephemeral), the cookie will be deleted when the browser is closed. When set to "persistent", the cookie will be stored until it expires or is deleted by the user. */
export const SessionCookieMetadataModeEnum = {
    NonPersistent: "non-persistent",
    Persistent: "persistent",
} as const;
export type SessionCookieMetadataModeEnum =
    (typeof SessionCookieMetadataModeEnum)[keyof typeof SessionCookieMetadataModeEnum];

/** Behavior of the session cookie */
export const SessionCookieModeEnum = {
    Persistent: "persistent",
    NonPersistent: "non-persistent",
} as const;
export type SessionCookieModeEnum = (typeof SessionCookieModeEnum)[keyof typeof SessionCookieModeEnum];

/**
 * Session cookie configuration
 */
export interface SessionCookieSchema {
    mode: Management.SessionCookieModeEnum;
}

export type SessionDate =
    /**
     * The date and time when the session was created */
    | string
    /**
     * The date and time when the session was created */
    | Record<string, unknown>;

/**
 * Metadata related to the device used in the session
 */
export interface SessionDeviceMetadata {
    /** First user agent of the device from which this user logged in */
    initial_user_agent?: string;
    initial_ip?: (Management.SessionIp | undefined) | null;
    /** First autonomous system number associated with this session */
    initial_asn?: string;
    /** Last user agent of the device from which this user logged in */
    last_user_agent?: string;
    last_ip?: (Management.SessionIp | undefined) | null;
    /** Last autonomous system number from which this user logged in */
    last_asn?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * First IP address associated with this session
 */
export type SessionIp = (string | null) | undefined;

/**
 * Metadata associated with the session, in the form of an object with string values (max 255 chars). Maximum of 25 metadata properties allowed.
 */
export type SessionMetadata = (Record<string, unknown> | null) | undefined;

export interface SessionResponseContent {
    /** The ID of the session */
    id?: string;
    /** ID of the user which can be used when interacting with other APIs. */
    user_id?: string;
    created_at?: Management.SessionDate;
    updated_at?: Management.SessionDate;
    authenticated_at?: Management.SessionDate;
    idle_expires_at?: Management.SessionDate;
    expires_at?: Management.SessionDate;
    last_interacted_at?: Management.SessionDate;
    device?: Management.SessionDeviceMetadata;
    /** List of client details for the session */
    clients?: Management.SessionClientMetadata[];
    authentication?: Management.SessionAuthenticationSignals;
    cookie?: Management.SessionCookieMetadata;
    session_metadata?: (Management.SessionMetadata | undefined) | null;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * JWKS representing an array of custom public signing keys.
 */
export interface SetCustomSigningKeysResponseContent {
    /** An array of custom public signing keys. */
    keys?: Management.CustomSigningKeyJwk[];
}

export interface SetEmailTemplateResponseContent {
    template: Management.EmailTemplateNameEnum;
    /** Body of the email template. */
    body?: string | null;
    /** Senders `from` email address. */
    from?: string | null;
    /** URL to redirect the user to after a successful action. */
    resultUrl?: string | null;
    /** Subject line of the email. */
    subject?: string | null;
    /** Syntax of the template body. */
    syntax?: string | null;
    /** Lifetime in seconds that the link within the email will be valid for. */
    urlLifetimeInSeconds?: number | null;
    /** Whether the `reset_email` and `verify_email` templates should include the user's email address as the `email` parameter in the returnUrl (true) or whether no email address should be included in the redirect (false). Defaults to true. */
    includeEmailInRedirect?: boolean;
    /** Whether the template is enabled (true) or disabled (false). */
    enabled?: boolean | null;
}

export interface SetGuardianFactorDuoSettingsResponseContent {
    ikey?: string;
    skey?: string;
    host?: string;
}

export interface SetGuardianFactorPhoneMessageTypesResponseContent {
    /** The list of phone factors to enable on the tenant. Can include `sms` and `voice`. */
    message_types?: Management.GuardianFactorPhoneFactorMessageTypeEnum[];
}

export interface SetGuardianFactorPhoneTemplatesResponseContent {
    /** Message sent to the user when they are invited to enroll with a phone number. */
    enrollment_message: string;
    /** Message sent to the user when they are prompted to verify their account. */
    verification_message: string;
}

export interface SetGuardianFactorResponseContent {
    /** Whether this factor is enabled (true) or disabled (false). */
    enabled: boolean;
}

export interface SetGuardianFactorSmsTemplatesResponseContent {
    /** Message sent to the user when they are invited to enroll with a phone number. */
    enrollment_message: string;
    /** Message sent to the user when they are prompted to verify their account. */
    verification_message: string;
}

export interface SetGuardianFactorsProviderPhoneResponseContent {
    provider?: Management.GuardianFactorsProviderSmsProviderEnum;
}

export interface SetGuardianFactorsProviderPhoneTwilioResponseContent {
    /** From number */
    from?: string | null;
    /** Copilot SID */
    messaging_service_sid?: string | null;
    /** Twilio Authentication token */
    auth_token?: string | null;
    /** Twilio SID */
    sid?: string | null;
}

export interface SetGuardianFactorsProviderPushNotificationApnsRequestContent {
    sandbox?: boolean;
    bundle_id?: string | null;
    p12?: string | null;
}

export interface SetGuardianFactorsProviderPushNotificationApnsResponseContent {
    sandbox?: boolean;
    bundle_id?: string | null;
}

export interface SetGuardianFactorsProviderPushNotificationFcmRequestContent {
    server_key?: string | null;
}

export type SetGuardianFactorsProviderPushNotificationFcmResponseContent = Record<string, unknown>;

export interface SetGuardianFactorsProviderPushNotificationFcmv1RequestContent {
    server_credentials?: string | null;
}

export type SetGuardianFactorsProviderPushNotificationFcmv1ResponseContent = Record<string, unknown>;

export interface SetGuardianFactorsProviderPushNotificationResponseContent {
    provider?: Management.GuardianFactorsProviderPushNotificationProviderDataEnum;
}

export interface SetGuardianFactorsProviderPushNotificationSnsResponseContent {
    aws_access_key_id?: string | null;
    aws_secret_access_key?: string | null;
    aws_region?: string | null;
    sns_apns_platform_application_arn?: string | null;
    sns_gcm_platform_application_arn?: string | null;
}

export interface SetGuardianFactorsProviderSmsResponseContent {
    provider?: Management.GuardianFactorsProviderSmsProviderEnum;
}

export interface SetGuardianFactorsProviderSmsTwilioResponseContent {
    /** From number */
    from?: string | null;
    /** Copilot SID */
    messaging_service_sid?: string | null;
    /** Twilio Authentication token */
    auth_token?: string | null;
    /** Twilio SID */
    sid?: string | null;
}

export type SetGuardianPoliciesRequestContent = Management.MfaPolicyEnum[];

export type SetGuardianPoliciesResponseContent = Management.MfaPolicyEnum[];

export interface SetNetworkAclsResponseContent {
    id?: string;
    description?: string;
    active?: boolean;
    priority?: number;
    rule?: Management.NetworkAclRule;
    /** The timestamp when the Network ACL Configuration was created */
    created_at?: string;
    /** The timestamp when the Network ACL Configuration was last updated */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * An object containing template partials for a group of screens.
 */
export type SetPartialsRequestContent = Record<string, unknown>;

export interface SetRulesConfigResponseContent {
    /** Key for a rules config variable. */
    key: string;
    /** Value for a rules config variable. */
    value: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * The list of text keys and values to customize the self-service SSO page. Values can be plain text or rich HTML content limited to basic styling tags and hyperlinks.
 */
export type SetSelfServiceProfileCustomTextRequestContent = Record<string, string>;

/**
 * The resulting list of custom text keys and values.
 */
export type SetSelfServiceProfileCustomTextResponseContent = Record<string, string>;

/**
 * The successfully created authentication method.
 */
export interface SetUserAuthenticationMethodResponseContent {
    /** The ID of the newly created authentication method (automatically generated by the application) */
    id?: string;
    type: Management.CreatedAuthenticationMethodTypeEnum;
    /** A human-readable label to identify the authentication method. */
    name?: string;
    /** Base32 encoded secret for TOTP generation */
    totp_secret?: string;
    /** Applies to phone authentication methods only. The destination phone number used to send verification codes via text and voice. */
    phone_number?: string;
    /** Applies to email authentication methods only. The email address used to send verification messages. */
    email?: string;
    authentication_methods?: Management.UserAuthenticationMethodProperties[];
    preferred_authentication_method?: Management.PreferredAuthenticationMethodEnum;
    /** Applies to webauthn authenticators only. The id of the credential. */
    key_id?: string;
    /** Applies to webauthn authenticators only. The public key. */
    public_key?: string;
    /** Applies to passkeys only. Authenticator Attestation Globally Unique Identifier. */
    aaguid?: string;
    /** Applies to webauthn authenticators only. The relying party identifier. */
    relying_party_identifier?: string;
    /** Authentication method creation date */
    created_at?: string;
}

export interface SetUserAuthenticationMethods {
    type: Management.AuthenticationTypeEnum;
    preferred_authentication_method?: Management.PreferredAuthenticationMethodEnum;
    /** AA human-readable label to identify the authentication method. */
    name?: string;
    /** Applies to phone authentication methods only. The destination phone number used to send verification codes via text and voice. */
    phone_number?: string;
    /** Applies to email authentication methods only. The email address used to send verification messages. */
    email?: string;
    /** Applies to totp authentication methods only. The base32 encoded secret for TOTP generation. */
    totp_secret?: string;
}

export type SetUserAuthenticationMethodsRequestContent = Management.SetUserAuthenticationMethods[];

/**
 * An object containing custom dictionaries for a group of screens.
 */
export type SetsCustomTextsByLanguageRequestContent = Record<string, unknown>;

/** Algorithm used to sign JWTs. Can be `HS256` or `RS256`. `PS256` available via addon. */
export const SigningAlgorithmEnum = {
    Hs256: "HS256",
    Rs256: "RS256",
    Rs512: "RS512",
    Ps256: "PS256",
} as const;
export type SigningAlgorithmEnum = (typeof SigningAlgorithmEnum)[keyof typeof SigningAlgorithmEnum];

export interface SigningKeys {
    /** The key id of the signing key */
    kid: string;
    /** The public certificate of the signing key */
    cert: string;
    /** The public certificate of the signing key in pkcs7 format */
    pkcs7?: string;
    /** True if the key is the the current key */
    current?: boolean;
    /** True if the key is the the next key */
    next?: boolean;
    /** True if the key is the the previous key */
    previous?: boolean;
    current_since?: Management.SigningKeysDate;
    current_until?: Management.SigningKeysDate;
    /** The cert fingerprint */
    fingerprint: string;
    /** The cert thumbprint */
    thumbprint: string;
    /** True if the key is revoked */
    revoked?: boolean;
    revoked_at?: Management.SigningKeysDate;
}

export type SigningKeysDate =
    /**
     * The date and time when the key became the current key */
    | string
    /**
     * The date and time when the key became the current key */
    | Record<string, unknown>;

export interface SignupSchema {
    status?: Management.SignupStatusEnum;
}

export const SignupStatusEnum = {
    Required: "required",
    Optional: "optional",
    Inactive: "inactive",
} as const;
export type SignupStatusEnum = (typeof SignupStatusEnum)[keyof typeof SignupStatusEnum];

export interface SignupVerification {
    active?: boolean;
}

export interface SignupVerified {
    status?: Management.SignupStatusEnum;
    verification?: Management.SignupVerification;
}

export const SupportedLocales = {
    Am: "am",
    Ar: "ar",
    ArEg: "ar-EG",
    ArSa: "ar-SA",
    Az: "az",
    Bg: "bg",
    Bn: "bn",
    Bs: "bs",
    CaEs: "ca-ES",
    Cnr: "cnr",
    Cs: "cs",
    Cy: "cy",
    Da: "da",
    De: "de",
    El: "el",
    En: "en",
    EnCa: "en-CA",
    Es: "es",
    Es419: "es-419",
    EsAr: "es-AR",
    EsMx: "es-MX",
    Et: "et",
    EuEs: "eu-ES",
    Fa: "fa",
    Fi: "fi",
    Fr: "fr",
    FrCa: "fr-CA",
    FrFr: "fr-FR",
    GlEs: "gl-ES",
    Gu: "gu",
    He: "he",
    Hi: "hi",
    Hr: "hr",
    Hu: "hu",
    Hy: "hy",
    Id: "id",
    Is: "is",
    It: "it",
    Ja: "ja",
    Ka: "ka",
    Kk: "kk",
    Kn: "kn",
    Ko: "ko",
    Lt: "lt",
    Lv: "lv",
    Mk: "mk",
    Ml: "ml",
    Mn: "mn",
    Mr: "mr",
    Ms: "ms",
    My: "my",
    Nb: "nb",
    Nl: "nl",
    Nn: "nn",
    No: "no",
    Pa: "pa",
    Pl: "pl",
    Pt: "pt",
    PtBr: "pt-BR",
    PtPt: "pt-PT",
    Ro: "ro",
    Ru: "ru",
    Sk: "sk",
    Sl: "sl",
    So: "so",
    Sq: "sq",
    Sr: "sr",
    Sv: "sv",
    Sw: "sw",
    Ta: "ta",
    Te: "te",
    Th: "th",
    Tl: "tl",
    Tr: "tr",
    Uk: "uk",
    Ur: "ur",
    Vi: "vi",
    Zgh: "zgh",
    ZhCn: "zh-CN",
    ZhHk: "zh-HK",
    ZhTw: "zh-TW",
} as const;
export type SupportedLocales = (typeof SupportedLocales)[keyof typeof SupportedLocales];

/**
 * List of trusted IP addresses that will not have attack protection enforced against them.
 */
export type SuspiciousIpThrottlingAllowlist = Management.SuspiciousIpThrottlingAllowlistItem[];

export type SuspiciousIpThrottlingAllowlistItem = string;

/**
 * Configuration options that apply before every login attempt.
 */
export interface SuspiciousIpThrottlingPreLoginStage {
    /** Total number of attempts allowed per day. */
    max_attempts?: number;
    /** Interval of time, given in milliseconds, at which new attempts are granted. */
    rate?: number;
}

/**
 * Configuration options that apply before every user registration attempt.
 */
export interface SuspiciousIpThrottlingPreUserRegistrationStage {
    /** Total number of attempts allowed. */
    max_attempts?: number;
    /** Interval of time, given in milliseconds, at which new attempts are granted. */
    rate?: number;
}

export const SuspiciousIpThrottlingShieldsEnum = {
    Block: "block",
    AdminNotification: "admin_notification",
} as const;
export type SuspiciousIpThrottlingShieldsEnum =
    (typeof SuspiciousIpThrottlingShieldsEnum)[keyof typeof SuspiciousIpThrottlingShieldsEnum];

/**
 * Holds per-stage configuration options (max_attempts and rate).
 */
export interface SuspiciousIpThrottlingStage {
    "pre-login"?: Management.SuspiciousIpThrottlingPreLoginStage;
    "pre-user-registration"?: Management.SuspiciousIpThrottlingPreUserRegistrationStage;
}

/**
 * Settings related to OIDC RP-initiated Logout
 */
export interface TenantOidcLogoutSettings {
    /** Enable the end_session_endpoint URL in the .well-known discovery configuration */
    rp_logout_end_session_endpoint_discovery?: boolean;
}

/**
 * Device Flow configuration
 */
export interface TenantSettingsDeviceFlow {
    charset?: Management.TenantSettingsDeviceFlowCharset;
    /** Mask used to format a generated User Code into a friendly, readable format. */
    mask?: string;
}

/** Character set used to generate a User Code. Can be `base20` or `digits`. */
export const TenantSettingsDeviceFlowCharset = {
    Base20: "base20",
    Digits: "digits",
} as const;
export type TenantSettingsDeviceFlowCharset =
    (typeof TenantSettingsDeviceFlowCharset)[keyof typeof TenantSettingsDeviceFlowCharset];

/**
 * Error page customization.
 */
export interface TenantSettingsErrorPage {
    /** Custom Error HTML (<a href='https://github.com/Shopify/liquid/wiki/Liquid-for-Designers'>Liquid syntax</a> is supported). */
    html?: string;
    /** Whether to show the link to log as part of the default error page (true, default) or not to show the link (false). */
    show_log_link?: boolean;
    /** URL to redirect to when an error occurs instead of showing the default error page. */
    url?: string;
}

/**
 * Flags used to change the behavior of this tenant.
 */
export interface TenantSettingsFlags {
    /** Whether to use the older v1 change password flow (true, not recommended except for backward compatibility) or the newer safer flow (false, recommended). */
    change_pwd_flow_v1?: boolean;
    /** Whether the APIs section is enabled (true) or disabled (false). */
    enable_apis_section?: boolean;
    /** Whether the impersonation functionality has been disabled (true) or not (false). Read-only. */
    disable_impersonation?: boolean;
    /** Whether all current connections should be enabled when a new client (application) is created (true, default) or not (false). */
    enable_client_connections?: boolean;
    /** Whether advanced API Authorization scenarios are enabled (true) or disabled (false). */
    enable_pipeline2?: boolean;
    /** If enabled, clients are able to add legacy delegation grants. */
    allow_legacy_delegation_grant_types?: boolean;
    /** If enabled, clients are able to add legacy RO grants. */
    allow_legacy_ro_grant_types?: boolean;
    /** Whether the legacy `/tokeninfo` endpoint is enabled for your account (true) or unavailable (false). */
    allow_legacy_tokeninfo_endpoint?: boolean;
    /** Whether ID tokens and the userinfo endpoint includes a complete user profile (true) or only OpenID Connect claims (false). */
    enable_legacy_profile?: boolean;
    /** Whether ID tokens can be used to authorize some types of requests to API v2 (true) not not (false). */
    enable_idtoken_api2?: boolean;
    /** Whether the public sign up process shows a user_exists error (true) or a generic error (false) if the user already exists. */
    enable_public_signup_user_exists_error?: boolean;
    /** Whether users are prompted to confirm log in before SSO redirection (false) or are not prompted (true). */
    enable_sso?: boolean;
    /** Whether the `enable_sso` setting can be changed (true) or not (false). */
    allow_changing_enable_sso?: boolean;
    /** Whether classic Universal Login prompts include additional security headers to prevent clickjacking (true) or no safeguard (false). */
    disable_clickjack_protection_headers?: boolean;
    /** Do not Publish Enterprise Connections Information with IdP domains on the lock configuration file. */
    no_disclose_enterprise_connections?: boolean;
    /** Enforce client authentication for passwordless start. */
    enforce_client_authentication_on_passwordless_start?: boolean;
    /** Enables the email verification flow during login for Azure AD and ADFS connections */
    enable_adfs_waad_email_verification?: boolean;
    /** Delete underlying grant when a Refresh Token is revoked via the Authentication API. */
    revoke_refresh_token_grant?: boolean;
    /** Enables beta access to log streaming changes */
    dashboard_log_streams_next?: boolean;
    /** Enables new insights activity page view */
    dashboard_insights_view?: boolean;
    /** Disables SAML fields map fix for bad mappings with repeated attributes */
    disable_fields_map_fix?: boolean;
    /** Used to allow users to pick what factor to enroll of the available MFA factors. */
    mfa_show_factor_list_on_enrollment?: boolean;
    /** Removes alg property from jwks .well-known endpoint */
    remove_alg_from_jwks?: boolean;
    /** Improves bot detection during signup in classic universal login */
    improved_signup_bot_detection_in_classic?: boolean;
    /** This tenant signed up for the Auth4GenAI trail */
    genai_trial?: boolean;
    /** Whether third-party developers can <a href="https://auth0.com/docs/api-auth/dynamic-client-registration">dynamically register</a> applications for your APIs (true) or not (false). This flag enables dynamic client registration. */
    enable_dynamic_client_registration?: boolean;
    /** If true, SMS phone numbers will not be obfuscated in Management API GET calls. */
    disable_management_api_sms_obfuscation?: boolean;
    /** Changes email_verified behavior for Azure AD/ADFS connections when enabled. Sets email_verified to false otherwise. */
    trust_azure_adfs_email_verified_connection_property?: boolean;
    /** If true, custom domains feature will be enabled for tenant. */
    custom_domains_provisioning?: boolean;
}

/**
 * Guardian page customization.
 */
export interface TenantSettingsGuardianPage {
    /** Whether to use the custom Guardian HTML (true) or the default Auth0 page (false, default) */
    enabled?: boolean;
    /**  Custom Guardian HTML (<a href='https://github.com/Shopify/liquid/wiki/Liquid-for-Designers'>Liquid syntax</a> is supported). */
    html?: string;
}

/**
 * mTLS configuration.
 */
export interface TenantSettingsMtls {
    /** If true, enables mTLS endpoint aliases */
    enable_endpoint_aliases?: boolean;
}

/**
 * Change Password page customization.
 */
export interface TenantSettingsPasswordPage {
    /** Whether to use the custom change password HTML (true) or the default Auth0 page (false). Default is to use the Auth0 page. */
    enabled?: boolean;
    /** Custom change password HTML (<a href='https://github.com/Shopify/liquid/wiki/Liquid-for-Designers'>Liquid syntax</a> supported). */
    html?: string;
}

/** Profile that determines how the identity of the protected resource (i.e., API) can be specified in the OAuth endpoints when access is being requested. When set to audience (default), the audience parameter is used to specify the resource server. When set to compatibility, the audience parameter is still checked first, but if it not provided, then the resource parameter can be used to specify the resource server. */
export const TenantSettingsResourceParameterProfile = {
    Audience: "audience",
    Compatibility: "compatibility",
} as const;
export type TenantSettingsResourceParameterProfile =
    (typeof TenantSettingsResourceParameterProfile)[keyof typeof TenantSettingsResourceParameterProfile];

/**
 * Sessions related settings for tenant
 */
export interface TenantSettingsSessions {
    /** Whether to bypass prompting logic (false) when performing OIDC Logout */
    oidc_logout_prompt_enabled?: boolean;
}

/**
 * The payload for the action.
 */
export type TestActionPayload = Record<string, unknown>;

export interface TestActionResponseContent {
    payload?: Management.TestActionResultPayload;
}

/**
 * The resulting payload after an action was executed.
 */
export type TestActionResultPayload = Record<string, unknown>;

export interface TestCustomDomainResponseContent {
    /** Result of the operation. */
    success: boolean;
    /** Message describing the operation status. */
    message?: string;
}

/**
 * The raw payload of the test event.
 */
export type TestEventDataContent = Record<string, unknown>;

export interface TokenExchangeProfileResponseContent {
    /** The unique ID of the token exchange profile. */
    id?: string;
    /** Friendly name of this profile. */
    name?: string;
    /** Subject token type for this profile. When receiving a token exchange request on the Authentication API, the corresponding token exchange profile with a matching subject_token_type will be executed. This must be a URI. */
    subject_token_type?: string;
    /** The ID of the Custom Token Exchange action to execute for this profile, in order to validate the subject_token. The action must use the custom-token-exchange trigger. */
    action_id?: string;
    type?: Management.TokenExchangeProfileTypeEnum;
    /** The time when this profile was created. */
    created_at?: string;
    /** The time when this profile was updated. */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * The type of the profile, which controls how the profile will be executed when receiving a token exchange request.
 */
export type TokenExchangeProfileTypeEnum = "custom_authentication";

export interface TokenQuota {
    client_credentials: Management.TokenQuotaClientCredentials;
}

/**
 * The token quota configuration
 */
export interface TokenQuotaClientCredentials {
    /** If enabled, the quota will be enforced and requests in excess of the quota will fail. If disabled, the quota will not be enforced, but notifications for requests exceeding the quota will be available in logs. */
    enforce?: boolean;
    /** Maximum number of issued tokens per day */
    per_day?: number;
    /** Maximum number of issued tokens per hour */
    per_hour?: number;
}

export interface TokenQuotaConfiguration {
    client_credentials: Management.TokenQuotaClientCredentials;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface TwilioProviderConfiguration {
    default_from?: string;
    mssid?: string;
    sid: string;
    delivery_methods: Management.TwilioProviderDeliveryMethodEnum[];
}

export interface TwilioProviderCredentials {
    auth_token: string;
}

export const TwilioProviderDeliveryMethodEnum = {
    Text: "text",
    Voice: "voice",
} as const;
export type TwilioProviderDeliveryMethodEnum =
    (typeof TwilioProviderDeliveryMethodEnum)[keyof typeof TwilioProviderDeliveryMethodEnum];

/** Which login experience to use. Can be `new` or `classic`. */
export const UniversalLoginExperienceEnum = {
    New: "new",
    Classic: "classic",
} as const;
export type UniversalLoginExperienceEnum =
    (typeof UniversalLoginExperienceEnum)[keyof typeof UniversalLoginExperienceEnum];

export interface UpdateActionBindingsResponseContent {
    bindings?: Management.ActionBinding[];
}

export interface UpdateActionResponseContent {
    /** The unique ID of the action. */
    id?: string;
    /** The name of an action. */
    name?: string;
    /** The list of triggers that this action supports. At this time, an action can only target a single trigger at a time. */
    supported_triggers?: Management.ActionTrigger[];
    /** True if all of an Action's contents have been deployed. */
    all_changes_deployed?: boolean;
    /** The time when this action was created. */
    created_at?: string;
    /** The time when this action was updated. */
    updated_at?: string;
    /** The source code of the action. */
    code?: string;
    /** The list of third party npm modules, and their versions, that this action depends on. */
    dependencies?: Management.ActionVersionDependency[];
    /** The Node runtime. For example: `node22`, defaults to `node22` */
    runtime?: string;
    /** The list of secrets that are included in an action or a version of an action. */
    secrets?: Management.ActionSecretResponse[];
    deployed_version?: Management.ActionDeployedVersion;
    /** installed_integration_id is the fk reference to the InstalledIntegration entity. */
    installed_integration_id?: string;
    integration?: Management.Integration;
    status?: Management.ActionBuildStatusEnum;
    /** The time when this action was built successfully. */
    built_at?: string;
    /** True if the action should be deployed after creation. */
    deploy?: boolean;
}

export interface UpdateAculResponseContent {
    rendering_mode?: Management.AculRenderingModeEnum;
    /** Context values to make available */
    context_configuration?: string[];
    /** Override Universal Login default head tags */
    default_head_tags_disabled?: boolean | null;
    /** An array of head tags */
    head_tags?: Management.AculHeadTag[];
    filters?: Management.AculFilters | null;
    /** Use page template with ACUL */
    use_page_template?: boolean | null;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface UpdateAttackProtectionCaptchaResponseContent {
    active_provider_id?: string;
    arkose?: Management.AttackProtectionCaptchaArkoseResponseContent;
    auth_challenge?: Management.AttackProtectionCaptchaAuthChallengeResponseContent;
    hcaptcha?: Management.AttackProtectionCaptchaHcaptchaResponseContent;
    friendly_captcha?: Management.AttackProtectionCaptchaFriendlyCaptchaResponseContent;
    recaptcha_enterprise?: Management.AttackProtectionCaptchaRecaptchaEnterpriseResponseContent;
    recaptcha_v2?: Management.AttackProtectionCaptchaRecaptchaV2ResponseContent;
    simple_captcha?: Management.AttackProtectionCaptchaSimpleCaptchaResponseContent;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface UpdateBotDetectionSettingsResponseContent {
    bot_detection_level?: Management.BotDetectionLevelEnum;
    challenge_password_policy?: Management.BotDetectionChallengePolicyPasswordFlowEnum;
    challenge_passwordless_policy?: Management.BotDetectionChallengePolicyPasswordlessFlowEnum;
    challenge_password_reset_policy?: Management.BotDetectionChallengePolicyPasswordResetFlowEnum;
    allowlist?: Management.BotDetectionAllowlist;
    monitoring_mode_enabled?: Management.BotDetectionMonitoringModeEnabled;
}

/**
 * Custom color settings.
 */
export interface UpdateBrandingColors {
    /** Accent color. */
    primary?: string | null;
    page_background?: Management.UpdateBrandingPageBackground;
}

/**
 * Custom font settings.
 */
export interface UpdateBrandingFont {
    /** URL for the custom font. The URL must point to a font file and not a stylesheet. Must use HTTPS. */
    url?: string | null;
}

/**
 * Page Background Color or Gradient.
 * Property contains either <code>null</code> to unset, a solid color as a string value <code>#FFFFFF</code>, or a gradient as an object.
 *
 * <pre><code>
 * {
 *   type: 'linear-gradient',
 *   start: '#FFFFFF',
 *   end: '#000000',
 *   angle_deg: 35
 * }
 * </code></pre>
 */
export type UpdateBrandingPageBackground = (string | null) | undefined | (Record<string, unknown> | null) | undefined;

/**
 * Phone provider configuration schema
 */
export interface UpdateBrandingPhoneProviderResponseContent {
    id?: string;
    /** The name of the tenant */
    tenant?: string;
    name: Management.PhoneProviderNameEnum;
    channel?: Management.PhoneProviderChannelEnum;
    /** Whether the provider is enabled (false) or disabled (true). */
    disabled?: boolean;
    configuration?: Management.PhoneProviderConfiguration;
    /** The provider's creation date and time in ISO 8601 format */
    created_at?: string;
    /** The date and time of the last update to the provider in ISO 8601 format */
    updated_at?: string;
}

export interface UpdateBrandingResponseContent {
    colors?: Management.BrandingColors;
    /** URL for the favicon. Must use HTTPS. */
    favicon_url?: string;
    /** URL for the logo. Must use HTTPS. */
    logo_url?: string;
    font?: Management.BrandingFont;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface UpdateBrandingThemeResponseContent {
    borders: Management.BrandingThemeBorders;
    colors: Management.BrandingThemeColors;
    /** Display Name */
    displayName: string;
    fonts: Management.BrandingThemeFonts;
    page_background: Management.BrandingThemePageBackground;
    /** Theme Id */
    themeId: string;
    widget: Management.BrandingThemeWidget;
}

export interface UpdateBreachedPasswordDetectionSettingsResponseContent {
    /** Whether or not breached password detection is active. */
    enabled?: boolean;
    /**
     * Action to take when a breached password is detected during a login.
     *       Possible values: <code>block</code>, <code>user_notification</code>, <code>admin_notification</code>.
     */
    shields?: Management.BreachedPasswordDetectionShieldsEnum[];
    /**
     * When "admin_notification" is enabled, determines how often email notifications are sent.
     *         Possible values: <code>immediately</code>, <code>daily</code>, <code>weekly</code>, <code>monthly</code>.
     */
    admin_notification_frequency?: Management.BreachedPasswordDetectionAdminNotificationFrequencyEnum[];
    method?: Management.BreachedPasswordDetectionMethodEnum;
    stage?: Management.BreachedPasswordDetectionStage;
}

export interface UpdateBruteForceSettingsResponseContent {
    /** Whether or not brute force attack protections are active. */
    enabled?: boolean;
    /**
     * Action to take when a brute force protection threshold is violated.
     *         Possible values: <code>block</code>, <code>user_notification</code>.
     */
    shields?: UpdateBruteForceSettingsResponseContent.Shields.Item[];
    /** List of trusted IP addresses that will not have attack protection enforced against them. */
    allowlist?: string[];
    /**
     * Account Lockout: Determines whether or not IP address is used when counting failed attempts.
     *           Possible values: <code>count_per_identifier_and_ip</code>, <code>count_per_identifier</code>.
     */
    mode?: UpdateBruteForceSettingsResponseContent.Mode;
    /** Maximum number of unsuccessful attempts. */
    max_attempts?: number;
}

export namespace UpdateBruteForceSettingsResponseContent {
    export type Shields = Shields.Item[];

    export namespace Shields {
        export const Item = {
            Block: "block",
            UserNotification: "user_notification",
        } as const;
        export type Item = (typeof Item)[keyof typeof Item];
    }

    /**
     * Account Lockout: Determines whether or not IP address is used when counting failed attempts.
     *           Possible values: <code>count_per_identifier_and_ip</code>, <code>count_per_identifier</code>.
     */
    export const Mode = {
        CountPerIdentifierAndIp: "count_per_identifier_and_ip",
        CountPerIdentifier: "count_per_identifier",
    } as const;
    export type Mode = (typeof Mode)[keyof typeof Mode];
}

export interface UpdateClientGrantResponseContent {
    /** ID of the client grant. */
    id?: string;
    /** ID of the client. */
    client_id?: string;
    /** The audience (API identifier) of this client grant. */
    audience?: string;
    /** Scopes allowed for this client grant. */
    scope?: string[];
    organization_usage?: Management.ClientGrantOrganizationUsageEnum;
    /** If enabled, any organization can be used with this grant. If disabled (default), the grant must be explicitly assigned to the desired organizations. */
    allow_any_organization?: boolean;
    /** If enabled, this grant is a special grant created by Auth0. It cannot be modified or deleted directly. */
    is_system?: boolean;
    subject_type?: Management.ClientGrantSubjectTypeEnum;
    /** Types of authorization_details allowed for this client grant. Use of this field is subject to the applicable Free Trial terms in Oktaâ€™s <a href= "https://www.okta.com/legal/"> Master Subscription Agreement.</a> */
    authorization_details_types?: string[];
}

export interface UpdateClientResponseContent {
    /** ID of this client. */
    client_id?: string;
    /** Name of the tenant this client belongs to. */
    tenant?: string;
    /** Name of this client (min length: 1 character, does not allow `<` or `>`). */
    name?: string;
    /** Free text description of this client (max length: 140 characters). */
    description?: string;
    /** Whether this is your global 'All Applications' client representing legacy tenant settings (true) or a regular client (false). */
    global?: boolean;
    /** Client secret (which you must not make public). */
    client_secret?: string;
    app_type?: Management.ClientAppTypeEnum;
    /** URL of the logo to display for this client. Recommended size is 150x150 pixels. */
    logo_uri?: string;
    /** Whether this client a first party client (true) or not (false). */
    is_first_party?: boolean;
    /** Whether this client conforms to <a href='https://auth0.com/docs/api-auth/tutorials/adoption'>strict OIDC specifications</a> (true) or uses legacy features (false). */
    oidc_conformant?: boolean;
    /** Comma-separated list of URLs whitelisted for Auth0 to use as a callback to the client after authentication. */
    callbacks?: string[];
    /** Comma-separated list of URLs allowed to make requests from JavaScript to Auth0 API (typically used with CORS). By default, all your callback URLs will be allowed. This field allows you to enter other origins if necessary. You can also use wildcards at the subdomain level (e.g., https://*.contoso.com). Query strings and hash information are not taken into account when validating these URLs. */
    allowed_origins?: string[];
    /** Comma-separated list of allowed origins for use with <a href='https://auth0.com/docs/cross-origin-authentication'>Cross-Origin Authentication</a>, <a href='https://auth0.com/docs/flows/concepts/device-auth'>Device Flow</a>, and <a href='https://auth0.com/docs/protocols/oauth2#how-response-mode-works'>web message response mode</a>. */
    web_origins?: string[];
    /** List of audiences/realms for SAML protocol. Used by the wsfed addon. */
    client_aliases?: string[];
    /** List of allow clients and API ids that are allowed to make delegation requests. Empty means all all your clients are allowed. */
    allowed_clients?: string[];
    /** Comma-separated list of URLs that are valid to redirect to after logout from Auth0. Wildcards are allowed for subdomains. */
    allowed_logout_urls?: string[];
    session_transfer?: Management.ClientSessionTransferConfiguration | null;
    oidc_logout?: Management.ClientOidcBackchannelLogoutSettings;
    /** List of grant types supported for this application. Can include `authorization_code`, `implicit`, `refresh_token`, `client_credentials`, `password`, `http://auth0.com/oauth/grant-type/password-realm`, `http://auth0.com/oauth/grant-type/mfa-oob`, `http://auth0.com/oauth/grant-type/mfa-otp`, `http://auth0.com/oauth/grant-type/mfa-recovery-code`, `urn:openid:params:grant-type:ciba`, `urn:ietf:params:oauth:grant-type:device_code`, and `urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token`. */
    grant_types?: string[];
    jwt_configuration?: Management.ClientJwtConfiguration;
    signing_keys?: Management.ClientSigningKeys;
    encryption_key?: Management.ClientEncryptionKey | null;
    /** Applies only to SSO clients and determines whether Auth0 will handle Single Sign On (true) or whether the Identity Provider will (false). */
    sso?: boolean;
    /** Whether Single Sign On is disabled (true) or enabled (true). Defaults to true. */
    sso_disabled?: boolean;
    /** Whether this client can be used to make cross-origin authentication requests (true) or it is not allowed to make such requests (false). */
    cross_origin_authentication?: boolean;
    /** URL of the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page. */
    cross_origin_loc?: string;
    /** Whether a custom login page is to be used (true) or the default provided login page (false). */
    custom_login_page_on?: boolean;
    /** The content (HTML, CSS, JS) of the custom login page. */
    custom_login_page?: string;
    /** The content (HTML, CSS, JS) of the custom login page. (Used on Previews) */
    custom_login_page_preview?: string;
    /** HTML form template to be used for WS-Federation. */
    form_template?: string;
    addons?: Management.ClientAddons;
    token_endpoint_auth_method?: Management.ClientTokenEndpointAuthMethodEnum;
    /** If true, trust that the IP specified in the `auth0-forwarded-for` header is the end-user's IP for brute-force-protection on token endpoint. */
    is_token_endpoint_ip_header_trusted?: boolean;
    client_metadata?: Management.ClientMetadata;
    mobile?: Management.ClientMobile;
    /** Initiate login uri, must be https */
    initiate_login_uri?: string;
    refresh_token?: Management.ClientRefreshTokenConfiguration | null;
    default_organization?: Management.ClientDefaultOrganization | null;
    organization_usage?: Management.ClientOrganizationUsageEnum;
    organization_require_behavior?: Management.ClientOrganizationRequireBehaviorEnum;
    /** Defines the available methods for organization discovery during the `pre_login_prompt`. Users can discover their organization either by `email`, `organization_name` or both. */
    organization_discovery_methods?: Management.ClientOrganizationDiscoveryEnum[];
    client_authentication_methods?: Management.ClientAuthenticationMethod | null;
    /** Makes the use of Pushed Authorization Requests mandatory for this client */
    require_pushed_authorization_requests?: boolean;
    /** Makes the use of Proof-of-Possession mandatory for this client */
    require_proof_of_possession?: boolean;
    signed_request_object?: Management.ClientSignedRequestObjectWithCredentialId;
    compliance_level?: Management.ClientComplianceLevelEnum | null;
    /**
     * Controls whether a confirmation prompt is shown during login flows when the redirect URI uses non-verifiable callback URIs (for example, a custom URI schema such as `myapp://`, or `localhost`).
     * If set to true, a confirmation prompt will not be shown. We recommend that this is set to false for improved protection from malicious apps.
     * See https://auth0.com/docs/secure/security-guidance/measures-against-app-impersonation for more information.
     */
    skip_non_verifiable_callback_uri_confirmation_prompt?: boolean;
    /** Specifies how long, in seconds, a Pushed Authorization Request URI remains valid */
    par_request_expiry?: number | null;
    token_quota?: Management.TokenQuota;
    express_configuration?: Management.ExpressConfiguration;
    /** The identifier of the resource server that this client is linked to. */
    resource_server_identifier?: string;
    async_approval_notification_channels?: Management.ClientAsyncApprovalNotificationsChannelsApiPostConfiguration;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * The connection's options (depend on the connection strategy). To update these options, the `update:connections_options` scope must be present. To verify your changes, also include the `read:connections_options` scope. If this scope is not specified, you will not be able to review the updated object.
 */
export interface UpdateConnectionOptions {
    validation?: Management.ConnectionValidationOptions | null;
    /** An array of user fields that should not be stored in the Auth0 database (https://auth0.com/docs/security/data-security/denylist) */
    non_persistent_attrs?: string[];
    /** Order of precedence for attribute types. If the property is not specified, the default precedence of attributes will be used. */
    precedence?: Management.ConnectionIdentifierPrecedenceEnum[];
    attributes?: Management.ConnectionAttributes;
    /** Set to true to inject context into custom DB scripts (warning: cannot be disabled once enabled) */
    enable_script_context?: boolean;
    /** Set to true to use a legacy user store */
    enabledDatabaseCustomization?: boolean;
    /** Enable this if you have a legacy user store and you want to gradually migrate those users to the Auth0 user store */
    import_mode?: boolean;
    customScripts?: Management.ConnectionCustomScripts;
    authentication_methods?: Management.ConnectionAuthenticationMethods | null;
    passkey_options?: Management.ConnectionPasskeyOptions | null;
    passwordPolicy?: Management.ConnectionPasswordPolicyEnum | null;
    password_complexity_options?: Management.ConnectionPasswordComplexityOptions | null;
    password_history?: Management.ConnectionPasswordHistoryOptions | null;
    password_no_personal_info?: Management.ConnectionPasswordNoPersonalInfoOptions | null;
    password_dictionary?: Management.ConnectionPasswordDictionaryOptions | null;
    api_enable_users?: boolean;
    basic_profile?: boolean;
    ext_admin?: boolean;
    ext_is_suspended?: boolean;
    ext_agreed_terms?: boolean;
    ext_groups?: boolean;
    ext_assigned_plans?: boolean;
    ext_profile?: boolean;
    disable_self_service_change_password?: boolean;
    upstream_params?: (Management.ConnectionUpstreamParams | undefined) | null;
    set_user_root_attributes?: Management.ConnectionSetUserRootAttributesEnum;
    gateway_authentication?: Management.ConnectionGatewayAuthentication | null;
    federated_connections_access_tokens?: Management.ConnectionFederatedConnectionsAccessTokens | null;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface UpdateConnectionProfileResponseContent {
    id?: Management.ConnectionProfileId;
    name?: Management.ConnectionProfileName;
    organization?: Management.ConnectionProfileOrganization;
    connection_name_prefix_template?: Management.ConnectionNamePrefixTemplate;
    enabled_features?: Management.ConnectionProfileEnabledFeatures;
    connection_config?: Management.ConnectionProfileConfig;
    strategy_overrides?: Management.ConnectionProfileStrategyOverrides;
}

export interface UpdateConnectionResponseContent {
    /** The name of the connection */
    name?: string;
    /** Connection name used in login screen */
    display_name?: string;
    options?: Management.ConnectionOptions;
    /** The connection's identifier */
    id?: string;
    /** The type of the connection, related to the identity provider */
    strategy?: string;
    /** Defines the realms for which the connection will be used (ie: email domains). If the array is empty or the property is not specified, the connection name will be added as realm. */
    realms?: string[];
    /** DEPRECATED property. Use the GET /connections/:id/clients endpoint to get the ids of the clients for which the connection is enabled */
    enabled_clients?: string[];
    /** True if the connection is domain level */
    is_domain_connection?: boolean;
    /** Enables showing a button for the connection in the login page (new experience only). If false, it will be usable only by HRD. */
    show_as_button?: boolean;
    metadata?: Management.ConnectionsMetadata;
    authentication?: Management.ConnectionAuthenticationPurpose;
    connected_accounts?: Management.ConnectionConnectedAccountsPurpose;
}

export interface UpdateCustomDomainResponseContent {
    /** ID of the custom domain. */
    custom_domain_id: string;
    /** Domain name. */
    domain: string;
    /** Whether this is a primary domain (true) or not (false). */
    primary: boolean;
    status: Management.CustomDomainStatusFilterEnum;
    type: Management.CustomDomainTypeEnum;
    verification: Management.DomainVerification;
    /** The HTTP header to fetch the client's IP address */
    custom_client_ip_header?: string | null;
    /** The TLS version policy */
    tls_policy?: string;
    certificate?: Management.DomainCertificate;
}

export interface UpdateEmailProviderResponseContent {
    /** Name of the email provider. Can be `mailgun`, `mandrill`, `sendgrid`, `ses`, `sparkpost`, `smtp`, `azure_cs`, `ms365`, or `custom`. */
    name?: string;
    /** Whether the provider is enabled (true) or disabled (false). */
    enabled?: boolean;
    /** Email address to use as "from" when no other address specified. */
    default_from_address?: string;
    credentials?: Management.EmailProviderCredentials;
    settings?: Management.EmailProviderSettings;
}

export interface UpdateEmailTemplateResponseContent {
    template?: Management.EmailTemplateNameEnum;
    /** Body of the email template. */
    body?: string | null;
    /** Senders `from` email address. */
    from?: string | null;
    /** URL to redirect the user to after a successful action. */
    resultUrl?: string | null;
    /** Subject line of the email. */
    subject?: string | null;
    /** Syntax of the template body. */
    syntax?: string | null;
    /** Lifetime in seconds that the link within the email will be valid for. */
    urlLifetimeInSeconds?: number | null;
    /** Whether the `reset_email` and `verify_email` templates should include the user's email address as the `email` parameter in the returnUrl (true) or whether no email address should be included in the redirect (false). Defaults to true. */
    includeEmailInRedirect?: boolean;
    /** Whether the template is enabled (true) or disabled (false). */
    enabled?: boolean | null;
}

export interface UpdateEnabledClientConnectionsRequestContentItem {
    /** The client_id of the client to be the subject to change status */
    client_id: string;
    /** Whether the connection is enabled or not for this client_id */
    status: boolean;
}

export type UpdateEnabledClientConnectionsRequestContent =
    Management.UpdateEnabledClientConnectionsRequestContentItem[];

export type UpdateEventStreamResponseContent =
    | Management.EventStreamWebhookResponseContent
    | Management.EventStreamEventBridgeResponseContent
    | Management.EventStreamActionResponseContent;

export interface UpdateFlowResponseContent {
    id: string;
    name: string;
    actions?: Management.FlowAction[];
    created_at: string;
    updated_at: string;
    executed_at?: string;
}

export interface UpdateFlowsVaultConnectionResponseContent {
    /** Flows Vault Connection identifier. */
    id: string;
    /** Flows Vault Connection app identifier. */
    app_id: string;
    /** Flows Vault Connection environment. */
    environment?: string;
    /** Flows Vault Connection name. */
    name: string;
    /** Flows Vault Connection custom account name. */
    account_name?: string;
    /** Whether the Flows Vault Connection is configured. */
    ready: boolean;
    /** The ISO 8601 formatted date when this Flows Vault Connection was created. */
    created_at: string;
    /** The ISO 8601 formatted date when this Flows Vault Connection was updated. */
    updated_at: string;
    /** The ISO 8601 formatted date when this Flows Vault Connection was refreshed. */
    refreshed_at?: string;
    fingerprint: string;
}

/**
 * Flows Vault Connection configuration.
 */
export type UpdateFlowsVaultConnectionSetup =
    | Management.FlowsVaultConnectioSetupApiKeyWithBaseUrl
    | Management.FlowsVaultConnectioSetupApiKey
    | Management.FlowsVaultConnectioSetupOauthApp
    | Management.FlowsVaultConnectioSetupBigqueryOauthJwt
    | Management.FlowsVaultConnectioSetupSecretApiKey
    | Management.FlowsVaultConnectioSetupHttpBearer
    | Management.FlowsVaultConnectioSetupJwt
    | Management.FlowsVaultConnectioSetupMailjetApiKey
    | Management.FlowsVaultConnectioSetupToken
    | Management.FlowsVaultConnectioSetupWebhook
    | Management.FlowsVaultConnectioSetupStripeKeyPair
    | Management.FlowsVaultConnectioSetupOauthCode
    | Management.FlowsVaultConnectioSetupTwilioApiKey;

export interface UpdateFormResponseContent {
    id: string;
    name: string;
    messages?: Management.FormMessages;
    languages?: Management.FormLanguages;
    translations?: Management.FormTranslations;
    nodes?: Management.FormNodeList;
    start?: Management.FormStartNode;
    ending?: Management.FormEndingNode;
    style?: Management.FormStyle;
    created_at: string;
    updated_at: string;
    embedded_at?: string;
    submitted_at?: string;
}

export interface UpdateGuardianFactorDuoSettingsResponseContent {
    ikey?: string;
    skey?: string;
    host?: string;
}

export interface UpdateGuardianFactorsProviderPushNotificationSnsResponseContent {
    aws_access_key_id?: string | null;
    aws_secret_access_key?: string | null;
    aws_region?: string | null;
    sns_apns_platform_application_arn?: string | null;
    sns_gcm_platform_application_arn?: string | null;
}

export interface UpdateHookResponseContent {
    /** Trigger ID */
    triggerId?: string;
    /** ID of this hook. */
    id?: string;
    /** Name of this hook. */
    name?: string;
    /** Whether this hook will be executed (true) or ignored (false). */
    enabled?: boolean;
    /** Code to be executed when this hook runs. */
    script?: string;
    dependencies?: Management.HookDependencies;
}

/**
 * Hashmap of key-value pairs where the value must be a string.
 */
export type UpdateHookSecretRequestContent = Record<string, string>;

export type UpdateLogStreamResponseContent =
    | Management.LogStreamHttpResponseSchema
    | Management.LogStreamEventBridgeResponseSchema
    | Management.LogStreamEventGridResponseSchema
    | Management.LogStreamDatadogResponseSchema
    | Management.LogStreamSplunkResponseSchema
    | Management.LogStreamSumoResponseSchema
    | Management.LogStreamSegmentResponseSchema
    | Management.LogStreamMixpanelResponseSchema;

export interface UpdateNetworkAclResponseContent {
    id?: string;
    description?: string;
    active?: boolean;
    priority?: number;
    rule?: Management.NetworkAclRule;
    /** The timestamp when the Network ACL Configuration was created */
    created_at?: string;
    /** The timestamp when the Network ACL Configuration was last updated */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface UpdateOrganizationConnectionResponseContent {
    /** ID of the connection. */
    connection_id?: string;
    /** When true, all users that log in with this connection will be automatically granted membership in the organization. When false, users must be granted membership in the organization before logging in with this connection. */
    assign_membership_on_login?: boolean;
    /** Determines whether a connection should be displayed on this organizationâ€™s login prompt. Only applicable for enterprise connections. Default: true. */
    show_as_button?: boolean;
    /** Determines whether organization signup should be enabled for this organization connection. Only applicable for database connections. Default: false. */
    is_signup_enabled?: boolean;
    connection?: Management.OrganizationConnectionInformation;
}

export interface UpdateOrganizationDiscoveryDomainResponseContent {
    /** Organization discovery domain identifier. */
    id: string;
    /** The domain name to associate with the organization e.g. acme.com. */
    domain: string;
    status: Management.OrganizationDiscoveryDomainStatus;
    /** A unique token generated for the discovery domain. This must be placed in a DNS TXT record at the location specified by the verification_host field to prove domain ownership. */
    verification_txt: string;
    /** The full domain where the TXT record should be added. */
    verification_host: string;
}

export interface UpdateOrganizationResponseContent {
    /** Organization identifier. */
    id?: string;
    /** The name of this organization. */
    name?: string;
    /** Friendly name of this organization. */
    display_name?: string;
    branding?: Management.OrganizationBranding;
    metadata?: Management.OrganizationMetadata;
    token_quota?: Management.TokenQuota;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface UpdatePhoneTemplateResponseContent {
    id: string;
    channel?: string;
    customizable?: boolean;
    tenant?: string;
    content: Management.PhoneTemplateContent;
    type: Management.PhoneTemplateNotificationTypeEnum;
    /** Whether the template is enabled (false) or disabled (true). */
    disabled: boolean;
}

export interface UpdateResourceServerResponseContent {
    /** ID of the API (resource server). */
    id?: string;
    /** Friendly name for this resource server. Can not contain `<` or `>` characters. */
    name?: string;
    /** Whether this is an Auth0 system API (true) or a custom API (false). */
    is_system?: boolean;
    /** Unique identifier for the API used as the audience parameter on authorization calls. Can not be changed once set. */
    identifier?: string;
    /** List of permissions (scopes) that this API uses. */
    scopes?: Management.ResourceServerScope[];
    signing_alg?: Management.SigningAlgorithmEnum;
    /** Secret used to sign tokens when using symmetric algorithms (HS256). */
    signing_secret?: string;
    /** Whether refresh tokens can be issued for this API (true) or not (false). */
    allow_offline_access?: boolean;
    /** Whether to skip user consent for applications flagged as first party (true) or not (false). */
    skip_consent_for_verifiable_first_party_clients?: boolean;
    /** Expiration value (in seconds) for access tokens issued for this API from the token endpoint. */
    token_lifetime?: number;
    /** Expiration value (in seconds) for access tokens issued for this API via Implicit or Hybrid Flows. Cannot be greater than the `token_lifetime` value. */
    token_lifetime_for_web?: number;
    /** Whether authorization polices are enforced (true) or unenforced (false). */
    enforce_policies?: boolean;
    token_dialect?: Management.ResourceServerTokenDialectResponseEnum;
    token_encryption?: Management.ResourceServerTokenEncryption | null;
    consent_policy?: (Management.ResourceServerConsentPolicyEnum | undefined) | null;
    authorization_details?: unknown[];
    proof_of_possession?: Management.ResourceServerProofOfPossession | null;
    subject_type_authorization?: Management.ResourceServerSubjectTypeAuthorization;
    /** The client ID of the client that this resource server is linked to */
    client_id?: string;
}

export interface UpdateRiskAssessmentsSettingsNewDeviceResponseContent {
    /** Length of time to remember devices for, in days. */
    remember_for: number;
}

export interface UpdateRiskAssessmentsSettingsResponseContent {
    /** Whether or not risk assessment is enabled. */
    enabled: boolean;
}

export interface UpdateRoleResponseContent {
    /** ID for this role. */
    id?: string;
    /** Name of this role. */
    name?: string;
    /** Description of this role. */
    description?: string;
}

export interface UpdateRuleResponseContent {
    /** Name of this rule. */
    name?: string;
    /** ID of this rule. */
    id?: string;
    /** Whether the rule is enabled (true), or disabled (false). */
    enabled?: boolean;
    /** Code to be executed when this rule runs. */
    script?: string;
    /** Order that this rule should execute in relative to other rules. Lower-valued rules execute first. */
    order?: number;
    /** Execution stage of this rule. Can be `login_success`, `login_failure`, or `pre_authorize`. */
    stage?: string;
}

export interface UpdateScimConfigurationResponseContent {
    /** The connection's identifier */
    connection_id?: string;
    /** The connection's identifier */
    connection_name?: string;
    /** The connection's strategy */
    strategy?: string;
    /** The tenant's name */
    tenant_name?: string;
    /** User ID attribute for generating unique user ids */
    user_id_attribute?: string;
    /** The mapping between auth0 and SCIM */
    mapping?: Management.ScimMappingItem[];
    /** The Date Time Scim Configuration was created */
    created_at?: string;
    /** The Date Time Scim Configuration was last updated */
    updated_on?: string;
}

export interface UpdateSelfServiceProfileResponseContent {
    /** The unique ID of the self-service Profile. */
    id?: string;
    /** The name of the self-service Profile. */
    name?: string;
    /** The description of the self-service Profile. */
    description?: string;
    /** List of attributes to be mapped that will be shown to the user during the SS-SSO flow. */
    user_attributes?: Management.SelfServiceProfileUserAttribute[];
    /** The time when this self-service Profile was created. */
    created_at?: string;
    /** The time when this self-service Profile was updated. */
    updated_at?: string;
    branding?: Management.SelfServiceProfileBrandingProperties;
    /** List of IdP strategies that will be shown to users during the Self-Service SSO flow. Possible values: [`oidc`, `samlp`, `waad`, `google-apps`, `adfs`, `okta`, `keycloak-samlp`, `pingfederate`] */
    allowed_strategies?: Management.SelfServiceProfileAllowedStrategyEnum[];
    /** ID of the user-attribute-profile to associate with this self-service profile. */
    user_attribute_profile_id?: string;
}

export interface UpdateSessionResponseContent {
    /** The ID of the session */
    id?: string;
    /** ID of the user which can be used when interacting with other APIs. */
    user_id?: string;
    created_at?: Management.SessionDate;
    updated_at?: Management.SessionDate;
    authenticated_at?: Management.SessionDate;
    idle_expires_at?: Management.SessionDate;
    expires_at?: Management.SessionDate;
    last_interacted_at?: Management.SessionDate;
    device?: Management.SessionDeviceMetadata;
    /** List of client details for the session */
    clients?: Management.SessionClientMetadata[];
    authentication?: Management.SessionAuthenticationSignals;
    cookie?: Management.SessionCookieMetadata;
    session_metadata?: (Management.SessionMetadata | undefined) | null;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface UpdateSettingsResponseContent {
    universal_login_experience?: Management.UniversalLoginExperienceEnum;
    /** Whether identifier first is enabled or not */
    identifier_first?: boolean;
    /** Use WebAuthn with Device Biometrics as the first authentication factor */
    webauthn_platform_first_factor?: boolean;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface UpdateSuspiciousIpThrottlingSettingsResponseContent {
    /** Whether or not suspicious IP throttling attack protections are active. */
    enabled?: boolean;
    /**
     * Action to take when a suspicious IP throttling threshold is violated.
     *           Possible values: <code>block</code>, <code>admin_notification</code>.
     */
    shields?: Management.SuspiciousIpThrottlingShieldsEnum[];
    allowlist?: Management.SuspiciousIpThrottlingAllowlist;
    stage?: Management.SuspiciousIpThrottlingStage;
}

export interface UpdateTenantSettingsResponseContent {
    change_password?: Management.TenantSettingsPasswordPage | null;
    guardian_mfa_page?: Management.TenantSettingsGuardianPage | null;
    /** Default audience for API authorization. */
    default_audience?: string;
    /** Name of connection used for password grants at the `/token`endpoint. The following connection types are supported: LDAP, AD, Database Connections, Passwordless, Windows Azure Active Directory, ADFS. */
    default_directory?: string;
    error_page?: Management.TenantSettingsErrorPage | null;
    device_flow?: Management.TenantSettingsDeviceFlow | null;
    default_token_quota?: Management.DefaultTokenQuota | null;
    flags?: Management.TenantSettingsFlags;
    /** Friendly name for this tenant. */
    friendly_name?: string;
    /** URL of logo to be shown for this tenant (recommended size: 150x150) */
    picture_url?: string;
    /** End-user support email address. */
    support_email?: string;
    /** End-user support URL. */
    support_url?: string;
    /** URLs that are valid to redirect to after logout from Auth0. */
    allowed_logout_urls?: string[];
    /** Number of hours a session will stay valid. */
    session_lifetime?: number;
    /** Number of hours for which a session can be inactive before the user must log in again. */
    idle_session_lifetime?: number;
    /** Number of hours an ephemeral (non-persistent) session will stay valid. */
    ephemeral_session_lifetime?: number;
    /** Number of hours for which an ephemeral (non-persistent) session can be inactive before the user must log in again. */
    idle_ephemeral_session_lifetime?: number;
    /** Selected sandbox version for the extensibility environment. */
    sandbox_version?: string;
    /** Selected sandbox version for rules and hooks extensibility. */
    legacy_sandbox_version?: string;
    /** Available sandbox versions for the extensibility environment. */
    sandbox_versions_available?: string[];
    /** The default absolute redirection uri, must be https */
    default_redirection_uri?: string;
    /** Supported locales for the user interface. */
    enabled_locales?: Management.SupportedLocales[];
    session_cookie?: Management.SessionCookieSchema | null;
    sessions?: Management.TenantSettingsSessions | null;
    oidc_logout?: Management.TenantOidcLogoutSettings;
    /** Whether to accept an organization name instead of an ID on auth endpoints */
    allow_organization_name_in_authentication_api?: boolean;
    /** Whether to enable flexible factors for MFA in the PostLogin action */
    customize_mfa_in_postlogin_action?: boolean;
    /** Supported ACR values */
    acr_values_supported?: string[];
    mtls?: Management.TenantSettingsMtls | null;
    /** Enables the use of Pushed Authorization Requests */
    pushed_authorization_requests_supported?: boolean;
    /** Supports iss parameter in authorization responses */
    authorization_response_iss_parameter_supported?: boolean | null;
    /**
     * Controls whether a confirmation prompt is shown during login flows when the redirect URI uses non-verifiable callback URIs (for example, a custom URI schema such as `myapp://`, or `localhost`).
     * If set to true, a confirmation prompt will not be shown. We recommend that this is set to false for improved protection from malicious apps.
     * See https://auth0.com/docs/secure/security-guidance/measures-against-app-impersonation for more information.
     */
    skip_non_verifiable_callback_uri_confirmation_prompt?: boolean | null;
    resource_parameter_profile?: Management.TenantSettingsResourceParameterProfile;
}

export interface UpdateTokenQuota {
    client_credentials: Management.TokenQuotaClientCredentials;
}

export type UpdateUniversalLoginTemplateRequestContent =
    | string
    | {
          template: string;
      };

export interface UpdateUserAttributeProfileResponseContent {
    id?: Management.UserAttributeProfileId;
    name?: Management.UserAttributeProfileName;
    user_id?: Management.UserAttributeProfileUserId;
    user_attributes?: Management.UserAttributeProfileUserAttributes;
}

/**
 * The successfully created authentication method.
 */
export interface UpdateUserAuthenticationMethodResponseContent {
    /** The ID of the newly created authentication method (automatically generated by the application) */
    id?: string;
    type: Management.CreatedAuthenticationMethodTypeEnum;
    /** A human-readable label to identify the authentication method. */
    name?: string;
    /** Base32 encoded secret for TOTP generation */
    totp_secret?: string;
    /** Applies to phone authentication methods only. The destination phone number used to send verification codes via text and voice. */
    phone_number?: string;
    /** Applies to email authentication methods only. The email address used to send verification messages. */
    email?: string;
    authentication_methods?: Management.UserAuthenticationMethodProperties[];
    preferred_authentication_method?: Management.PreferredAuthenticationMethodEnum;
    /** Applies to webauthn authentication methods only. The id of the credential. */
    key_id?: string;
    /** Applies to webauthn authentication methods only. The public key. */
    public_key?: string;
    /** Applies to passkey authentication methods only. Authenticator Attestation Globally Unique Identifier. */
    aaguid?: string;
    /** Applies to webauthn authentication methods only. The relying party identifier. */
    relying_party_identifier?: string;
    /** Authentication method creation date */
    created_at?: string;
}

export interface UpdateUserResponseContent {
    /** ID of the user which can be used when interacting with other APIs. */
    user_id?: string;
    /** Email address of this user. */
    email?: string;
    /** Whether this email address is verified (true) or unverified (false). */
    email_verified?: boolean;
    /** Username of this user. */
    username?: string;
    /** Phone number for this user. Follows the <a href="https://en.wikipedia.org/wiki/E.164">E.164 recommendation</a>. */
    phone_number?: string;
    /** Whether this phone number has been verified (true) or not (false). */
    phone_verified?: boolean;
    created_at?: Management.UserDateSchema;
    updated_at?: Management.UserDateSchema;
    /** Array of user identity objects when accounts are linked. */
    identities?: Management.UserIdentitySchema[];
    app_metadata?: Management.UserAppMetadataSchema;
    user_metadata?: Management.UserMetadataSchema;
    /** URL to picture, photo, or avatar of this user. */
    picture?: string;
    /** Name of this user. */
    name?: string;
    /** Preferred nickname or alias of this user. */
    nickname?: string;
    /** List of multi-factor authentication providers with which this user has enrolled. */
    multifactor?: string[];
    /** Last IP address from which this user logged in. */
    last_ip?: string;
    last_login?: Management.UserDateSchema;
    /** Total number of logins this user has performed. */
    logins_count?: number;
    /** Whether this user was blocked by an administrator (true) or is not (false). */
    blocked?: boolean;
    /** Given name/first name/forename of this user. */
    given_name?: string;
    /** Family name/last name/surname of this user. */
    family_name?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface UpdateVerifiableCredentialTemplateResponseContent {
    /** The id of the template. */
    id?: string;
    /** The name of the template. */
    name?: string;
    /** The type of the template. */
    type?: string;
    /** The dialect of the template. */
    dialect?: string;
    presentation?: Management.MdlPresentationRequest;
    /** The custom certificate authority. */
    custom_certificate_authority?: string;
    /** The well-known trusted issuers, comma separated. */
    well_known_trusted_issuers?: string;
    /** The date and time the template was created. */
    created_at?: string;
    /** The date and time the template was created. */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

/**
 * User metadata to which this user has read-only access.
 */
export type UserAppMetadataSchema = Record<string, unknown>;

export interface UserAttributeProfile {
    id?: Management.UserAttributeProfileId;
    name?: Management.UserAttributeProfileName;
    user_id?: Management.UserAttributeProfileUserId;
    user_attributes?: Management.UserAttributeProfileUserAttributes;
}

/**
 * User Attribute Profile identifier.
 */
export type UserAttributeProfileId = string;

/**
 * The name of the user attribute profile.
 */
export type UserAttributeProfileName = string;

/**
 * OIDC mapping for this attribute
 */
export interface UserAttributeProfileOidcMapping {
    /** OIDC mapping field */
    mapping: string;
    /** Display name for the OIDC mapping */
    display_name?: string;
}

export type UserAttributeProfilePatchUserId = (Management.UserAttributeProfileUserId | null) | undefined;

/**
 * SAML mapping override for this strategy
 */
export type UserAttributeProfileSamlMapping = string[];

/**
 * Strategy-specific overrides for this attribute
 */
export interface UserAttributeProfileStrategyOverrides {
    pingfederate?: Management.UserAttributeProfileStrategyOverridesMapping;
    ad?: Management.UserAttributeProfileStrategyOverridesMapping;
    adfs?: Management.UserAttributeProfileStrategyOverridesMapping;
    waad?: Management.UserAttributeProfileStrategyOverridesMapping;
    "google-apps"?: Management.UserAttributeProfileStrategyOverridesMapping;
    okta?: Management.UserAttributeProfileStrategyOverridesMapping;
    oidc?: Management.UserAttributeProfileStrategyOverridesMapping;
    samlp?: Management.UserAttributeProfileStrategyOverridesMapping;
}

export interface UserAttributeProfileStrategyOverridesMapping {
    oidc_mapping?: Management.UserAttributeProfileOidcMapping;
    saml_mapping?: Management.UserAttributeProfileSamlMapping;
    /** SCIM mapping override for this strategy */
    scim_mapping?: string;
}

/**
 * Strategy-specific overrides for user ID
 */
export interface UserAttributeProfileStrategyOverridesUserId {
    pingfederate?: Management.UserAttributeProfileStrategyOverridesUserIdMapping;
    ad?: Management.UserAttributeProfileStrategyOverridesUserIdMapping;
    adfs?: Management.UserAttributeProfileStrategyOverridesUserIdMapping;
    waad?: Management.UserAttributeProfileStrategyOverridesUserIdMapping;
    "google-apps"?: Management.UserAttributeProfileStrategyOverridesUserIdMapping;
    okta?: Management.UserAttributeProfileStrategyOverridesUserIdMapping;
    oidc?: Management.UserAttributeProfileStrategyOverridesUserIdMapping;
    samlp?: Management.UserAttributeProfileStrategyOverridesUserIdMapping;
}

export interface UserAttributeProfileStrategyOverridesUserIdMapping {
    oidc_mapping?: Management.UserAttributeProfileUserIdOidcStrategyOverrideMapping;
    saml_mapping?: Management.UserAttributeProfileSamlMapping;
    /** SCIM mapping override for this strategy */
    scim_mapping?: string;
}

/**
 * The structure of the template, which can be used as the payload for creating or updating a User Attribute Profile.
 */
export interface UserAttributeProfileTemplate {
    name?: Management.UserAttributeProfileName;
    user_id?: Management.UserAttributeProfileUserId;
    user_attributes?: Management.UserAttributeProfileUserAttributes;
}

export interface UserAttributeProfileTemplateItem {
    /** The id of the template. */
    id?: string;
    /** The user-friendly name of the template displayed in the UI. */
    display_name?: string;
    template?: Management.UserAttributeProfileTemplate;
}

export interface UserAttributeProfileUserAttributeAdditionalProperties {
    /** Description of this attribute */
    description: string;
    /** Display label for this attribute */
    label: string;
    /** Whether this attribute is required in the profile */
    profile_required: boolean;
    /** Auth0 mapping for this attribute */
    auth0_mapping: string;
    oidc_mapping?: Management.UserAttributeProfileOidcMapping;
    saml_mapping?: Management.UserAttributeProfileSamlMapping;
    /** SCIM mapping for this attribute */
    scim_mapping?: string;
    strategy_overrides?: Management.UserAttributeProfileStrategyOverrides;
}

/**
 * User attributes configuration map. Keys are attribute names, values are the mapping configuration for each attribute.
 */
export type UserAttributeProfileUserAttributes = Record<
    string,
    Management.UserAttributeProfileUserAttributeAdditionalProperties
>;

/**
 * User ID mapping configuration
 */
export interface UserAttributeProfileUserId {
    oidc_mapping?: Management.UserAttributeProfileUserIdOidcMappingEnum;
    saml_mapping?: Management.UserAttributeProfileUserIdSamlMapping;
    /** SCIM mapping for user ID */
    scim_mapping?: string;
    strategy_overrides?: Management.UserAttributeProfileStrategyOverridesUserId;
}

/**
 * OIDC mapping for user ID
 */
export type UserAttributeProfileUserIdOidcMappingEnum = "sub";

/** OIDC mapping override for this strategy */
export const UserAttributeProfileUserIdOidcStrategyOverrideMapping = {
    Sub: "sub",
    Oid: "oid",
    Email: "email",
} as const;
export type UserAttributeProfileUserIdOidcStrategyOverrideMapping =
    (typeof UserAttributeProfileUserIdOidcStrategyOverrideMapping)[keyof typeof UserAttributeProfileUserIdOidcStrategyOverrideMapping];

/**
 * SAML mapping for user ID
 */
export type UserAttributeProfileUserIdSamlMapping = string[];

export interface UserAuthenticationMethod {
    /** The ID of the authentication method (auto generated) */
    id: string;
    type: Management.AuthenticationMethodTypeEnum;
    /** The authentication method status */
    confirmed?: boolean;
    /** A human-readable label to identify the authentication method */
    name?: string;
    authentication_methods?: Management.UserAuthenticationMethodProperties[];
    preferred_authentication_method?: Management.PreferredAuthenticationMethodEnum;
    /** The ID of a linked authentication method. Linked authentication methods will be deleted together. */
    link_id?: string;
    /** Applies to phone authentication methods only. The destination phone number used to send verification codes via text and voice. */
    phone_number?: string;
    /** Applies to email and email-verification authentication methods only. The email address used to send verification messages. */
    email?: string;
    /** Applies to webauthn authentication methods only. The ID of the generated credential. */
    key_id?: string;
    /** Applies to webauthn authentication methods only. The public key. */
    public_key?: string;
    /** Authenticator creation date */
    created_at: string;
    /** Enrollment date */
    enrolled_at?: string;
    /** Last authentication */
    last_auth_at?: string;
    /** Applies to passkeys only. The kind of device the credential is stored on as defined by backup eligibility. "single_device" credentials cannot be backed up and synced to another device, "multi_device" credentials can be backed up if enabled by the end-user. */
    credential_device_type?: string;
    /** Applies to passkeys only. Whether the credential was backed up. */
    credential_backed_up?: boolean;
    /** Applies to passkeys only. The ID of the user identity linked with the authentication method. */
    identity_user_id?: string;
    /** Applies to passkeys only. The user-agent of the browser used to create the passkey. */
    user_agent?: string;
    /** Applies to passkey authentication methods only. Authenticator Attestation Globally Unique Identifier. */
    aaguid?: string;
    /** Applies to webauthn/passkey authentication methods only. The credential's relying party identifier. */
    relying_party_identifier?: string;
}

export interface UserAuthenticationMethodProperties {
    type?: Management.UserAuthenticationMethodPropertiesEnum;
    id?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export const UserAuthenticationMethodPropertiesEnum = {
    Totp: "totp",
    Push: "push",
    Sms: "sms",
    Voice: "voice",
} as const;
export type UserAuthenticationMethodPropertiesEnum =
    (typeof UserAuthenticationMethodPropertiesEnum)[keyof typeof UserAuthenticationMethodPropertiesEnum];

export interface UserBlockIdentifier {
    /** Identifier (should be any of an `email`, `username`, or `phone_number`) */
    identifier?: string;
    /** IP Address */
    ip?: string;
    /** Connection identifier */
    connection?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export type UserDateSchema =
    /**
     * Date and time when this user was created (ISO_8601 format). */
    | string
    /**
     * Date and time when this user was created (ISO_8601 format). */
    | Record<string, unknown>;

/** Authentication method for this enrollment. Can be `authenticator`, `guardian`, `sms`, `webauthn-roaming`, or `webauthn-platform`. */
export const UserEnrollmentAuthMethodEnum = {
    Authenticator: "authenticator",
    Guardian: "guardian",
    Sms: "sms",
    WebauthnPlatform: "webauthn-platform",
    WebauthnRoaming: "webauthn-roaming",
} as const;
export type UserEnrollmentAuthMethodEnum =
    (typeof UserEnrollmentAuthMethodEnum)[keyof typeof UserEnrollmentAuthMethodEnum];

/** Status of this enrollment. Can be `pending` or `confirmed`. */
export const UserEnrollmentStatusEnum = {
    Pending: "pending",
    Confirmed: "confirmed",
} as const;
export type UserEnrollmentStatusEnum = (typeof UserEnrollmentStatusEnum)[keyof typeof UserEnrollmentStatusEnum];

export interface UserGrant {
    /** ID of the grant. */
    id?: string;
    /** ID of the client. */
    clientID?: string;
    /** ID of the user. */
    user_id?: string;
    /** Audience of the grant. */
    audience?: string;
    /** Scopes included in this grant. */
    scope?: string[];
}

export interface UserGroupsResponseSchema extends Management.Group {
    /** Timestamp of when the group membership was added. */
    membership_created_at?: string;
}

/**
 * user_id of the secondary user account being linked.
 */
export type UserId = string | number;

export interface UserIdentity {
    /** Connection name of this identity. */
    connection: string;
    user_id: Management.UserId;
    /** Type of identity provider. */
    provider: string;
    profileData?: Management.UserProfileData;
    /** Whether the identity provider is a social provider (true) or not (false). */
    isSocial?: boolean;
    /** IDP access token returned if scope `read:user_idp_tokens` is defined. */
    access_token?: string;
    /** IDP access token secret returned only if `scope read:user_idp_tokens` is defined. */
    access_token_secret?: string;
    /** IDP refresh token returned only if scope `read:user_idp_tokens` is defined. */
    refresh_token?: string;
}

/** The type of identity provider */
export const UserIdentityProviderEnum = {
    Ad: "ad",
    Adfs: "adfs",
    Amazon: "amazon",
    Apple: "apple",
    Dropbox: "dropbox",
    Bitbucket: "bitbucket",
    Aol: "aol",
    Auth0Oidc: "auth0-oidc",
    Auth0: "auth0",
    Baidu: "baidu",
    Bitly: "bitly",
    Box: "box",
    Custom: "custom",
    Daccount: "daccount",
    Dwolla: "dwolla",
    Email: "email",
    EvernoteSandbox: "evernote-sandbox",
    Evernote: "evernote",
    Exact: "exact",
    Facebook: "facebook",
    Fitbit: "fitbit",
    Flickr: "flickr",
    Github: "github",
    GoogleApps: "google-apps",
    GoogleOauth2: "google-oauth2",
    Instagram: "instagram",
    Ip: "ip",
    Line: "line",
    Linkedin: "linkedin",
    Miicard: "miicard",
    Oauth1: "oauth1",
    Oauth2: "oauth2",
    Office365: "office365",
    Oidc: "oidc",
    Okta: "okta",
    Paypal: "paypal",
    PaypalSandbox: "paypal-sandbox",
    Pingfederate: "pingfederate",
    Planningcenter: "planningcenter",
    Renren: "renren",
    SalesforceCommunity: "salesforce-community",
    SalesforceSandbox: "salesforce-sandbox",
    Salesforce: "salesforce",
    Samlp: "samlp",
    Sharepoint: "sharepoint",
    Shopify: "shopify",
    Shop: "shop",
    Sms: "sms",
    Soundcloud: "soundcloud",
    ThecitySandbox: "thecity-sandbox",
    Thecity: "thecity",
    Thirtysevensignals: "thirtysevensignals",
    Twitter: "twitter",
    Untappd: "untappd",
    Vkontakte: "vkontakte",
    Waad: "waad",
    Weibo: "weibo",
    Windowslive: "windowslive",
    Wordpress: "wordpress",
    Yahoo: "yahoo",
    Yammer: "yammer",
    Yandex: "yandex",
} as const;
export type UserIdentityProviderEnum = (typeof UserIdentityProviderEnum)[keyof typeof UserIdentityProviderEnum];

export interface UserIdentitySchema {
    /** Name of the connection containing this identity. */
    connection?: string;
    /** Unique identifier of the user user for this identity. */
    user_id?: string;
    provider?: Management.UserIdentityProviderEnum;
    /** Whether this identity is from a social provider (true) or not (false). */
    isSocial?: boolean;
    /** IDP access token returned only if scope read:user_idp_tokens is defined. */
    access_token?: string;
    /** IDP access token secret returned only if scope read:user_idp_tokens is defined. */
    access_token_secret?: string;
    /** IDP refresh token returned only if scope read:user_idp_tokens is defined. */
    refresh_token?: string;
    profileData?: Management.UserProfileData;
}

export interface UserListLogOffsetPaginatedResponseContent {
    start?: number;
    limit?: number;
    length?: number;
    total?: number;
    logs?: Management.Log[];
}

/**
 * Data related to the user that does not affect the application's core functionality.
 */
export type UserMetadata = Record<string, unknown>;

/**
 * User metadata to which this user has read/write access.
 */
export type UserMetadataSchema = Record<string, unknown>;

/** The multi-factor provider. Supported values 'duo' or 'google-authenticator' */
export const UserMultifactorProviderEnum = {
    Duo: "duo",
    GoogleAuthenticator: "google-authenticator",
} as const;
export type UserMultifactorProviderEnum =
    (typeof UserMultifactorProviderEnum)[keyof typeof UserMultifactorProviderEnum];

export interface UserPermissionSchema {
    /** Resource server (API) identifier that this permission is for. */
    resource_server_identifier?: string;
    /** Name of this permission. */
    permission_name?: string;
    /** Resource server (API) name this permission is for. */
    resource_server_name?: string;
    /** Description of this permission. */
    description?: string;
}

export interface UserProfileData {
    /** Email address of this user. */
    email?: string;
    /** Whether this email address is verified (true) or unverified (false). */
    email_verified?: boolean;
    /** Name of this user. */
    name?: string;
    /** Username of this user. */
    username?: string;
    /** Given name/first name/forename of this user. */
    given_name?: string;
    /** Phone number for this user. */
    phone_number?: string;
    /** Whether this phone number is verified (true) or unverified (false). */
    phone_verified?: boolean;
    /** Family name/last name/surname of this user. */
    family_name?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface UserResponseSchema {
    /** ID of the user which can be used when interacting with other APIs. */
    user_id?: string;
    /** Email address of this user. */
    email?: string;
    /** Whether this email address is verified (true) or unverified (false). */
    email_verified?: boolean;
    /** Username of this user. */
    username?: string;
    /** Phone number for this user. Follows the <a href="https://en.wikipedia.org/wiki/E.164">E.164 recommendation</a>. */
    phone_number?: string;
    /** Whether this phone number has been verified (true) or not (false). */
    phone_verified?: boolean;
    created_at?: Management.UserDateSchema;
    updated_at?: Management.UserDateSchema;
    /** Array of user identity objects when accounts are linked. */
    identities?: Management.UserIdentitySchema[];
    app_metadata?: Management.UserAppMetadataSchema;
    user_metadata?: Management.UserMetadataSchema;
    /** URL to picture, photo, or avatar of this user. */
    picture?: string;
    /** Name of this user. */
    name?: string;
    /** Preferred nickname or alias of this user. */
    nickname?: string;
    /** List of multi-factor authentication providers with which this user has enrolled. */
    multifactor?: string[];
    /** Last IP address from which this user logged in. */
    last_ip?: string;
    last_login?: Management.UserDateSchema;
    /** Total number of logins this user has performed. */
    logins_count?: number;
    /** Whether this user was blocked by an administrator (true) or is not (false). */
    blocked?: boolean;
    /** Given name/first name/forename of this user. */
    given_name?: string;
    /** Family name/last name/surname of this user. */
    family_name?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface UsernameAllowedTypes {
    email?: boolean;
    phone_number?: boolean;
}

/**
 * Configuration for the username attribute for users.
 */
export interface UsernameAttribute {
    identifier?: Management.ConnectionAttributeIdentifier;
    /** Determines if property should be required for users */
    profile_required?: boolean;
    signup?: Management.SignupSchema;
    validation?: Management.UsernameValidation;
}

export interface UsernameValidation {
    /** Minimum allowed length */
    min_length?: number;
    /** Maximum allowed length */
    max_length?: number;
    allowed_types?: Management.UsernameAllowedTypes;
}

export interface UsersEnrollment {
    /** ID of this enrollment. */
    id?: string;
    status?: Management.UserEnrollmentStatusEnum;
    /** Type of enrollment. */
    type?: string;
    /** Name of enrollment (usually phone number). */
    name?: string;
    /** Device identifier (usually phone identifier) of this enrollment. */
    identifier?: string;
    /** Phone number for this enrollment. */
    phone_number?: string;
    auth_method?: Management.UserEnrollmentAuthMethodEnum;
    /** Start date and time of this enrollment. */
    enrolled_at?: string;
    /** Last authentication date and time of this enrollment. */
    last_auth?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export interface VerifiableCredentialTemplateResponse {
    /** The id of the template. */
    id?: string;
    /** The name of the template. */
    name?: string;
    /** The type of the template. */
    type?: string;
    /** The dialect of the template. */
    dialect?: string;
    presentation?: Management.MdlPresentationRequest;
    /** The custom certificate authority. */
    custom_certificate_authority?: string;
    /** The well-known trusted issuers, comma separated. */
    well_known_trusted_issuers?: string;
    /** The date and time the template was created. */
    created_at?: string;
    /** The date and time the template was created. */
    updated_at?: string;
    /** Accepts any additional properties */
    [key: string]: any;
}

export const VerificationMethodEnum = {
    Link: "link",
    Otp: "otp",
} as const;
export type VerificationMethodEnum = (typeof VerificationMethodEnum)[keyof typeof VerificationMethodEnum];

export interface VerifyCustomDomainResponseContent {
    /** ID of the custom domain. */
    custom_domain_id: string;
    /** Domain name. */
    domain: string;
    /** Whether this is a primary domain (true) or not (false). */
    primary: boolean;
    status: Management.CustomDomainStatusFilterEnum;
    type: Management.CustomDomainTypeEnum;
    /** CNAME API key header. */
    cname_api_key?: string;
    /** Intermediate address. */
    origin_domain_name?: string;
    verification?: Management.DomainVerification;
    /** The HTTP header to fetch the client's IP address */
    custom_client_ip_header?: string | null;
    /** The TLS version policy */
    tls_policy?: string;
    certificate?: Management.DomainCertificate;
}

export interface VerifyEmailTicketResponseContent {
    /** URL representing the ticket. */
    ticket: string;
    /** Accepts any additional properties */
    [key: string]: any;
}
