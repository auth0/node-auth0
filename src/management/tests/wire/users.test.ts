// This file was auto-generated by Fern from our API Definition.

import { mockServerPool } from "../mock-server/MockServerPool";
import { ManagementClient } from "../../Client";
import * as Management from "../../api/index";

describe("UsersClient", () => {
    test("list (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            start: 1.1,
            limit: 1.1,
            length: 1.1,
            total: 1.1,
            users: [
                {
                    user_id: "user_id",
                    email: "email",
                    email_verified: true,
                    username: "username",
                    phone_number: "phone_number",
                    phone_verified: true,
                    created_at: "created_at",
                    updated_at: "updated_at",
                    identities: [{}],
                    app_metadata: { key: "value" },
                    user_metadata: { key: "value" },
                    picture: "picture",
                    name: "name",
                    nickname: "nickname",
                    multifactor: ["multifactor"],
                    last_ip: "last_ip",
                    last_login: "last_login",
                    logins_count: 1,
                    blocked: true,
                    given_name: "given_name",
                    family_name: "family_name",
                },
            ],
        };
        server
            .mockEndpoint({ once: false })
            .get("/users")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const expected = {
            start: 1.1,
            limit: 1.1,
            length: 1.1,
            total: 1.1,
            users: [
                {
                    user_id: "user_id",
                    email: "email",
                    email_verified: true,
                    username: "username",
                    phone_number: "phone_number",
                    phone_verified: true,
                    created_at: "created_at",
                    updated_at: "updated_at",
                    identities: [{}],
                    app_metadata: {
                        key: "value",
                    },
                    user_metadata: {
                        key: "value",
                    },
                    picture: "picture",
                    name: "name",
                    nickname: "nickname",
                    multifactor: ["multifactor"],
                    last_ip: "last_ip",
                    last_login: "last_login",
                    logins_count: 1,
                    blocked: true,
                    given_name: "given_name",
                    family_name: "family_name",
                },
            ],
        };
        const page = await client.users.list({
            page: 1,
            per_page: 1,
            include_totals: true,
            sort: "sort",
            connection: "connection",
            fields: "fields",
            include_fields: true,
            q: "q",
            search_engine: "v1",
            primary_order: true,
        });

        expect(expected.users).toEqual(page.data);
        expect(page.hasNextPage()).toBe(true);
        const nextPage = await page.getNextPage();
        expect(expected.users).toEqual(nextPage.data);
    });

    test("list (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint({ once: false })
            .get("/users")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.list();
        }).rejects.toThrow(Management.BadRequestError);
    });

    test("list (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint({ once: false })
            .get("/users")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.list();
        }).rejects.toThrow(Management.UnauthorizedError);
    });

    test("list (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint({ once: false })
            .get("/users")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.list();
        }).rejects.toThrow(Management.ForbiddenError);
    });

    test("list (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint({ once: false })
            .get("/users")
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.list();
        }).rejects.toThrow(Management.TooManyRequestsError);
    });

    test("list (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint({ once: false })
            .get("/users")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.list();
        }).rejects.toThrow(Management.ServiceUnavailableError);
    });

    test("create (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { connection: "connection" };
        const rawResponseBody = {
            user_id: "user_id",
            email: "email",
            email_verified: true,
            username: "username",
            phone_number: "phone_number",
            phone_verified: true,
            created_at: "created_at",
            updated_at: "updated_at",
            identities: [
                {
                    connection: "connection",
                    user_id: "user_id",
                    provider: "ad",
                    isSocial: true,
                    access_token: "access_token",
                    access_token_secret: "access_token_secret",
                    refresh_token: "refresh_token",
                },
            ],
            app_metadata: { key: "value" },
            user_metadata: { key: "value" },
            picture: "picture",
            name: "name",
            nickname: "nickname",
            multifactor: ["multifactor"],
            last_ip: "last_ip",
            last_login: "last_login",
            logins_count: 1,
            blocked: true,
            given_name: "given_name",
            family_name: "family_name",
        };
        server
            .mockEndpoint()
            .post("/users")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.users.create({
            connection: "connection",
        });
        expect(response).toEqual({
            user_id: "user_id",
            email: "email",
            email_verified: true,
            username: "username",
            phone_number: "phone_number",
            phone_verified: true,
            created_at: "created_at",
            updated_at: "updated_at",
            identities: [
                {
                    connection: "connection",
                    user_id: "user_id",
                    provider: "ad",
                    isSocial: true,
                    access_token: "access_token",
                    access_token_secret: "access_token_secret",
                    refresh_token: "refresh_token",
                },
            ],
            app_metadata: {
                key: "value",
            },
            user_metadata: {
                key: "value",
            },
            picture: "picture",
            name: "name",
            nickname: "nickname",
            multifactor: ["multifactor"],
            last_ip: "last_ip",
            last_login: "last_login",
            logins_count: 1,
            blocked: true,
            given_name: "given_name",
            family_name: "family_name",
        });
    });

    test("create (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { connection: "Initial-Connection" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.create({
                connection: "Initial-Connection",
            });
        }).rejects.toThrow(Management.BadRequestError);
    });

    test("create (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { connection: "Initial-Connection" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.create({
                connection: "Initial-Connection",
            });
        }).rejects.toThrow(Management.UnauthorizedError);
    });

    test("create (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { connection: "Initial-Connection" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.create({
                connection: "Initial-Connection",
            });
        }).rejects.toThrow(Management.ForbiddenError);
    });

    test("create (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { connection: "Initial-Connection" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(409)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.create({
                connection: "Initial-Connection",
            });
        }).rejects.toThrow(Management.ConflictError);
    });

    test("create (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = { connection: "Initial-Connection" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.create({
                connection: "Initial-Connection",
            });
        }).rejects.toThrow(Management.TooManyRequestsError);
    });

    test("listUsersByEmail (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                user_id: "user_id",
                email: "email",
                email_verified: true,
                username: "username",
                phone_number: "phone_number",
                phone_verified: true,
                created_at: "created_at",
                updated_at: "updated_at",
                identities: [{}],
                app_metadata: { key: "value" },
                user_metadata: { key: "value" },
                picture: "picture",
                name: "name",
                nickname: "nickname",
                multifactor: ["multifactor"],
                last_ip: "last_ip",
                last_login: "last_login",
                logins_count: 1,
                blocked: true,
                given_name: "given_name",
                family_name: "family_name",
            },
        ];
        server.mockEndpoint().get("/users-by-email").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.users.listUsersByEmail({
            fields: "fields",
            include_fields: true,
            email: "email",
        });
        expect(response).toEqual([
            {
                user_id: "user_id",
                email: "email",
                email_verified: true,
                username: "username",
                phone_number: "phone_number",
                phone_verified: true,
                created_at: "created_at",
                updated_at: "updated_at",
                identities: [{}],
                app_metadata: {
                    key: "value",
                },
                user_metadata: {
                    key: "value",
                },
                picture: "picture",
                name: "name",
                nickname: "nickname",
                multifactor: ["multifactor"],
                last_ip: "last_ip",
                last_login: "last_login",
                logins_count: 1,
                blocked: true,
                given_name: "given_name",
                family_name: "family_name",
            },
        ]);
    });

    test("listUsersByEmail (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/users-by-email").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.listUsersByEmail({
                email: "email",
            });
        }).rejects.toThrow(Management.BadRequestError);
    });

    test("listUsersByEmail (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/users-by-email").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.listUsersByEmail({
                email: "email",
            });
        }).rejects.toThrow(Management.UnauthorizedError);
    });

    test("listUsersByEmail (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/users-by-email").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.listUsersByEmail({
                email: "email",
            });
        }).rejects.toThrow(Management.ForbiddenError);
    });

    test("listUsersByEmail (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/users-by-email").respondWith().statusCode(429).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.listUsersByEmail({
                email: "email",
            });
        }).rejects.toThrow(Management.TooManyRequestsError);
    });

    test("get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            user_id: "user_id",
            email: "email",
            email_verified: true,
            username: "username",
            phone_number: "phone_number",
            phone_verified: true,
            created_at: "created_at",
            updated_at: "updated_at",
            identities: [
                {
                    connection: "connection",
                    user_id: "user_id",
                    provider: "ad",
                    isSocial: true,
                    access_token: "access_token",
                    access_token_secret: "access_token_secret",
                    refresh_token: "refresh_token",
                },
            ],
            app_metadata: { key: "value" },
            user_metadata: { key: "value" },
            picture: "picture",
            name: "name",
            nickname: "nickname",
            multifactor: ["multifactor"],
            last_ip: "last_ip",
            last_login: "last_login",
            logins_count: 1,
            blocked: true,
            given_name: "given_name",
            family_name: "family_name",
        };
        server.mockEndpoint().get("/users/id").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.users.get("id", {
            fields: "fields",
            include_fields: true,
        });
        expect(response).toEqual({
            user_id: "user_id",
            email: "email",
            email_verified: true,
            username: "username",
            phone_number: "phone_number",
            phone_verified: true,
            created_at: "created_at",
            updated_at: "updated_at",
            identities: [
                {
                    connection: "connection",
                    user_id: "user_id",
                    provider: "ad",
                    isSocial: true,
                    access_token: "access_token",
                    access_token_secret: "access_token_secret",
                    refresh_token: "refresh_token",
                },
            ],
            app_metadata: {
                key: "value",
            },
            user_metadata: {
                key: "value",
            },
            picture: "picture",
            name: "name",
            nickname: "nickname",
            multifactor: ["multifactor"],
            last_ip: "last_ip",
            last_login: "last_login",
            logins_count: 1,
            blocked: true,
            given_name: "given_name",
            family_name: "family_name",
        });
    });

    test("get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/users/id").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.get("id");
        }).rejects.toThrow(Management.BadRequestError);
    });

    test("get (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/users/id").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.get("id");
        }).rejects.toThrow(Management.UnauthorizedError);
    });

    test("get (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/users/id").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.get("id");
        }).rejects.toThrow(Management.ForbiddenError);
    });

    test("get (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/users/id").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.get("id");
        }).rejects.toThrow(Management.NotFoundError);
    });

    test("get (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/users/id").respondWith().statusCode(429).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.get("id");
        }).rejects.toThrow(Management.TooManyRequestsError);
    });

    test("delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        server.mockEndpoint().delete("/users/id").respondWith().statusCode(200).build();

        const response = await client.users.delete("id");
        expect(response).toEqual(undefined);
    });

    test("delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().delete("/users/id").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.delete("id");
        }).rejects.toThrow(Management.BadRequestError);
    });

    test("delete (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().delete("/users/id").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.delete("id");
        }).rejects.toThrow(Management.UnauthorizedError);
    });

    test("delete (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().delete("/users/id").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.delete("id");
        }).rejects.toThrow(Management.ForbiddenError);
    });

    test("delete (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().delete("/users/id").respondWith().statusCode(429).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.users.delete("id");
        }).rejects.toThrow(Management.TooManyRequestsError);
    });

    test("update (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            user_id: "user_id",
            email: "email",
            email_verified: true,
            username: "username",
            phone_number: "phone_number",
            phone_verified: true,
            created_at: "created_at",
            updated_at: "updated_at",
            identities: [
                {
                    connection: "connection",
                    user_id: "user_id",
                    provider: "ad",
                    isSocial: true,
                    access_token: "access_token",
                    access_token_secret: "access_token_secret",
                    refresh_token: "refresh_token",
                },
            ],
            app_metadata: { key: "value" },
            user_metadata: { key: "value" },
            picture: "picture",
            name: "name",
            nickname: "nickname",
            multifactor: ["multifactor"],
            last_ip: "last_ip",
            last_login: "last_login",
            logins_count: 1,
            blocked: true,
            given_name: "given_name",
            family_name: "family_name",
        };
        server
            .mockEndpoint()
            .patch("/users/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.users.update("id");
        expect(response).toEqual({
            user_id: "user_id",
            email: "email",
            email_verified: true,
            username: "username",
            phone_number: "phone_number",
            phone_verified: true,
            created_at: "created_at",
            updated_at: "updated_at",
            identities: [
                {
                    connection: "connection",
                    user_id: "user_id",
                    provider: "ad",
                    isSocial: true,
                    access_token: "access_token",
                    access_token_secret: "access_token_secret",
                    refresh_token: "refresh_token",
                },
            ],
            app_metadata: {
                key: "value",
            },
            user_metadata: {
                key: "value",
            },
            picture: "picture",
            name: "name",
            nickname: "nickname",
            multifactor: ["multifactor"],
            last_ip: "last_ip",
            last_login: "last_login",
            logins_count: 1,
            blocked: true,
            given_name: "given_name",
            family_name: "family_name",
        });
    });

    test("update (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/users/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.update("id");
        }).rejects.toThrow(Management.BadRequestError);
    });

    test("update (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/users/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.update("id");
        }).rejects.toThrow(Management.UnauthorizedError);
    });

    test("update (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/users/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.update("id");
        }).rejects.toThrow(Management.ForbiddenError);
    });

    test("update (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/users/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.update("id");
        }).rejects.toThrow(Management.NotFoundError);
    });

    test("update (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/users/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.update("id");
        }).rejects.toThrow(Management.TooManyRequestsError);
    });

    test("regenerateRecoveryCode (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { recovery_code: "recovery_code" };
        server
            .mockEndpoint()
            .post("/users/id/recovery-code-regeneration")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.users.regenerateRecoveryCode("id");
        expect(response).toEqual({
            recovery_code: "recovery_code",
        });
    });

    test("regenerateRecoveryCode (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users/id/recovery-code-regeneration")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.regenerateRecoveryCode("id");
        }).rejects.toThrow(Management.BadRequestError);
    });

    test("regenerateRecoveryCode (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users/id/recovery-code-regeneration")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.regenerateRecoveryCode("id");
        }).rejects.toThrow(Management.UnauthorizedError);
    });

    test("regenerateRecoveryCode (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users/id/recovery-code-regeneration")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.regenerateRecoveryCode("id");
        }).rejects.toThrow(Management.ForbiddenError);
    });

    test("regenerateRecoveryCode (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users/id/recovery-code-regeneration")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.regenerateRecoveryCode("id");
        }).rejects.toThrow(Management.NotFoundError);
    });

    test("revokeAccess (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = {};

        server
            .mockEndpoint()
            .post("/users/id/revoke-access")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .build();

        const response = await client.users.revokeAccess("id");
        expect(response).toEqual(undefined);
    });

    test("revokeAccess (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users/id/revoke-access")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.revokeAccess("id");
        }).rejects.toThrow(Management.BadRequestError);
    });

    test("revokeAccess (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users/id/revoke-access")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.revokeAccess("id");
        }).rejects.toThrow(Management.UnauthorizedError);
    });

    test("revokeAccess (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users/id/revoke-access")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.revokeAccess("id");
        }).rejects.toThrow(Management.ForbiddenError);
    });

    test("revokeAccess (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new ManagementClient({ maxRetries: 0, token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/users/id/revoke-access")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(429)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.users.revokeAccess("id");
        }).rejects.toThrow(Management.TooManyRequestsError);
    });
});
